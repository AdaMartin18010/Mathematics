# 03-量子数学物理 | Quantum Mathematical Physics

## 目录

- [03-量子数学物理 | Quantum Mathematical Physics](#03-量子数学物理--quantum-mathematical-physics)
  - [目录](#目录)
  - [1. 主题简介 | Topic Introduction](#1-主题简介--topic-introduction)
  - [2. 量子力学数学基础 | Mathematical Foundations of Quantum Mechanics](#2-量子力学数学基础--mathematical-foundations-of-quantum-mechanics)
    - [2.1 量子态与波函数 | Quantum States \& Wave Functions](#21-量子态与波函数--quantum-states--wave-functions)
    - [2.2 算符与可观测量 | Operators \& Observables](#22-算符与可观测量--operators--observables)
    - [2.3 测量与坍缩 | Measurement \& Collapse](#23-测量与坍缩--measurement--collapse)
  - [3. 希尔伯特空间与算子理论 | Hilbert Spaces \& Operator Theory](#3-希尔伯特空间与算子理论--hilbert-spaces--operator-theory)
    - [3.1 希尔伯特空间结构 | Hilbert Space Structure](#31-希尔伯特空间结构--hilbert-space-structure)
    - [3.2 谱理论 | Spectral Theory](#32-谱理论--spectral-theory)
  - [4. 量子场论数学框架 | Mathematical Framework of Quantum Field Theory](#4-量子场论数学框架--mathematical-framework-of-quantum-field-theory)
    - [4.1 量子场 | Quantum Fields](#41-量子场--quantum-fields)
    - [4.2 路径积分 | Path Integrals](#42-路径积分--path-integrals)
  - [5. 量子信息与量子计算 | Quantum Information \& Quantum Computing](#5-量子信息与量子计算--quantum-information--quantum-computing)
    - [5.1 量子比特 | Qubits](#51-量子比特--qubits)
    - [5.2 量子算法 | Quantum Algorithms](#52-量子算法--quantum-algorithms)
    - [5.3 量子纠缠 | Quantum Entanglement](#53-量子纠缠--quantum-entanglement)
  - [6. 相关性与本地跳转 | Relevance \& Local Navigation](#6-相关性与本地跳转--relevance--local-navigation)
  - [进度日志 | Progress Log](#进度日志--progress-log)

---

## 1. 主题简介 | Topic Introduction

量子数学物理是现代物理学与数学交叉的最前沿领域，从希尔伯特空间的数学结构到量子场论的代数框架，再到量子信息论的数学基础，这一领域不仅推动了物理理论的革命性发展，也为数学本身带来了深刻的变革。

Quantum mathematical physics is the most cutting-edge field of intersection between modern physics and mathematics, from the mathematical structure of Hilbert spaces to the algebraic framework of quantum field theory, to the mathematical foundations of quantum information theory. This field has not only driven revolutionary developments in physical theory but also brought profound changes to mathematics itself.

---

## 2. 量子力学数学基础 | Mathematical Foundations of Quantum Mechanics

### 2.1 量子态与波函数 | Quantum States & Wave Functions

**量子态的形式化定义：**

```lean
-- 希尔伯特空间
structure hilbert_space :=
  (carrier : Type)
  (inner_product : carrier → carrier → ℂ)
  (complete : cauchy_sequences_converge)
  (separable : ∃ countable_dense_subset)

-- 量子态
def quantum_state (H : hilbert_space) : Prop :=
  ∀ ψ : H.carrier, ⟨ψ, ψ⟩ = 1

-- 波函数
def wave_function (ψ : ℝ → ℂ) : Prop :=
  ∫ |ψ(x)|² dx = 1 ∧ ψ ∈ L²(ℝ)
```

**薛定谔方程：**

```lean
-- 时间相关薛定谔方程
def schrodinger_equation (ψ : ℝ → ℝ → ℂ) (V : ℝ → ℝ) : Prop :=
  iℏ ∂ψ/∂t = -ℏ²/(2m) ∂²ψ/∂x² + V(x)ψ

-- 时间无关薛定谔方程
def time_independent_schrodinger (ψ : ℝ → ℂ) (V : ℝ → ℝ) (E : ℝ) : Prop :=
  -ℏ²/(2m) d²ψ/dx² + V(x)ψ = Eψ
```

### 2.2 算符与可观测量 | Operators & Observables

**线性算符：**

```lean
-- 线性算符
structure linear_operator (H : hilbert_space) :=
  (map : H.carrier → H.carrier)
  (linear : ∀ a b : ℂ, ∀ ψ φ : H.carrier,
    map(a*ψ + b*φ) = a*map(ψ) + b*map(φ))

-- 厄米算符（自伴算符）
def hermitian_operator (A : linear_operator H) : Prop :=
  ∀ ψ φ : H.carrier, ⟨A(ψ), φ⟩ = ⟨ψ, A(φ)⟩

-- 幺正算符
def unitary_operator (U : linear_operator H) : Prop :=
  ∀ ψ φ : H.carrier, ⟨U(ψ), U(φ)⟩ = ⟨ψ, φ⟩
```

**位置和动量算符：**

```lean
-- 位置算符
def position_operator (ψ : ℝ → ℂ) (x : ℝ) : ℂ :=
  x * ψ(x)

-- 动量算符
def momentum_operator (ψ : ℝ → ℂ) (x : ℝ) : ℂ :=
  -iℏ * dψ/dx(x)

-- 对易关系
theorem canonical_commutation_relation :
  [x̂, p̂] = x̂p̂ - p̂x̂ = iℏ
```

### 2.3 测量与坍缩 | Measurement & Collapse

**测量公设：**

```lean
-- 测量公设
def measurement_postulate (ψ : quantum_state) (A : hermitian_operator) :
  measurement_result :=
  let eigenvalues = eigen_values A
  let probabilities = |⟨ψ, eigenvector⟩|²
  sample_from_distribution eigenvalues probabilities

-- 波函数坍缩
def wave_function_collapse (ψ : quantum_state) (eigenvalue : ℝ) :
  quantum_state :=
  project_onto_eigenspace ψ eigenvalue
```

---

## 3. 希尔伯特空间与算子理论 | Hilbert Spaces & Operator Theory

### 3.1 希尔伯特空间结构 | Hilbert Space Structure

**内积空间：**

```lean
-- 内积空间
structure inner_product_space :=
  (carrier : Type)
  (inner_product : carrier → carrier → ℂ)
  (positive_definite : ∀ v ≠ 0, ⟨v, v⟩ > 0)
  (conjugate_symmetric : ∀ v w, ⟨v, w⟩ = ⟨w, v⟩*)
  (linear_in_first : ∀ a b : ℂ, ∀ u v w, ⟨a*u + b*v, w⟩ = a*⟨u, w⟩ + b*⟨v, w⟩)

-- 完备性
def complete_space (V : inner_product_space) : Prop :=
  ∀ cauchy_sequence : ℕ → V.carrier,
    ∃ limit : V.carrier, sequence_converges_to cauchy_sequence limit
```

**正交基：**

```lean
-- 正交基
def orthonormal_basis (H : hilbert_space) (B : set H.carrier) : Prop :=
  (∀ v ∈ B, ⟨v, v⟩ = 1) ∧  -- 归一化
  (∀ v w ∈ B, v ≠ w → ⟨v, w⟩ = 0) ∧  -- 正交
  (span B = H.carrier)  -- 完备性

-- 傅里叶展开
theorem fourier_expansion (ψ : H.carrier) (B : orthonormal_basis H) :
  ψ = ∑ᵥ∈B ⟨v, ψ⟩ * v
```

### 3.2 谱理论 | Spectral Theory

**本征值与本征向量：**

```lean
-- 本征值问题
def eigenvalue_problem (A : linear_operator H) (λ : ℂ) (v : H.carrier) : Prop :=
  A(v) = λ * v ∧ v ≠ 0

-- 谱分解
theorem spectral_decomposition (A : hermitian_operator H) :
  A = ∑ᵢ λᵢ * Pᵢ
  where λᵢ are eigenvalues and Pᵢ are projection operators
```

**连续谱：**

```lean
-- 连续谱
def continuous_spectrum (A : operator H) : set ℂ :=
  {λ | (A - λI)⁻¹ exists but is not bounded}

-- 离散谱
def discrete_spectrum (A : operator H) : set ℂ :=
  {λ | λ is eigenvalue of A}
```

---

## 4. 量子场论数学框架 | Mathematical Framework of Quantum Field Theory

### 4.1 量子场 | Quantum Fields

**标量场：**

```lean
-- 标量量子场
def scalar_quantum_field (φ : ℝ⁴ → operator) : Prop :=
  ∀ x y : ℝ⁴, [φ(x), φ(y)] = iΔ(x-y)
  where Δ is the commutator function

-- 克莱因-戈登方程
def klein_gordon_equation (φ : ℝ⁴ → ℂ) (m : ℝ) : Prop :=
  (∂²/∂t² - ∇² + m²)φ = 0
```

**费米子场：**

```lean
-- 费米子场
def fermion_field (ψ : ℝ⁴ → spinor) : Prop :=
  ∀ x y : ℝ⁴, {ψ(x), ψ(y)} = iS(x-y)
  where S is the anticommutator function

-- 狄拉克方程
def dirac_equation (ψ : ℝ⁴ → ℂ⁴) (m : ℝ) : Prop :=
  (iγᵅ∂ᵅ - m)ψ = 0
  where γᵅ are Dirac matrices
```

### 4.2 路径积分 | Path Integrals

**费曼路径积分：**

```lean
-- 路径积分
def path_integral (q_i q_f : ℝ) (t_i t_f : ℝ) : ℂ :=
  ∫ D[q(t)] exp(iS[q(t)]/ℏ)
  where S is the action functional

-- 作用量
def action (q : ℝ → ℝ) (t_i t_f : ℝ) : ℝ :=
  ∫[t_i,t_f] L(q(t), q̇(t)) dt
  where L is the Lagrangian
```

**泛函积分：**

```python
# 路径积分的数值实现
import numpy as np
from scipy.integrate import quad

def path_integral_numerical(q_i, q_f, t_i, t_f, n_paths=1000):
    """路径积分的蒙特卡洛实现"""
    def action_path(q_path):
        """计算路径的作用量"""
        dt = (t_f - t_i) / len(q_path)
        S = 0
        for i in range(len(q_path) - 1):
            q = q_path[i]
            q_dot = (q_path[i+1] - q) / dt
            S += 0.5 * q_dot**2 * dt  # 自由粒子拉格朗日量
        return S
    
    # 生成随机路径
    paths = []
    for _ in range(n_paths):
        path = np.random.normal(0, 1, 100)
        path[0] = q_i
        path[-1] = q_f
        paths.append(path)
    
    # 计算路径积分
    integral = 0
    for path in paths:
        S = action_path(path)
        integral += np.exp(1j * S / hbar)
    
    return integral / n_paths
```

---

## 5. 量子信息与量子计算 | Quantum Information & Quantum Computing

### 5.1 量子比特 | Qubits

**量子比特定义：**

```lean
-- 量子比特
def qubit : Type :=
  {|ψ⟩ : ℂ² | ⟨ψ|ψ⟩ = 1}

-- 计算基
def computational_basis : set qubit :=
  {|0⟩, |1⟩}
  where |0⟩ = [1, 0]ᵀ and |1⟩ = [0, 1]ᵀ

-- 叠加态
def superposition (α β : ℂ) : qubit :=
  α|0⟩ + β|1⟩
  where |α|² + |β|² = 1
```

**量子门：**

```python
import numpy as np

class QuantumGate:
    def __init__(self, matrix):
        self.matrix = np.array(matrix)
    
    def apply(self, qubit):
        return self.matrix @ qubit

# 常用量子门
H = QuantumGate([[1, 1], [1, -1]]) / np.sqrt(2)  # 哈达玛门
X = QuantumGate([[0, 1], [1, 0]])  # Pauli-X门
Y = QuantumGate([[0, -1j], [1j, 0]])  # Pauli-Y门
Z = QuantumGate([[1, 0], [0, -1]])  # Pauli-Z门

def hadamard_gate(qubit):
    """应用哈达玛门"""
    return H.apply(qubit)

def cnot_gate(control, target):
    """受控非门"""
    if control == 1:
        return 1 - target  # 翻转目标比特
    else:
        return target
```

### 5.2 量子算法 | Quantum Algorithms

**量子傅里叶变换：**

```python
def quantum_fourier_transform(qubits):
    """量子傅里叶变换"""
    n = len(qubits)
    result = np.zeros(n, dtype=complex)
    
    for i in range(n):
        for j in range(n):
            phase = 2 * np.pi * i * j / n
            result[i] += qubits[j] * np.exp(1j * phase)
    
    return result / np.sqrt(n)

def qft_circuit(n_qubits):
    """量子傅里叶变换电路"""
    circuit = []
    
    for i in range(n_qubits):
        # 应用哈达玛门
        circuit.append(('H', i))
        
        # 应用受控相位门
        for j in range(i + 1, n_qubits):
            phase = 2 * np.pi / (2**(j - i))
            circuit.append(('CP', i, j, phase))
    
    return circuit
```

**肖尔算法：**

```python
def shor_algorithm(N):
    """肖尔量子因数分解算法"""
    # 经典部分：选择随机数
    a = random.randint(2, N-1)
    if math.gcd(a, N) > 1:
        return math.gcd(a, N)
    
    # 量子部分：找到周期
    period = quantum_period_finding(a, N)
    
    # 经典部分：计算因数
    if period % 2 == 0:
        factor1 = pow(a, period//2, N)
        factor2 = pow(a, period//2, N) + 1
        if factor1 % N != 0 and factor2 % N != 0:
            return math.gcd(factor1, N)
    
    return None

def quantum_period_finding(a, N):
    """量子周期寻找"""
    # 这是量子算法的核心部分
    # 实际实现需要量子计算机
    # 这里提供经典模拟
    n_qubits = 2 * len(bin(N)[2:])
    
    # 制备叠加态
    superposition = np.zeros(2**n_qubits)
    for i in range(2**n_qubits):
        superposition[i] = 1 / np.sqrt(2**n_qubits)
    
    # 应用量子傅里叶变换
    qft_result = quantum_fourier_transform(superposition)
    
    # 测量得到周期
    measured = np.argmax(np.abs(qft_result))
    return measured
```

### 5.3 量子纠缠 | Quantum Entanglement

**贝尔态：**

```lean
-- 贝尔态
def bell_states : set (qubit ⊗ qubit) :=
  {|Φ⁺⟩, |Φ⁻⟩, |Ψ⁺⟩, |Ψ⁻⟩}
  where:
  |Φ⁺⟩ = (|00⟩ + |11⟩)/√2
  |Φ⁻⟩ = (|00⟩ - |11⟩)/√2
  |Ψ⁺⟩ = (|01⟩ + |10⟩)/√2
  |Ψ⁻⟩ = (|01⟩ - |10⟩)/√2

-- 纠缠度量
def entanglement_entropy (ρ : density_matrix) : ℝ :=
  -tr(ρ log ρ)
```

**量子隐形传态：**

```python
def quantum_teleportation(alice_state, bell_pair):
    """量子隐形传态协议"""
    # 初始状态：|ψ⟩_A ⊗ |Φ⁺⟩_BC
    # 其中A是Alice的量子比特，B和C是纠缠对
    
    # 1. Alice对A和B进行贝尔测量
    bell_measurement = bell_measure(alice_state, bell_pair[0])
    
    # 2. Alice将测量结果通过经典信道发送给Bob
    classical_info = bell_measurement
    
    # 3. Bob根据经典信息对C进行相应的操作
    bob_state = apply_correction(bell_pair[1], classical_info)
    
    return bob_state

def bell_measure(qubit1, qubit2):
    """贝尔测量"""
    # 将两个量子比特投影到贝尔基
    bell_basis = [
        np.array([1, 0, 0, 1]) / np.sqrt(2),  # |Φ⁺⟩
        np.array([1, 0, 0, -1]) / np.sqrt(2), # |Φ⁻⟩
        np.array([0, 1, 1, 0]) / np.sqrt(2),  # |Ψ⁺⟩
        np.array([0, 1, -1, 0]) / np.sqrt(2)  # |Ψ⁻⟩
    ]
    
    # 计算投影概率
    joint_state = np.kron(qubit1, qubit2)
    probabilities = [np.abs(np.dot(bell_state, joint_state))**2 
                    for bell_state in bell_basis]
    
    # 返回测量结果
    return np.argmax(probabilities)
```

---

## 6. 相关性与本地跳转 | Relevance & Local Navigation

- 参见 [01-总览.md](./01-总览.md)
- 参见 [02-经典数学物理.md](./02-经典数学物理.md)
- 参见 [../01-总览.md](../01-总览.md)
- 参见 [../../04-逻辑与公理系统/01-总览.md](../../04-逻辑与公理系统/01-总览.md)
- 参见 [../../05-形式语言与符号系统/01-总览.md](../../05-形式语言与符号系统/01-总览.md)

---

## 进度日志 | Progress Log

```markdown
### 进度日志
- 日期：2024-12-19
- 当前主题：量子数学物理
- 已完成内容：量子力学基础、希尔伯特空间理论、量子场论框架
- 中断点：需要进一步细化量子场论和量子信息部分
- 待续内容：具体量子系统的数学分析、前沿应用案例
- 责任人/AI协作：AI+人工
```

<!-- 中断点：量子场论/量子信息/前沿应用案例的递归扩展 -->