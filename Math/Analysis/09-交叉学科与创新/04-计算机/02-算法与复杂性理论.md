# 02-算法与复杂性理论 | Algorithms & Complexity Theory

## 目录

- [02-算法与复杂性理论 | Algorithms \& Complexity Theory](#02-算法与复杂性理论--algorithms--complexity-theory)
  - [目录](#目录)
  - [1. 主题简介 | Topic Introduction](#1-主题简介--topic-introduction)
  - [2. 算法设计基础 | Algorithm Design Fundamentals](#2-算法设计基础--algorithm-design-fundamentals)
    - [2.1 算法设计范式 | Algorithm Design Paradigms](#21-算法设计范式--algorithm-design-paradigms)
    - [2.2 贪心算法 | Greedy Algorithms](#22-贪心算法--greedy-algorithms)
  - [3. 计算复杂性理论 | Computational Complexity Theory](#3-计算复杂性理论--computational-complexity-theory)
    - [3.1 复杂度类定义 | Complexity Class Definitions](#31-复杂度类定义--complexity-class-definitions)
    - [3.2 P vs NP问题 | P vs NP Problem](#32-p-vs-np问题--p-vs-np-problem)
    - [3.3 其他复杂度类 | Other Complexity Classes](#33-其他复杂度类--other-complexity-classes)
  - [4. 经典算法分析 | Classical Algorithm Analysis](#4-经典算法分析--classical-algorithm-analysis)
    - [4.1 排序算法 | Sorting Algorithms](#41-排序算法--sorting-algorithms)
    - [4.2 图算法 | Graph Algorithms](#42-图算法--graph-algorithms)
  - [5. 随机算法与概率分析 | Randomized Algorithms \& Probabilistic Analysis](#5-随机算法与概率分析--randomized-algorithms--probabilistic-analysis)
    - [5.1 随机快速排序 | Randomized Quicksort](#51-随机快速排序--randomized-quicksort)
    - [5.2 随机化算法应用 | Applications of Randomized Algorithms](#52-随机化算法应用--applications-of-randomized-algorithms)
  - [6. 近似算法与启发式方法 | Approximation Algorithms \& Heuristics](#6-近似算法与启发式方法--approximation-algorithms--heuristics)
    - [6.1 近似算法 | Approximation Algorithms](#61-近似算法--approximation-algorithms)
    - [6.2 启发式方法 | Heuristic Methods](#62-启发式方法--heuristic-methods)
  - [7. 相关性与本地跳转 | Relevance \& Local Navigation](#7-相关性与本地跳转--relevance--local-navigation)
  - [进度日志 | Progress Log](#进度日志--progress-log)

---

## 1. 主题简介 | Topic Introduction

算法与复杂性理论是计算机科学的核心数学基础，研究如何设计高效的算法来解决计算问题，以及如何分析算法的计算复杂度。这一领域不仅为软件工程提供了理论基础，也为数学中的可计算性理论提供了重要的应用场景。

Algorithm and complexity theory is the core mathematical foundation of computer science, studying how to design efficient algorithms to solve computational problems and how to analyze the computational complexity of algorithms. This field not only provides theoretical foundations for software engineering but also offers important application scenarios for computability theory in mathematics.

---

## 2. 算法设计基础 | Algorithm Design Fundamentals

### 2.1 算法设计范式 | Algorithm Design Paradigms

**分治算法：**

```python
# 分治算法的数学分析
def divide_and_conquer(problem):
    """分治算法的通用框架"""
    if is_base_case(problem):
        return solve_base_case(problem)
    
    # 分解
    subproblems = divide(problem)
    
    # 递归求解
    solutions = [divide_and_conquer(sub) for sub in subproblems]
    
    # 合并
    return combine(solutions)

# 时间复杂度分析：T(n) = aT(n/b) + f(n)
# 主定理：如果 f(n) = O(n^c)，其中 c < log_b(a)，则 T(n) = Θ(n^log_b(a))
```

**动态规划：**

```python
# 动态规划的数学基础
def dynamic_programming(problem):
    """动态规划的核心思想：最优子结构 + 重叠子问题"""
    n = problem.size
    
    # 初始化DP表
    dp = [[0] * n for _ in range(n)]
    
    # 填充DP表
    for i in range(n):
        for j in range(i, n):
            if i == j:
                dp[i][j] = base_case(problem, i)
            else:
                dp[i][j] = min(dp[i][k] + dp[k+1][j] + cost(i, j, k) 
                              for k in range(i, j))
    
    return dp[0][n-1]

# 时间复杂度：O(n³)，空间复杂度：O(n²)
```

### 2.2 贪心算法 | Greedy Algorithms

**贪心选择性质：**

```lean
-- 贪心选择性质
def greedy_choice_property (problem : optimization_problem) : Prop :=
  ∀ optimal_solution, ∃ greedy_step, 
    greedy_step ∈ optimal_solution ∧ 
    greedy_step is locally_optimal

-- 最优子结构
def optimal_substructure (problem : optimization_problem) : Prop :=
  ∀ optimal_solution, ∀ subproblem,
    optimal_solution ∩ subproblem is optimal_for subproblem
```

**具体应用：**

```python
# 霍夫曼编码
import heapq
from collections import Counter

def huffman_encoding(text):
    """霍夫曼编码的贪心算法"""
    # 统计频率
    freq = Counter(text)
    
    # 构建优先队列
    heap = [[freq[char], char] for char in freq]
    heapq.heapify(heap)
    
    # 贪心构建霍夫曼树
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        
        # 合并节点
        merged = [left[0] + right[0], left, right]
        heapq.heappush(heap, merged)
    
    return build_codes(heap[0])

# 时间复杂度：O(n log n)，其中 n 是字符种类数
```

---

## 3. 计算复杂性理论 | Computational Complexity Theory

### 3.1 复杂度类定义 | Complexity Class Definitions

**基本复杂度类：**

```lean
-- P类：多项式时间可解问题
def P_class : set problem :=
  {p | ∃ algorithm, ∃ k : ℕ, 
       time_complexity algorithm p = O(n^k)}

-- NP类：非确定性多项式时间可验证问题
def NP_class : set problem :=
  {p | ∃ verifier, ∃ k : ℕ,
       verification_time p = O(n^k) ∧
       ∀ yes_instance, ∃ certificate, verifier accepts (yes_instance, certificate)}

-- NP完全问题
def NP_complete : set problem :=
  {p | p ∈ NP ∧ ∀ q ∈ NP, q ≤ₚ p}

-- NP难问题
def NP_hard : set problem :=
  {p | ∀ q ∈ NP, q ≤ₚ p}
```

**归约关系：**

```lean
-- 多项式时间归约
def polynomial_reduction (A B : problem) : Prop :=
  ∃ f : A → B, ∃ k : ℕ,
    f is computable_in O(n^k) ∧
    ∀ x, x ∈ A ↔ f(x) ∈ B

-- 记作 A ≤ₚ B
notation A `≤ₚ` B := polynomial_reduction A B
```

### 3.2 P vs NP问题 | P vs NP Problem

**问题陈述：**

```lean
-- P vs NP问题
theorem P_vs_NP_question : Prop :=
  P_class = NP_class ∨ P_class ≠ NP_class

-- 当前状态：未解决
-- 如果 P = NP，则所有NP问题都可以在多项式时间内解决
-- 如果 P ≠ NP，则存在NP问题不能在多项式时间内解决
```

**重要定理：**

```lean
-- 库克-列文定理：SAT是NP完全的
theorem cook_levin_theorem :
  SAT ∈ NP_complete

-- 时间层次定理
theorem time_hierarchy_theorem (f g : ℕ → ℕ) :
  f(n) = o(g(n)) → TIME(f(n)) ⊊ TIME(g(n))

-- 空间层次定理
theorem space_hierarchy_theorem (f g : ℕ → ℕ) :
  f(n) = o(g(n)) → SPACE(f(n)) ⊊ SPACE(g(n))
```

### 3.3 其他复杂度类 | Other Complexity Classes

**指数时间类：**

```lean
-- EXP类：指数时间可解问题
def EXP_class : set problem :=
  {p | ∃ algorithm, ∃ k : ℕ,
       time_complexity algorithm p = O(2^(n^k))}

-- EXPSPACE类：指数空间可解问题
def EXPSPACE_class : set problem :=
  {p | ∃ algorithm, ∃ k : ℕ,
       space_complexity algorithm p = O(2^(n^k))}
```

**概率复杂度类：**

```lean
-- BPP类：有界误差概率多项式时间
def BPP_class : set problem :=
  {p | ∃ algorithm, ∃ k : ℕ,
       time_complexity algorithm p = O(n^k) ∧
       error_probability ≤ 1/3}

-- RP类：随机多项式时间
def RP_class : set problem :=
  {p | ∃ algorithm, ∃ k : ℕ,
       time_complexity algorithm p = O(n^k) ∧
       ∀ x ∈ p, Pr[algorithm accepts x] ≥ 1/2 ∧
       ∀ x ∉ p, Pr[algorithm accepts x] = 0}
```

---

## 4. 经典算法分析 | Classical Algorithm Analysis

### 4.1 排序算法 | Sorting Algorithms

**快速排序：**

```python
def quicksort(arr):
    """快速排序的数学分析"""
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quicksort(left) + middle + quicksort(right)

# 时间复杂度分析：
# 最好情况：O(n log n) - 每次都能平衡分割
# 平均情况：O(n log n) - 期望情况
# 最坏情况：O(n²) - 已经排序或逆序
# 空间复杂度：O(log n) - 递归调用栈深度
```

**归并排序：**

```python
def mergesort(arr):
    """归并排序的数学分析"""
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = mergesort(arr[:mid])
    right = mergesort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    """合并两个有序数组"""
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# 时间复杂度：O(n log n) - 稳定
# 空间复杂度：O(n) - 需要额外空间
```

### 4.2 图算法 | Graph Algorithms

**最短路径算法：**

```python
import heapq

def dijkstra(graph, start):
    """Dijkstra最短路径算法"""
    distances = {node: float('infinity') for node in graph}
    distances[start] = 0
    pq = [(0, start)]
    
    while pq:
        current_distance, current_node = heapq.heappop(pq)
        
        if current_distance > distances[current_node]:
            continue
        
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))
    
    return distances

# 时间复杂度：O((V + E) log V) - 使用优先队列
# 空间复杂度：O(V)
```

**最小生成树：**

```python
def kruskal(graph):
    """Kruskal最小生成树算法"""
    edges = []
    for u in graph:
        for v, weight in graph[u].items():
            edges.append((weight, u, v))
    
    edges.sort()  # 按权重排序
    mst = []
    uf = UnionFind(len(graph))
    
    for weight, u, v in edges:
        if uf.find(u) != uf.find(v):
            uf.union(u, v)
            mst.append((u, v, weight))
    
    return mst

# 时间复杂度：O(E log E) - 排序占主导
# 空间复杂度：O(E)
```

---

## 5. 随机算法与概率分析 | Randomized Algorithms & Probabilistic Analysis

### 5.1 随机快速排序 | Randomized Quicksort

**随机化策略：**

```python
import random

def randomized_quicksort(arr):
    """随机化快速排序"""
    if len(arr) <= 1:
        return arr
    
    # 随机选择主元
    pivot = random.choice(arr)
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return randomized_quicksort(left) + middle + randomized_quicksort(right)

# 期望时间复杂度：O(n log n)
# 概率分析：随机主元使得分割更平衡
```

**概率分析：**

```lean
-- 随机快速排序的期望复杂度
theorem randomized_quicksort_complexity :
  E[T(n)] = O(n log n)

-- 证明思路：
-- 1. 定义指示随机变量 X_ij
-- 2. 计算 E[X_ij] = 2/(j-i+1)
-- 3. 求和得到期望复杂度
```

### 5.2 随机化算法应用 | Applications of Randomized Algorithms

**素数测试：**

```python
def miller_rabin(n, k=5):
    """Miller-Rabin素数测试"""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0:
        return False
    
    # 将 n-1 写成 2^r * d 的形式
    r, d = 0, n - 1
    while d % 2 == 0:
        r += 1
        d //= 2
    
    # 进行 k 次测试
    for _ in range(k):
        a = random.randrange(2, n - 1)
        x = pow(a, d, n)
        
        if x == 1 or x == n - 1:
            continue
        
        for _ in range(r - 1):
            x = (x * x) % n
            if x == n - 1:
                break
        else:
            return False
    
    return True

# 时间复杂度：O(k log³ n)
# 错误概率：≤ 4^(-k)
```

---

## 6. 近似算法与启发式方法 | Approximation Algorithms & Heuristics

### 6.1 近似算法 | Approximation Algorithms

**旅行商问题的近似算法：**

```python
def christofides_tsp(graph):
    """Christofides算法的2-近似解"""
    # 1. 计算最小生成树
    mst = kruskal(graph)
    
    # 2. 找到奇数度顶点
    odd_vertices = find_odd_degree_vertices(mst)
    
    # 3. 计算最小权重完美匹配
    matching = minimum_weight_perfect_matching(graph, odd_vertices)
    
    # 4. 合并MST和匹配
    multigraph = combine_mst_and_matching(mst, matching)
    
    # 5. 找到欧拉回路
    euler_tour = find_euler_tour(multigraph)
    
    # 6. 短路得到哈密顿回路
    hamiltonian_cycle = shortcut_euler_tour(euler_tour)
    
    return hamiltonian_cycle

# 近似比：3/2
# 时间复杂度：O(n³)
```

**集合覆盖问题的贪心算法：**

```python
def greedy_set_cover(universe, subsets):
    """集合覆盖问题的贪心算法"""
    uncovered = set(universe)
    cover = []
    
    while uncovered:
        # 选择覆盖最多未覆盖元素的集合
        best_subset = max(subsets, 
                         key=lambda s: len(s & uncovered))
        cover.append(best_subset)
        uncovered -= best_subset
    
    return cover

# 近似比：ln n
# 时间复杂度：O(n²)
```

### 6.2 启发式方法 | Heuristic Methods

**遗传算法：**

```python
import random
import numpy as np

class GeneticAlgorithm:
    def __init__(self, population_size=100, mutation_rate=0.01):
        self.population_size = population_size
        self.mutation_rate = mutation_rate
    
    def evolve(self, fitness_function, generations=100):
        """遗传算法主循环"""
        population = self.initialize_population()
        
        for generation in range(generations):
            # 评估适应度
            fitness_scores = [fitness_function(individual) 
                            for individual in population]
            
            # 选择
            parents = self.selection(population, fitness_scores)
            
            # 交叉
            offspring = self.crossover(parents)
            
            # 变异
            offspring = self.mutation(offspring)
            
            # 更新种群
            population = offspring
        
        return self.get_best_individual(population, fitness_function)
    
    def selection(self, population, fitness_scores):
        """轮盘赌选择"""
        total_fitness = sum(fitness_scores)
        probabilities = [f/total_fitness for f in fitness_scores]
        
        selected = []
        for _ in range(self.population_size):
            r = random.random()
            cumulative = 0
            for i, p in enumerate(probabilities):
                cumulative += p
                if r <= cumulative:
                    selected.append(population[i])
                    break
        
        return selected
```

---

## 7. 相关性与本地跳转 | Relevance & Local Navigation

- 参见 [01-总览.md](./01-总览.md)
- 参见 [../01-总览.md](../01-总览.md)
- 参见 [../../06-可计算性与自动机理论/01-总览.md](../../06-可计算性与自动机理论/01-总览.md)
- 参见 [../../07-复杂性理论与算法基础/01-总览.md](../../07-复杂性理论与算法基础/01-总览.md)
- 参见 [../../03-代数结构与理论/01-基本代数系统/01-总览.md](../../03-代数结构与理论/01-基本代数系统/01-总览.md)

---

## 进度日志 | Progress Log

```markdown
### 进度日志
- 日期：2024-12-19
- 当前主题：算法与复杂性理论
- 已完成内容：算法设计基础、复杂度理论、经典算法分析
- 中断点：需要进一步细化随机算法和近似算法部分
- 待续内容：具体算法的数学证明、前沿应用案例
- 责任人/AI协作：AI+人工
```

<!-- 中断点：随机算法/近似算法/前沿应用案例的递归扩展 -->