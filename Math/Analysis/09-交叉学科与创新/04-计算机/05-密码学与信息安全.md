# 05-密码学与信息安全 | Cryptography & Information Security

## 目录

- [05-密码学与信息安全 | Cryptography \& Information Security](#05-密码学与信息安全--cryptography--information-security)
  - [目录](#目录)
  - [1. 主题简介 | Topic Introduction](#1-主题简介--topic-introduction)
  - [2. 数论基础 | Number Theory Foundations](#2-数论基础--number-theory-foundations)
    - [2.1 模运算与同余 | Modular Arithmetic \& Congruences](#21-模运算与同余--modular-arithmetic--congruences)
    - [2.2 欧拉函数与费马小定理 | Euler's Totient \& Fermat's Little Theorem](#22-欧拉函数与费马小定理--eulers-totient--fermats-little-theorem)
    - [2.3 二次剩余与勒让德符号 | Quadratic Residues \& Legendre Symbol](#23-二次剩余与勒让德符号--quadratic-residues--legendre-symbol)
  - [3. 现代密码学 | Modern Cryptography](#3-现代密码学--modern-cryptography)
    - [3.1 RSA加密系统 | RSA Encryption System](#31-rsa加密系统--rsa-encryption-system)
    - [3.2 椭圆曲线密码学 | Elliptic Curve Cryptography](#32-椭圆曲线密码学--elliptic-curve-cryptography)
    - [3.3 哈希函数与数字签名 | Hash Functions \& Digital Signatures](#33-哈希函数与数字签名--hash-functions--digital-signatures)
  - [4. 量子密码学 | Quantum Cryptography](#4-量子密码学--quantum-cryptography)
    - [4.1 量子密钥分发 | Quantum Key Distribution](#41-量子密钥分发--quantum-key-distribution)
    - [4.2 后量子密码学 | Post-Quantum Cryptography](#42-后量子密码学--post-quantum-cryptography)
    - [4.3 量子随机数生成 | Quantum Random Number Generation](#43-量子随机数生成--quantum-random-number-generation)
  - [5. 相关性与本地跳转 | Relevance \& Local Navigation](#5-相关性与本地跳转--relevance--local-navigation)
  - [进度日志 | Progress Log](#进度日志--progress-log)

---

## 1. 主题简介 | Topic Introduction

密码学与信息安全是数学在计算机科学中的重要应用领域，从古典数论到现代公钥密码学，从椭圆曲线到量子密码学，这一领域不仅保护了数字世界的安全，也推动了数学理论的发展和应用。

Cryptography and information security are important applications of mathematics in computer science, from classical number theory to modern public-key cryptography, from elliptic curves to quantum cryptography. This field not only protects the security of the digital world but also promotes the development and application of mathematical theory.

---

## 2. 数论基础 | Number Theory Foundations

### 2.1 模运算与同余 | Modular Arithmetic & Congruences

**模运算基础：**

```lean
-- 同余关系
def congruence (a b : ℤ) (n : ℕ) : Prop :=
  n | (a - b)

-- 记作 a ≡ b (mod n)
notation a `≡` b `(mod` n `)` := congruence a b n

-- 模运算性质
theorem modular_arithmetic_properties (a b c : ℤ) (n : ℕ) :
  a ≡ a (mod n) ∧  -- 自反性
  (a ≡ b (mod n) → b ≡ a (mod n)) ∧  -- 对称性
  (a ≡ b (mod n) ∧ b ≡ c (mod n) → a ≡ c (mod n))  -- 传递性

-- 中国剩余定理
theorem chinese_remainder_theorem (a₁ a₂ : ℤ) (n₁ n₂ : ℕ) :
  coprime n₁ n₂ → ∃ x, x ≡ a₁ (mod n₁) ∧ x ≡ a₂ (mod n₂)
```

**模运算实现：**

```python
import numpy as np
from math import gcd

class ModularArithmetic:
    def __init__(self, modulus):
        self.modulus = modulus
    
    def add(self, a, b):
        """模加法"""
        return (a + b) % self.modulus
    
    def multiply(self, a, b):
        """模乘法"""
        return (a * b) % self.modulus
    
    def power(self, base, exponent):
        """模幂运算"""
        result = 1
        base = base % self.modulus
        
        while exponent > 0:
            if exponent % 2 == 1:
                result = (result * base) % self.modulus
            base = (base * base) % self.modulus
            exponent //= 2
        
        return result
    
    def extended_gcd(self, a, b):
        """扩展欧几里得算法"""
        if a == 0:
            return b, 0, 1
        
        gcd_val, x1, y1 = self.extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        
        return gcd_val, x, y
    
    def modular_inverse(self, a):
        """模逆元"""
        g, x, y = self.extended_gcd(a, self.modulus)
        if g != 1:
            raise ValueError("模逆元不存在")
        return (x % self.modulus + self.modulus) % self.modulus

def chinese_remainder_theorem(remainders, moduli):
    """中国剩余定理实现"""
    def extended_gcd(a, b):
        if a == 0:
            return b, 0, 1
        gcd_val, x1, y1 = extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        return gcd_val, x, y
    
    def mod_inverse(a, m):
        g, x, y = extended_gcd(a, m)
        if g != 1:
            raise ValueError("模逆元不存在")
        return (x % m + m) % m
    
    # 计算乘积
    product = 1
    for modulus in moduli:
        product *= modulus
    
    # 计算解
    result = 0
    for remainder, modulus in zip(remainders, moduli):
        pi = product // modulus
        result += remainder * pi * mod_inverse(pi, modulus)
    
    return result % product
```

### 2.2 欧拉函数与费马小定理 | Euler's Totient & Fermat's Little Theorem

**欧拉函数：**

```lean
-- 欧拉函数
def euler_totient (n : ℕ) : ℕ :=
  |{k : ℕ | 1 ≤ k ≤ n ∧ coprime k n}|

-- 欧拉函数性质
theorem euler_totient_properties (m n : ℕ) :
  coprime m n → φ(m * n) = φ(m) * φ(n)

-- 费马小定理
theorem fermat_little_theorem (a : ℤ) (p : ℕ) :
  prime p ∧ ¬p | a → a^(p-1) ≡ 1 (mod p)

-- 欧拉定理
theorem euler_theorem (a : ℤ) (n : ℕ) :
  coprime a n → a^φ(n) ≡ 1 (mod n)
```

**欧拉函数计算：**

```python
def euler_totient(n):
    """计算欧拉函数"""
    if n == 1:
        return 1
    
    # 质因数分解
    factors = prime_factorization(n)
    
    # 计算欧拉函数
    result = n
    for prime, power in factors.items():
        result *= (1 - 1/prime)
    
    return int(result)

def prime_factorization(n):
    """质因数分解"""
    factors = {}
    d = 2
    
    while d * d <= n:
        while n % d == 0:
            factors[d] = factors.get(d, 0) + 1
            n //= d
        d += 1
    
    if n > 1:
        factors[n] = factors.get(n, 0) + 1
    
    return factors

def fermat_little_theorem(a, p):
    """费马小定理验证"""
    if not is_prime(p):
        return False
    
    if a % p == 0:
        return True  # 0^(p-1) ≡ 0 (mod p)
    
    # 计算 a^(p-1) mod p
    result = pow(a, p-1, p)
    return result == 1

def is_prime(n):
    """素数检测"""
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    
    for i in range(3, int(np.sqrt(n)) + 1, 2):
        if n % i == 0:
            return False
    
    return True
```

### 2.3 二次剩余与勒让德符号 | Quadratic Residues & Legendre Symbol

**二次剩余：**

```lean
-- 二次剩余
def quadratic_residue (a : ℤ) (p : ℕ) : Prop :=
  ∃ x, x² ≡ a (mod p)

-- 勒让德符号
def legendre_symbol (a : ℤ) (p : ℕ) : ℤ :=
  if a ≡ 0 (mod p) then 0
  else if quadratic_residue a p then 1
  else -1

-- 二次互反律
theorem quadratic_reciprocity (p q : ℕ) :
  odd_prime p ∧ odd_prime q ∧ p ≠ q →
  (p/q) * (q/p) = (-1)^((p-1)/2 * (q-1)/2)
```

**二次剩余计算：**

```python
def legendre_symbol(a, p):
    """计算勒让德符号"""
    if a % p == 0:
        return 0
    
    # 欧拉准则
    result = pow(a, (p-1)//2, p)
    if result == 1:
        return 1
    elif result == p-1:
        return -1
    else:
        return 0

def quadratic_residue_solver(a, p):
    """求解二次剩余"""
    if legendre_symbol(a, p) != 1:
        return None  # 无解
    
    # 寻找二次非剩余
    for n in range(2, p):
        if legendre_symbol(n, p) == -1:
            break
    
    # 使用Tonelli-Shanks算法
    return tonelli_shanks(a, p, n)

def tonelli_shanks(a, p, n):
    """Tonelli-Shanks算法"""
    # 将 p-1 写成 Q * 2^S 的形式
    Q = p - 1
    S = 0
    while Q % 2 == 0:
        Q //= 2
        S += 1
    
    # 初始化
    R = pow(a, (Q+1)//2, p)
    t = pow(a, Q, p)
    M = S
    
    while t != 1:
        # 找到最小的 i 使得 t^(2^i) ≡ 1 (mod p)
        i = 1
        temp = t
        while temp != 1 and i < M:
            temp = (temp * temp) % p
            i += 1
        
        if i == M:
            return None  # 无解
        
        # 更新参数
        b = pow(n, Q * (2**(M-i-1)), p)
        R = (R * b) % p
        t = (t * b * b) % p
        M = i
    
    return R

def quadratic_reciprocity_demo():
    """二次互反律演示"""
    primes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
    
    for i, p in enumerate(primes):
        for j, q in enumerate(primes[i+1:], i+1):
            # 计算 (p/q) 和 (q/p)
            legendre_pq = legendre_symbol(p, q)
            legendre_qp = legendre_symbol(q, p)
            
            # 验证二次互反律
            expected = (-1)**(((p-1)//2) * ((q-1)//2))
            actual = legendre_pq * legendre_qp
            
            print(f"({p}/{q}) * ({q}/{p}) = {actual}, 期望: {expected}")
    
    return True
```

---

## 3. 现代密码学 | Modern Cryptography

### 3.1 RSA加密系统 | RSA Encryption System

**RSA算法：**

```lean
-- RSA密钥生成
def rsa_key_generation (p q : ℕ) : (public_key × private_key) :=
  let n = p * q
  let φ = (p-1) * (q-1)
  let e = choose_public_exponent φ
  let d = modular_inverse e φ
  ((n, e), (n, d))

-- RSA加密
def rsa_encryption (m : ℤ) (public_key : ℕ × ℕ) : ℤ :=
  let (n, e) = public_key
  m^e mod n

-- RSA解密
def rsa_decryption (c : ℤ) (private_key : ℕ × ℕ) : ℤ :=
  let (n, d) = private_key
  c^d mod n
```

**RSA实现：**

```python
class RSA:
    def __init__(self, key_size=1024):
        self.key_size = key_size
        self.public_key = None
        self.private_key = None
    
    def generate_keys(self):
        """生成RSA密钥对"""
        # 生成大素数
        p = generate_large_prime(self.key_size // 2)
        q = generate_large_prime(self.key_size // 2)
        
        n = p * q
        phi = (p - 1) * (q - 1)
        
        # 选择公钥指数
        e = 65537  # 常用的公钥指数
        
        # 计算私钥指数
        d = modular_inverse(e, phi)
        
        self.public_key = (n, e)
        self.private_key = (n, d)
        
        return self.public_key, self.private_key
    
    def encrypt(self, message):
        """RSA加密"""
        n, e = self.public_key
        # 将消息转换为整数
        m = int.from_bytes(message.encode(), 'big')
        
        # 加密
        c = pow(m, e, n)
        return c
    
    def decrypt(self, ciphertext):
        """RSA解密"""
        n, d = self.private_key
        
        # 解密
        m = pow(ciphertext, d, n)
        
        # 转换回字符串
        message = m.to_bytes((m.bit_length() + 7) // 8, 'big').decode()
        return message

def generate_large_prime(bits):
    """生成大素数"""
    while True:
        # 生成随机奇数
        n = np.random.randint(2**(bits-1), 2**bits)
        if n % 2 == 0:
            n += 1
        
        # 素数检测
        if miller_rabin_test(n, 10):
            return n

def miller_rabin_test(n, k):
    """Miller-Rabin素数检测"""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0:
        return False
    
    # 将 n-1 写成 2^r * d 的形式
    r, d = 0, n - 1
    while d % 2 == 0:
        r += 1
        d //= 2
    
    # 进行 k 次测试
    for _ in range(k):
        a = np.random.randint(2, n - 1)
        x = pow(a, d, n)
        
        if x == 1 or x == n - 1:
            continue
        
        for _ in range(r - 1):
            x = (x * x) % n
            if x == n - 1:
                break
        else:
            return False
    
    return True
```

### 3.2 椭圆曲线密码学 | Elliptic Curve Cryptography

**椭圆曲线：**

```lean
-- 椭圆曲线
structure elliptic_curve :=
  (field : field)
  (a b : field.element)
  (discriminant : 4a³ + 27b² ≠ 0)

-- 点加法
def point_addition (E : elliptic_curve) (P Q : point) : point :=
  if P = point_at_infinity then Q
  else if Q = point_at_infinity then P
  else compute_sum P Q E

-- 标量乘法
def scalar_multiplication (E : elliptic_curve) (k : ℕ) (P : point) : point :=
  k * P = P + P + ... + P (k times)
```

**椭圆曲线实现：**

```python
class EllipticCurve:
    def __init__(self, a, b, p):
        self.a = a
        self.b = b
        self.p = p
        self.infinity = None
    
    def is_on_curve(self, x, y):
        """检查点是否在曲线上"""
        return (y**2 - x**3 - self.a * x - self.b) % self.p == 0
    
    def add_points(self, P1, P2):
        """点加法"""
        if P1 == self.infinity:
            return P2
        if P2 == self.infinity:
            return P1
        
        x1, y1 = P1
        x2, y2 = P2
        
        if x1 == x2 and y1 != y2:
            return self.infinity
        
        if x1 == x2:
            # P1 = P2，计算切线斜率
            slope = (3 * x1**2 + self.a) * pow(2 * y1, -1, self.p) % self.p
        else:
            # 计算直线斜率
            slope = (y2 - y1) * pow(x2 - x1, -1, self.p) % self.p
        
        x3 = (slope**2 - x1 - x2) % self.p
        y3 = (slope * (x1 - x3) - y1) % self.p
        
        return (x3, y3)
    
    def scalar_multiply(self, k, P):
        """标量乘法"""
        result = self.infinity
        addend = P
        
        while k:
            if k & 1:
                result = self.add_points(result, addend)
            addend = self.add_points(addend, addend)
            k >>= 1
        
        return result

class ECDSA:
    def __init__(self, curve, G, n):
        self.curve = curve
        self.G = G  # 生成元
        self.n = n  # 阶
    
    def generate_keys(self):
        """生成ECDSA密钥对"""
        private_key = np.random.randint(1, self.n)
        public_key = self.curve.scalar_multiply(private_key, self.G)
        return private_key, public_key
    
    def sign(self, message, private_key):
        """ECDSA签名"""
        k = np.random.randint(1, self.n)
        R = self.curve.scalar_multiply(k, self.G)
        r = R[0] % self.n
        
        if r == 0:
            return self.sign(message, private_key)
        
        # 计算消息哈希
        h = hash(message) % self.n
        
        s = (pow(k, -1, self.n) * (h + private_key * r)) % self.n
        
        if s == 0:
            return self.sign(message, private_key)
        
        return (r, s)
    
    def verify(self, message, signature, public_key):
        """ECDSA验证"""
        r, s = signature
        
        if not (1 <= r < self.n and 1 <= s < self.n):
            return False
        
        h = hash(message) % self.n
        w = pow(s, -1, self.n)
        u1 = (h * w) % self.n
        u2 = (r * w) % self.n
        
        V = self.curve.add_points(
            self.curve.scalar_multiply(u1, self.G),
            self.curve.scalar_multiply(u2, public_key)
        )
        
        return V[0] % self.n == r

def hash(message):
    """简单的哈希函数"""
    return hash(message) % (2**256)
```

### 3.3 哈希函数与数字签名 | Hash Functions & Digital Signatures

**哈希函数：**

```lean
-- 哈希函数
def hash_function (H : message → hash_value) : Prop :=
  (∀ m₁ m₂, H(m₁) = H(m₂) → m₁ = m₂) ∧  -- 抗碰撞性
  (∀ m, H(m) has_fixed_length) ∧         -- 固定长度
  (∀ m, H(m) is_random_looking)          -- 随机性

-- 数字签名
def digital_signature (Sign : message × private_key → signature) : Prop :=
  ∀ m k, Verify(m, Sign(m,k), public_key(k)) = true
```

**哈希函数实现：**

```python
import hashlib
import hmac

class HashFunctions:
    @staticmethod
    def sha256(message):
        """SHA-256哈希函数"""
        return hashlib.sha256(message.encode()).hexdigest()
    
    @staticmethod
    def sha512(message):
        """SHA-512哈希函数"""
        return hashlib.sha512(message.encode()).hexdigest()
    
    @staticmethod
    def hmac_sha256(key, message):
        """HMAC-SHA256"""
        return hmac.new(key.encode(), message.encode(), hashlib.sha256).hexdigest()
    
    @staticmethod
    def pbkdf2(password, salt, iterations=10000, key_length=32):
        """PBKDF2密钥派生函数"""
        return hashlib.pbkdf2_hmac(
            'sha256', 
            password.encode(), 
            salt.encode(), 
            iterations, 
            key_length
        ).hex()

class DigitalSignature:
    def __init__(self, hash_function='sha256'):
        self.hash_function = hash_function
    
    def sign(self, message, private_key):
        """数字签名"""
        # 计算消息哈希
        message_hash = getattr(HashFunctions, self.hash_function)(message)
        
        # 使用私钥签名（这里使用RSA作为示例）
        signature = rsa_sign(message_hash, private_key)
        
        return signature
    
    def verify(self, message, signature, public_key):
        """验证数字签名"""
        # 计算消息哈希
        message_hash = getattr(HashFunctions, self.hash_function)(message)
        
        # 使用公钥验证
        return rsa_verify(message_hash, signature, public_key)

def rsa_sign(message_hash, private_key):
    """RSA签名"""
    n, d = private_key
    signature = pow(int(message_hash, 16), d, n)
    return signature

def rsa_verify(message_hash, signature, public_key):
    """RSA验证"""
    n, e = public_key
    decrypted = pow(signature, e, n)
    return decrypted == int(message_hash, 16)
```

---

## 4. 量子密码学 | Quantum Cryptography

### 4.1 量子密钥分发 | Quantum Key Distribution

**BB84协议：**

```lean
-- BB84协议
def bb84_protocol (Alice Bob : quantum_system) : shared_key :=
  -- 1. Alice随机选择比特和基底
  let alice_bits = random_bits n
  let alice_bases = random_bases n
  
  -- 2. Alice制备量子态
  let quantum_states = prepare_states alice_bits alice_bases
  
  -- 3. Bob随机选择测量基底
  let bob_bases = random_bases n
  
  -- 4. Bob测量量子态
  let bob_measurements = measure_states quantum_states bob_bases
  
  -- 5. 经典后处理
  let shared_key = post_process alice_bits bob_measurements alice_bases bob_bases
```

**BB84协议实现：**

```python
import numpy as np

class BB84Protocol:
    def __init__(self, key_length=100):
        self.key_length = key_length
    
    def generate_random_bits(self, n):
        """生成随机比特"""
        return np.random.randint(0, 2, n)
    
    def generate_random_bases(self, n):
        """生成随机基底"""
        return np.random.randint(0, 2, n)  # 0: 计算基底, 1: 对角基底
    
    def prepare_quantum_state(self, bit, basis):
        """制备量子态"""
        if basis == 0:  # 计算基底
            if bit == 0:
                return np.array([1, 0])  # |0⟩
            else:
                return np.array([0, 1])  # |1⟩
        else:  # 对角基底
            if bit == 0:
                return np.array([1, 1]) / np.sqrt(2)  # |+⟩
            else:
                return np.array([1, -1]) / np.sqrt(2)  # |-⟩
    
    def measure_quantum_state(self, state, basis):
        """测量量子态"""
        if basis == 0:  # 计算基底测量
            # 投影到 |0⟩ 和 |1⟩
            prob_0 = abs(np.dot(state, np.array([1, 0])))**2
            return np.random.choice([0, 1], p=[prob_0, 1-prob_0])
        else:  # 对角基底测量
            # 投影到 |+⟩ 和 |-⟩
            prob_plus = abs(np.dot(state, np.array([1, 1])/np.sqrt(2)))**2
            return np.random.choice([0, 1], p=[prob_plus, 1-prob_plus])
    
    def execute_protocol(self):
        """执行BB84协议"""
        # 1. Alice生成随机比特和基底
        alice_bits = self.generate_random_bits(self.key_length)
        alice_bases = self.generate_random_bases(self.key_length)
        
        # 2. Alice制备量子态
        quantum_states = []
        for bit, basis in zip(alice_bits, alice_bases):
            state = self.prepare_quantum_state(bit, basis)
            quantum_states.append(state)
        
        # 3. Bob生成随机测量基底
        bob_bases = self.generate_random_bases(self.key_length)
        
        # 4. Bob测量量子态
        bob_measurements = []
        for state, basis in zip(quantum_states, bob_bases):
            measurement = self.measure_quantum_state(state, basis)
            bob_measurements.append(measurement)
        
        # 5. 经典后处理
        shared_key = self.post_process(alice_bits, bob_measurements, 
                                     alice_bases, bob_bases)
        
        return shared_key
    
    def post_process(self, alice_bits, bob_measurements, alice_bases, bob_bases):
        """后处理"""
        # 找到基底匹配的位置
        matching_bases = (alice_bases == bob_bases)
        
        # 提取共享密钥
        shared_key = []
        for i in range(len(alice_bits)):
            if matching_bases[i]:
                if alice_bits[i] == bob_measurements[i]:
                    shared_key.append(alice_bits[i])
        
        return np.array(shared_key)
```

### 4.2 后量子密码学 | Post-Quantum Cryptography

**格密码学：**

```lean
-- 格
def lattice (B : matrix) : set :=
  {∑ᵢ xᵢ * bᵢ | xᵢ ∈ ℤ}
  where bᵢ are the columns of B

-- 最近向量问题
def closest_vector_problem (B : matrix) (t : vector) : vector :=
  argmin_{v ∈ lattice(B)} ||v - t||

-- 最短向量问题
def shortest_vector_problem (B : matrix) : vector :=
  argmin_{v ∈ lattice(B) \ {0}} ||v||
```

**格密码学实现：**

```python
class LatticeCryptography:
    def __init__(self, dimension=256, modulus=12289):
        self.dimension = dimension
        self.modulus = modulus
    
    def generate_lattice_basis(self):
        """生成格基"""
        # 生成随机格基
        B = np.random.randint(0, self.modulus, (self.dimension, self.dimension))
        return B
    
    def closest_vector_approximation(self, B, target):
        """最近向量问题的近似解"""
        # 使用Babai算法
        # 将目标向量投影到格基上
        B_inv = np.linalg.inv(B)
        coefficients = np.dot(B_inv, target)
        
        # 四舍五入到最近的整数
        rounded_coefficients = np.round(coefficients).astype(int)
        
        # 计算格向量
        closest_vector = np.dot(B, rounded_coefficients) % self.modulus
        
        return closest_vector
    
    def lwe_encryption(self, public_key, message):
        """基于LWE的加密"""
        A, b = public_key
        
        # 选择随机向量
        r = np.random.randint(0, 2, self.dimension)
        
        # 计算密文
        u = np.dot(A.T, r) % self.modulus
        v = (np.dot(b, r) + message * (self.modulus // 2)) % self.modulus
        
        return (u, v)
    
    def lwe_decryption(self, private_key, ciphertext):
        """基于LWE的解密"""
        s = private_key
        u, v = ciphertext
        
        # 计算解密值
        decrypted = (v - np.dot(u, s)) % self.modulus
        
        # 恢复消息
        if decrypted < self.modulus // 2:
            return 0
        else:
            return 1

def generate_lwe_keys(dimension=256, modulus=12289, error_std=3.2):
    """生成LWE密钥对"""
    # 生成随机矩阵A
    A = np.random.randint(0, modulus, (dimension, dimension))
    
    # 生成私钥s
    s = np.random.randint(0, 2, dimension)
    
    # 生成错误向量e
    e = np.random.normal(0, error_std, dimension).astype(int) % modulus
    
    # 计算公钥b
    b = (np.dot(A, s) + e) % modulus
    
    return (A, b), s
```

### 4.3 量子随机数生成 | Quantum Random Number Generation

**量子随机数：**

```lean
-- 量子随机数生成
def quantum_random_number (qubit : quantum_state) : bit :=
  measure qubit in computational_basis

-- 量子随机数生成器
def quantum_rng (n : ℕ) : bit_string :=
  [quantum_random_number(qubit_i) | i ∈ [1..n]]
```

**量子随机数生成实现：**

```python
class QuantumRandomNumberGenerator:
    def __init__(self):
        self.quantum_states = []
    
    def generate_quantum_state(self):
        """生成量子态"""
        # 模拟量子态的制备
        # 在实际应用中，这需要真实的量子设备
        theta = np.random.uniform(0, 2*np.pi)
        phi = np.random.uniform(0, 2*np.pi)
        
        # 布洛赫球上的随机点
        state = np.array([
            np.cos(theta/2),
            np.exp(1j*phi) * np.sin(theta/2)
        ])
        
        return state
    
    def measure_quantum_state(self, state):
        """测量量子态"""
        # 在计算基底中测量
        prob_0 = abs(state[0])**2
        return np.random.choice([0, 1], p=[prob_0, 1-prob_0])
    
    def generate_random_bits(self, n):
        """生成n个随机比特"""
        random_bits = []
        
        for _ in range(n):
            # 制备量子态
            state = self.generate_quantum_state()
            
            # 测量得到随机比特
            bit = self.measure_quantum_state(state)
            random_bits.append(bit)
        
        return np.array(random_bits)
    
    def generate_random_bytes(self, n_bytes):
        """生成n_bytes个随机字节"""
        n_bits = n_bytes * 8
        bits = self.generate_random_bits(n_bits)
        
        # 将比特转换为字节
        bytes_array = []
        for i in range(0, n_bits, 8):
            byte = 0
            for j in range(8):
                byte |= bits[i+j] << j
            bytes_array.append(byte)
        
        return np.array(bytes_array)
    
    def test_randomness(self, bits):
        """测试随机性"""
        # 简单的随机性测试
        n = len(bits)
        
        # 计算0和1的比例
        ratio_0 = np.sum(bits == 0) / n
        ratio_1 = np.sum(bits == 1) / n
        
        # 计算游程数
        runs = 0
        for i in range(1, n):
            if bits[i] != bits[i-1]:
                runs += 1
        
        return {
            'ratio_0': ratio_0,
            'ratio_1': ratio_1,
            'runs': runs,
            'expected_runs': (n+1)/2
        }

def quantum_random_demo():
    """量子随机数生成演示"""
    qrng = QuantumRandomNumberGenerator()
    
    # 生成1000个随机比特
    random_bits = qrng.generate_random_bits(1000)
    
    # 测试随机性
    test_results = qrng.test_randomness(random_bits)
    
    print("量子随机数生成结果:")
    print(f"0的比例: {test_results['ratio_0']:.3f}")
    print(f"1的比例: {test_results['ratio_1']:.3f}")
    print(f"游程数: {test_results['runs']}")
    print(f"期望游程数: {test_results['expected_runs']:.1f}")
    
    return random_bits, test_results
```

---

## 5. 相关性与本地跳转 | Relevance & Local Navigation

- 参见 [01-总览.md](./01-总览.md)
- 参见 [02-算法与复杂性理论.md](./02-算法与复杂性理论.md)
- 参见 [03-形式化方法与程序验证.md](./03-形式化方法与程序验证.md)
- 参见 [04-人工智能与机器学习.md](./04-人工智能与机器学习.md)
- 参见 [../01-总览.md](../01-总览.md)
- 参见 [../../07-数论与离散数学/01-总览.md](../../07-数论与离散数学/01-总览.md)

---

## 进度日志 | Progress Log

```markdown
### 进度日志
- 日期：2024-12-19
- 当前主题：密码学与信息安全
- 已完成内容：数论基础、现代密码学、量子密码学
- 中断点：需要进一步细化具体应用和安全性分析部分
- 待续内容：具体密码学应用案例、安全性证明
- 责任人/AI协作：AI+人工
```

<!-- 中断点：具体应用/安全性分析/前沿方法的递归扩展 -->