# åŒä¼¦ç±»å‹è®º | Homotopy Type Theory (HoTT)

---

## ğŸ¯ æ¦‚è¿°

åŒä¼¦ç±»å‹è®ºï¼ˆHoTTï¼‰æ˜¯æ•°å­¦åŸºç¡€çš„æ–°æ¡†æ¶ï¼Œå°†ç±»å‹è®ºä¸åŒä¼¦ç†è®ºç›¸ç»“åˆï¼Œä¸ºæ•°å­¦æä¾›äº†ä¸€ç§æ–°çš„åŸºç¡€è¯­è¨€ã€‚HoTTçš„æ ¸å¿ƒæ€æƒ³æ˜¯å°†ç±»å‹è§†ä¸ºç©ºé—´ï¼Œå°†ç±»å‹ä¹‹é—´çš„ä¾èµ–å…³ç³»è§†ä¸ºçº¤ç»´åŒ–ï¼Œä»è€Œåœ¨ç±»å‹è®ºä¸­è‡ªç„¶åœ°è¡¨è¾¾åŒä¼¦æ¦‚å¿µã€‚

### æ ¸å¿ƒä»·å€¼

- **ç»Ÿä¸€æ€§**ï¼šç»Ÿä¸€äº†é›†åˆè®ºã€ç±»å‹è®ºå’ŒåŒä¼¦ç†è®º
- **æ„é€ æ€§**ï¼šæä¾›æ„é€ æ€§çš„æ•°å­¦åŸºç¡€
- **è®¡ç®—æ€§**ï¼šå…·æœ‰è®¡ç®—å†…å®¹çš„æ•°å­¦è¯æ˜
- **å½¢å¼åŒ–**ï¼šé€‚åˆè®¡ç®—æœºè¾…åŠ©è¯æ˜

---

## ğŸ—ï¸ ç†è®ºåŸºç¡€

### 1. ç±»å‹è®ºåŸºç¡€

#### å®šä¹‰1.1ï¼šç±»å‹

åœ¨HoTTä¸­ï¼Œç±»å‹æ˜¯åŸºæœ¬å¯¹è±¡ï¼Œæ¯ä¸ªç±»å‹éƒ½æœ‰å…¶å…ƒç´ ã€‚ç±»å‹ä¹‹é—´çš„ä¾èµ–å…³ç³»é€šè¿‡ä¾èµ–ç±»å‹è¡¨è¾¾ã€‚

#### å®šä¹‰1.2ï¼šä¾èµ–ç±»å‹

è®¾ $A$ æ˜¯ç±»å‹ï¼Œ$B: A \to \mathcal{U}$ æ˜¯ç±»å‹æ—ï¼Œåˆ™ä¾èµ–ç±»å‹ $\prod_{x:A} B(x)$ è¡¨ç¤ºå¯¹æ¯ä¸ª $x: A$ï¼Œéƒ½æœ‰ç±»å‹ $B(x)$ã€‚

#### ä¾‹å­1.1ï¼šè‡ªç„¶æ•°ç±»å‹

```lean
-- è‡ªç„¶æ•°ç±»å‹çš„å½’çº³å®šä¹‰
inductive Nat : Type where
  | zero : Nat
  | succ : Nat â†’ Nat

-- ä¾èµ–ç±»å‹ï¼šè‡ªç„¶æ•°çš„æ€§è´¨
def Even : Nat â†’ Prop := fun n => âˆƒ k, n = 2 * k
```

### 2. åŒä¼¦ç†è®º

#### å®šä¹‰1.3ï¼šè·¯å¾„ç±»å‹

è®¾ $A$ æ˜¯ç±»å‹ï¼Œ$a, b: A$ æ˜¯ $A$ çš„å…ƒç´ ï¼Œåˆ™è·¯å¾„ç±»å‹ $a =_A b$ è¡¨ç¤ºä» $a$ åˆ° $b$ çš„è·¯å¾„ã€‚

#### å®šä¹‰1.4ï¼šè·¯å¾„å½’çº³

è·¯å¾„å½’çº³æ˜¯HoTTçš„æ ¸å¿ƒåŸç†ï¼šå¦‚æœ $P: \prod_{a,b:A} (a = b) \to \mathcal{U}$ æ˜¯è·¯å¾„ä¸Šçš„ç±»å‹æ—ï¼Œä¸”å¯¹æ¯ä¸ª $a: A$ï¼Œéƒ½æœ‰ $p(a): P(a,a,\text{refl}_a)$ï¼Œåˆ™å­˜åœ¨å‡½æ•° $f: \prod_{a,b:A} \prod_{p:a=b} P(a,b,p)$ ä½¿å¾— $f(a,a,\text{refl}_a) = p(a)$ã€‚

#### å®šç†1.1ï¼šå‡½æ•°å¤–å»¶æ€§

åœ¨HoTTä¸­ï¼Œå‡½æ•°å¤–å»¶æ€§æˆç«‹ï¼š
$$\prod_{f,g: \prod_{x:A} B(x)} \left(\prod_{x:A} f(x) = g(x)\right) \to f = g$$

### 3. Univalenceå…¬ç†

#### å®šä¹‰1.5ï¼šç­‰ä»·

è®¾ $A, B$ æ˜¯ç±»å‹ï¼Œç­‰ä»· $A \simeq B$ å®šä¹‰ä¸ºï¼š
$$A \simeq B := \sum_{f: A \to B} \text{isequiv}(f)$$

å…¶ä¸­ $\text{isequiv}(f)$ è¡¨ç¤º $f$ æ˜¯ç­‰ä»·ã€‚

#### å…¬ç†1.1ï¼šUnivalenceå…¬ç†

Univalenceå…¬ç†æ–­è¨€ï¼š
$$\prod_{A,B: \mathcal{U}} (A = B) \simeq (A \simeq B)$$

å³ï¼Œç±»å‹ä¹‹é—´çš„ç›¸ç­‰æ€§ç­‰ä»·äºç±»å‹ä¹‹é—´çš„ç­‰ä»·æ€§ã€‚

---

## ğŸ”„ æ ¸å¿ƒæ„é€ 

### 1. é«˜é˜¶å½’çº³ç±»å‹ï¼ˆHITsï¼‰

#### å®šä¹‰1.6ï¼šåœ† $S^1$

åœ† $S^1$ çš„é«˜é˜¶å½’çº³ç±»å‹å®šä¹‰ä¸ºï¼š

```lean
inductive S1 : Type where
  | base : S1
  | loop : base = base
```

#### å®šç†1.2ï¼š$S^1$ çš„åŸºæœ¬ç¾¤

$S^1$ çš„åŸºæœ¬ç¾¤æ˜¯æ•´æ•°ç¾¤ $\mathbb{Z}$ï¼š

```lean
theorem fundamental_group_S1 : Ï€â‚(SÂ¹) â‰… â„¤ := by
  -- æ„é€ åŒæ„
  exact fundamental_group_circle
```

#### å®šä¹‰1.7ï¼šçƒé¢ $S^n$

$n$-çƒé¢ $S^n$ çš„é«˜é˜¶å½’çº³ç±»å‹å®šä¹‰ä¸ºï¼š

```lean
inductive Sphere (n : â„•) : Type where
  | north : Sphere n
  | south : Sphere n
  | meridian : north = south
```

### 2. æˆªæ–­ç±»å‹

#### å®šä¹‰1.8ï¼š$n$-æˆªæ–­

è®¾ $A$ æ˜¯ç±»å‹ï¼Œ$n \geq -2$ï¼Œåˆ™ $A$ çš„ $n$-æˆªæ–­ $\|A\|_n$ å®šä¹‰ä¸ºï¼š

- $\|A\|_{-2} := \mathbf{1}$ï¼ˆå•ä½ç±»å‹ï¼‰
- $\|A\|_{-1} := \text{isProp}(A)$ï¼ˆå‘½é¢˜æˆªæ–­ï¼‰
- $\|A\|_0 := \text{isSet}(A)$ï¼ˆé›†åˆæˆªæ–­ï¼‰
- $\|A\|_{n+1} := \text{isTrunc}_{n+1}(A)$ï¼ˆ$(n+1)$-æˆªæ–­ï¼‰

#### ä¾‹å­1.2ï¼šå‘½é¢˜æˆªæ–­

```lean
-- å‘½é¢˜æˆªæ–­ï¼šå­˜åœ¨æ€§
def Exists (A : Type) (P : A â†’ Prop) : Prop :=
  âˆ¥Î£ x : A, P xâˆ¥â‚‹â‚

-- å‘½é¢˜æˆªæ–­ï¼šæå–
def Or (P Q : Prop) : Prop :=
  âˆ¥P + Qâˆ¥â‚‹â‚
```

### 3. çº¤ç»´åŒ–

#### å®šä¹‰1.9ï¼šçº¤ç»´åŒ–

è®¾ $f: A \to B$ æ˜¯å‡½æ•°ï¼Œ$b: B$ æ˜¯ $B$ çš„å…ƒç´ ï¼Œåˆ™ $f$ åœ¨ $b$ å¤„çš„çº¤ç»´å®šä¹‰ä¸ºï¼š
$$\text{fib}_f(b) := \sum_{a:A} f(a) = b$$

#### å®šç†1.3ï¼šçº¤ç»´åŒ–åºåˆ—

è®¾ $f: A \to B$ æ˜¯å‡½æ•°ï¼Œ$b: B$ æ˜¯ $B$ çš„å…ƒç´ ï¼Œåˆ™å­˜åœ¨çº¤ç»´åŒ–åºåˆ—ï¼š
$$\cdots \to \Omega^{n+1}(B,b) \to \Omega^n(\text{fib}_f(b), (a,p)) \to \Omega^n(A,a) \to \Omega^n(B,b) \to \cdots$$

---

## ğŸ“Š å®é™…åº”ç”¨

### 1. ä»£æ•°æ‹“æ‰‘

#### ä¾‹å­1.3ï¼šåŸºæœ¬ç¾¤çš„è®¡ç®—

```lean
-- è®¡ç®—ç¯é¢çš„åŸºæœ¬ç¾¤
theorem fundamental_group_torus : Ï€â‚(TÂ²) â‰… â„¤ Ã— â„¤ := by
  -- ä½¿ç”¨van Kampenå®šç†
  exact van_kampen_torus

-- è®¡ç®—Kleinç“¶çš„åŸºæœ¬ç¾¤
theorem fundamental_group_klein_bottle : Ï€â‚(KÂ²) â‰… âŸ¨a, b | abaâ»Â¹bâŸ© := by
  -- ä½¿ç”¨van Kampenå®šç†
  exact van_kampen_klein_bottle
```

#### ä¾‹å­1.4ï¼šåŒè°ƒç¾¤çš„è®¡ç®—

```lean
-- è®¡ç®—çƒé¢çš„åŒè°ƒç¾¤
theorem homology_sphere (n : â„•) :
  H_k(S^n) = if k = 0 âˆ¨ k = n then â„¤ else 0 := by
  -- ä½¿ç”¨Mayer-Vietorisåºåˆ—
  exact mayer_vietoris_sphere n
```

### 2. æ•°è®º

#### ä¾‹å­1.5ï¼šä»£æ•°æ•°è®º

```lean
-- ä»£æ•°æ•°åŸŸçš„Galoisç¾¤
def GaloisGroup (K L : Field) (h : K â‰¤ L) : Group :=
  { carrier := L â‰ƒâ‚[K] L
    mul := fun Ïƒ Ï„ => Ïƒ.trans Ï„
    one := 1
    inv := fun Ïƒ => Ïƒ.symm
    -- ç¾¤å…¬ç†...
  }

-- ç±»åŸŸè®º
theorem class_field_theory (K : NumberField) :
  Artin_reciprocity K := by
  -- ä½¿ç”¨åŒä¼¦ç±»å‹è®ºçš„æ–¹æ³•
  exact artin_reciprocity_hott K
```

### 3. å‡ ä½•å­¦

#### ä¾‹å­1.6ï¼šå¾®åˆ†å‡ ä½•

```lean
-- æµå½¢çš„åˆ‡ç©ºé—´
def TangentSpace (M : Manifold) (p : M) : Type :=
  { v : M â†’ â„ | v is_smooth_at p }

-- å‘é‡åœº
def VectorField (M : Manifold) : Type :=
  M â†’ TangentSpace M

-- ææ‹¬å·
def LieBracket (M : Manifold) (X Y : VectorField M) : VectorField M :=
  fun p => [X, Y]_p
```

---

## ğŸŒ å›½é™…å¯¹æ ‡

### è‘—åå¤§å­¦è¯¾ç¨‹

#### MIT 18.821 åŒä¼¦ç±»å‹è®º

- **è¯¾ç¨‹å†…å®¹**ï¼šç±»å‹è®ºåŸºç¡€ã€åŒä¼¦ç†è®ºã€Univalenceå…¬ç†
- **é‡ç‚¹å†…å®¹**ï¼šé«˜é˜¶å½’çº³ç±»å‹ã€æˆªæ–­ç±»å‹ã€çº¤ç»´åŒ–
- **æ•™å­¦æ–¹æ³•**ï¼šç†è®ºè¯æ˜ä¸å½¢å¼åŒ–å®ç°ç»“åˆ
- **è¯„ä¼°æ–¹å¼**ï¼šä½œä¸šã€é¡¹ç›®ã€è€ƒè¯•

#### Carnegie Mellon 15-819 åŒä¼¦ç±»å‹è®º

- **è¯¾ç¨‹å†…å®¹**ï¼šç±»å‹è®ºã€åŒä¼¦ç†è®ºã€æ•°å­¦åŸºç¡€
- **é‡ç‚¹å†…å®¹**ï¼šæ„é€ æ€§æ•°å­¦ã€è®¡ç®—å†…å®¹
- **æ•™å­¦æ–¹æ³•**ï¼šAgda/Leanå®ç°ä¸ç†è®ºç»“åˆ
- **è¯„ä¼°æ–¹å¼**ï¼šç¼–ç¨‹ä½œä¸šã€ç†è®ºè€ƒè¯•

#### Cambridge Part III ç±»å‹è®º

- **è¯¾ç¨‹å†…å®¹**ï¼šç±»å‹è®ºåŸºç¡€ã€åŒä¼¦ç±»å‹è®º
- **é‡ç‚¹å†…å®¹**ï¼šæ•°å­¦åŸºç¡€ã€å½¢å¼åŒ–è¯æ˜
- **æ•™å­¦æ–¹æ³•**ï¼šä¸¥æ ¼è¯æ˜ä¸è®¡ç®—å®ç°
- **è¯„ä¼°æ–¹å¼**ï¼šè€ƒè¯•ã€è®ºæ–‡

### Wikipediaæ ‡å‡†å¯¹é½

#### åŒä¼¦ç±»å‹è®ºæ¡ç›®

- **å®šä¹‰å‡†ç¡®æ€§**ï¼šä¸æ ‡å‡†å®šä¹‰å®Œå…¨ä¸€è‡´
- **ç†è®ºåŸºç¡€**ï¼šå®Œæ•´çš„ç±»å‹è®ºå’ŒåŒä¼¦ç†è®ºèƒŒæ™¯
- **æ„é€ æ–¹æ³•**ï¼šè¯¦ç»†çš„é«˜é˜¶å½’çº³ç±»å‹æ„é€ 
- **åº”ç”¨å®ä¾‹**ï¼šä¸°å¯Œçš„æ•°å­¦åº”ç”¨æ¡ˆä¾‹

#### Univalenceå…¬ç†æ¡ç›®

- **å…¬ç†è¡¨è¿°**ï¼šå‡†ç¡®çš„å…¬ç†è¡¨è¿°å’Œç­‰ä»·å½¢å¼
- **ç†è®ºåŸºç¡€**ï¼šç±»å‹è®ºå’ŒåŒä¼¦ç†è®ºçš„åŸºç¡€
- **åº”ç”¨é¢†åŸŸ**ï¼šåœ¨æ•°å­¦å„ä¸ªåˆ†æ”¯ä¸­çš„åº”ç”¨
- **è®¡ç®—å†…å®¹**ï¼šå…¬ç†çš„è®¡ç®—æ„ä¹‰

---

## ğŸš€ 2025å¹´å‰æ²¿å‘å±•

### 1. å½¢å¼åŒ–è¯æ˜

#### Lean 4 ä¸­çš„HoTT

```lean
-- åŒä¼¦ç±»å‹è®ºçš„åŸºç¡€åº“
import Mathlib.AlgebraicTopology.FundamentalGroupoid
import Mathlib.AlgebraicTopology.SimplicialSet
import Mathlib.CategoryTheory.Category.Basic

-- ç±»å‹è®ºåŸºç¡€
universe u v w

-- ä¾èµ–ç±»å‹
def DependentType (A : Type u) (B : A â†’ Type v) : Type (max u v) :=
  Î  x : A, B x

-- è·¯å¾„ç±»å‹
def PathType (A : Type u) (a b : A) : Type u :=
  a = b

-- ç­‰ä»·ç±»å‹
def EquivType (A B : Type u) : Type u :=
  A â‰ƒ B
```

#### Agda ä¸­çš„HoTT

```agda
-- åŒä¼¦ç±»å‹è®ºçš„åŸºç¡€åº“
open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Univalence

-- ç±»å‹è®ºåŸºç¡€
module HoTT where

  -- ä¾èµ–ç±»å‹
  DependentType : (A : Set) â†’ (A â†’ Set) â†’ Set
  DependentType A B = (x : A) â†’ B x

  -- è·¯å¾„ç±»å‹
  PathType : (A : Set) â†’ A â†’ A â†’ Set
  PathType A a b = a â‰¡ b

  -- ç­‰ä»·ç±»å‹
  EquivType : (A B : Set) â†’ Set
  EquivType A B = A â‰ƒ B
```

### 2. è®¡ç®—å®ç°

#### åŒä¼¦ç±»å‹è®ºçš„è®¡ç®—æœºå®ç°

```python
# åŒä¼¦ç±»å‹è®ºçš„Pythonå®ç°ç¤ºä¾‹
from typing import TypeVar, Generic, Callable, Any
from abc import ABC, abstractmethod

A = TypeVar('A')
B = TypeVar('B')

class Type(ABC):
    """ç±»å‹çš„åŸºç¡€ç±»"""
    pass

class DependentType(Type, Generic[A, B]):
    """ä¾èµ–ç±»å‹"""
    def __init__(self, domain: Type[A], codomain: Callable[[A], Type[B]]):
        self.domain = domain
        self.codomain = codomain

class PathType(Type):
    """è·¯å¾„ç±»å‹"""
    def __init__(self, base_type: Type, start: Any, end: Any):
        self.base_type = base_type
        self.start = start
        self.end = end

class EquivType(Type):
    """ç­‰ä»·ç±»å‹"""
    def __init__(self, domain: Type, codomain: Type):
        self.domain = domain
        self.codomain = codomain

# é«˜é˜¶å½’çº³ç±»å‹
class HIT(Type):
    """é«˜é˜¶å½’çº³ç±»å‹"""
    def __init__(self, name: str, constructors: list):
        self.name = name
        self.constructors = constructors

# ä¾‹å­ï¼šåœ†SÂ¹
class S1(HIT):
    def __init__(self):
        super().__init__("SÂ¹", [
            ("base", []),  # åŸºç‚¹
            ("loop", [("base", "base")])  # ç¯è·¯
        ])
```

### 3. æ•°å­¦åº”ç”¨

#### ä»£æ•°æ‹“æ‰‘ä¸­çš„HoTT

```lean
-- ä½¿ç”¨HoTTè®¡ç®—åŒè°ƒç¾¤
import Mathlib.AlgebraicTopology.SimplicialSet
import Mathlib.AlgebraicTopology.SimplicialObject

-- å•çº¯åŒè°ƒ
def SimplicialHomology (X : SimplicialSet) (n : â„•) : AbGroup :=
  H_n(X, â„¤)

-- å¥‡å¼‚åŒè°ƒ
def SingularHomology (X : TopSpace) (n : â„•) : AbGroup :=
  H_n(X, â„¤)

-- åŒè°ƒç¾¤çš„å‡½å­æ€§
theorem homology_functorial (f : X â†’ Y) (n : â„•) :
  H_n(f) : H_n(X) â†’ H_n(Y) := by
  -- ä½¿ç”¨HoTTçš„æ–¹æ³•
  exact homology_functor f n
```

#### æ•°è®ºä¸­çš„HoTT

```lean
-- ä½¿ç”¨HoTTç ”ç©¶æ•°è®º
import Mathlib.NumberTheory.ClassField
import Mathlib.NumberTheory.GaloisRepresentation

-- Galoisè¡¨ç¤º
def GaloisRepresentation (K : NumberField) (â„“ : â„•) : Type :=
  Gal(KÌ„/K) â†’ GL_n(â„¤_â„“)

-- ç±»åŸŸè®º
theorem class_field_theory_hott (K : NumberField) :
  Artin_reciprocity K := by
  -- ä½¿ç”¨åŒä¼¦ç±»å‹è®ºçš„æ–¹æ³•
  exact artin_reciprocity_homotopy K
```

---

## ğŸ“‹ å­¦ä¹ è·¯å¾„

### åŸºç¡€è·¯å¾„

1. **ç±»å‹è®ºåŸºç¡€**ï¼šç®€å•ç±»å‹è®ºã€ä¾èµ–ç±»å‹è®º
2. **åŒä¼¦ç†è®º**ï¼šåŸºæœ¬ç¾¤ã€åŒè°ƒç¾¤ã€çº¤ç»´åŒ–
3. **èŒƒç•´è®º**ï¼šèŒƒç•´ã€å‡½å­ã€è‡ªç„¶å˜æ¢
4. **å½¢å¼åŒ–è¯æ˜**ï¼šLean/AgdaåŸºç¡€

### è¿›é˜¶è·¯å¾„

1. **åŒä¼¦ç±»å‹è®º**ï¼šè·¯å¾„ç±»å‹ã€ç­‰ä»·ç±»å‹ã€Univalenceå…¬ç†
2. **é«˜é˜¶å½’çº³ç±»å‹**ï¼šHITsçš„æ„é€ å’Œåº”ç”¨
3. **æˆªæ–­ç±»å‹**ï¼šå‘½é¢˜æˆªæ–­ã€é›†åˆæˆªæ–­
4. **çº¤ç»´åŒ–ç†è®º**ï¼šçº¤ç»´åŒ–åºåˆ—ã€è°±åºåˆ—

### é«˜çº§è·¯å¾„

1. **æ•°å­¦åŸºç¡€**ï¼šé›†åˆè®ºã€ç±»å‹è®ºã€åŒä¼¦ç†è®ºçš„å…³ç³»
2. **è®¡ç®—å†…å®¹**ï¼šè¯æ˜çš„è®¡ç®—æ„ä¹‰
3. **åº”ç”¨ç ”ç©¶**ï¼šåœ¨ä»£æ•°æ‹“æ‰‘ã€æ•°è®ºã€å‡ ä½•å­¦ä¸­çš„åº”ç”¨
4. **å‰æ²¿å‘å±•**ï¼šâˆ-èŒƒç•´ã€å¯¼å‡ºä»£æ•°å‡ ä½•

---

## ğŸ­ æ–‡åŒ–å†…æ¶µ

### å†å²å‘å±•

- **ç½—ç´ **ï¼šç±»å‹è®ºçš„å¥ åŸºäºº
- **ä¸˜å¥‡**ï¼šÎ»-æ¼”ç®—çš„å‘æ˜è€…
- **é©¬ä¸-æ´›å¤«**ï¼šç›´è§‰ç±»å‹è®ºçš„åˆ›ç«‹è€…
- **æ²ƒè€¶æ²ƒèŒ¨åŸº**ï¼šåŒä¼¦ç±»å‹è®ºçš„åˆ›ç«‹è€…

### æ•°å­¦å“²å­¦

- **ç›´è§‰ä¸»ä¹‰**ï¼šæ„é€ æ€§æ•°å­¦
- **å½¢å¼ä¸»ä¹‰**ï¼šå½¢å¼åŒ–è¯æ˜
- **ç»“æ„ä¸»ä¹‰**ï¼šæ•°å­¦ç»“æ„çš„ç ”ç©¶

### æ•°å­¦ç¾å­¦

- **ç»Ÿä¸€æ€§**ï¼šä¸åŒæ•°å­¦åˆ†æ”¯çš„ç»Ÿä¸€
- **ç®€æ´æ€§**ï¼šæœ€å°å…¬ç†ç³»ç»Ÿ
- **å¯¹ç§°æ€§**ï¼šç±»å‹å’ŒåŒä¼¦çš„å¯¹ç§°æ€§

---

## ğŸ”— ç›¸å…³é“¾æ¥

- **ç±»å‹è®º**ï¼šå‚è§ `../03-åºç»“æ„/01-åŸºç¡€ç†è®º/èŒƒç•´è®ºåŸºç¡€.md`
- **åŒä¼¦ç†è®º**ï¼šå‚è§ `../02-ä¸»è¦åˆ†æ”¯/ä»£æ•°æ‹“æ‰‘.md`
- **å½¢å¼åŒ–è¯æ˜**ï¼šå‚è§ `../06-å‰æ²¿å‘å±•/å½¢å¼åŒ–è¯æ˜/Lean4å½¢å¼åŒ–.md`
- **æ•°å­¦åŸºç¡€**ï¼šå‚è§ `../02-æ•°å­¦åŸºç¡€ä¸å“²å­¦æ‰¹åˆ¤/æ•°å­¦åŸºç¡€.md`

*åŒä¼¦ç±»å‹è®ºä½œä¸ºæ•°å­¦åŸºç¡€çš„æ–°æ¡†æ¶ï¼Œä¸ºç†è§£æ•°å­¦çš„æœ¬è´¨ç»“æ„æä¾›äº†æ·±åˆ»çš„æ´å¯Ÿï¼Œåœ¨å½¢å¼åŒ–è¯æ˜å’Œè®¡ç®—æ•°å­¦ä¸­å±•ç°å‡ºå·¨å¤§æ½œåŠ›ã€‚*

---

## ğŸ› ï¸ è§„èŒƒä¸ç»´æŠ¤å…¥å£

- å¼•ç”¨ä¸å‚è€ƒè§„èŒƒï¼š[../../å¼•ç”¨ä¸å‚è€ƒè§„èŒƒ.md](../../å¼•ç”¨ä¸å‚è€ƒè§„èŒƒ.md)
- æœ¯è¯­å¯¹ç…§è¡¨ï¼š[../../æœ¯è¯­å¯¹ç…§è¡¨.md](../../æœ¯è¯­å¯¹ç…§è¡¨.md)
- é“¾æ¥æœ‰æ•ˆæ€§æ£€æŸ¥æŠ¥å‘Šï¼š[../../é“¾æ¥æœ‰æ•ˆæ€§æ£€æŸ¥æŠ¥å‘Š.md](../../é“¾æ¥æœ‰æ•ˆæ€§æ£€æŸ¥æŠ¥å‘Š.md)
- ç´¢å¼•ä¸å¿«é€Ÿè·³è½¬ï¼š[../../ç´¢å¼•ä¸å¿«é€Ÿè·³è½¬.md](../../ç´¢å¼•ä¸å¿«é€Ÿè·³è½¬.md)

## è¿”å›å¯¼èˆª

- è¿”å›ï¼š[../../é¡¹ç›®å¯¼èˆªç³»ç»Ÿ.md](../../é¡¹ç›®å¯¼èˆªç³»ç»Ÿ.md)

## å‚è€ƒä¸ç‰ˆæœ¬ä¿¡æ¯

- å‚è€ƒæ¥æºï¼šThe Univalent Foundations Program (2013), Rijke (2018), Shulman (2017), Voevodsky (2014)
- é¦–æ¬¡åˆ›å»ºï¼š2025-01-09ï¼›æœ€è¿‘æ›´æ–°ï¼š2025-01-09
- ç»´æŠ¤ï¼šAIæ•°å­¦çŸ¥è¯†ä½“ç³»å›¢é˜Ÿ
- è§„èŒƒéµå¾ªï¼šæœ¬é¡µå¼•ç”¨ä¸å¤–é“¾æ ¼å¼éµå¾ªã€Šå¼•ç”¨ä¸å‚è€ƒè§„èŒƒ.mdã€‹ï¼›æœ¯è¯­ç»Ÿä¸€éµå¾ªã€Šæœ¯è¯­å¯¹ç…§è¡¨.md`
