# 02-标识符与关键字 | Identifiers & Keywords

## 目录

- [02-标识符与关键字 | Identifiers & Keywords](#02-标识符与关键字--identifiers--keywords)
  - [目录](#目录)
  - [1. 主题简介 | Topic Introduction](#1-主题简介--topic-introduction)
  - [2. 标识符系统 | Identifier System](#2-标识符系统--identifier-system)
  - [3. 关键字系统 | Keyword System](#3-关键字系统--keyword-system)
  - [4. 命名约定 | Naming Conventions](#4-命名约定--naming-conventions)
  - [5. 代码示例 | Code Examples](#5-代码示例--code-examples)
  - [6. 相关性与本地跳转 | Relevance & Local Navigation](#6-相关性与本地跳转--relevance--local-navigation)

---

## 1. 主题简介 | Topic Introduction

本主题深入探讨Lean语言中的标识符系统、关键字定义以及命名约定，为理解Lean语法基础提供核心知识。

This topic delves into the identifier system, keyword definitions, and naming conventions in Lean language, providing core knowledge for understanding Lean syntax fundamentals.

---

## 2. 标识符系统 | Identifier System

### 2.1 标识符定义 | Identifier Definition

- **中文定义**：标识符是编程语言中用于命名变量、函数、类型等程序实体的字符序列
- **English Definition**: An identifier is a sequence of characters used to name program entities such as variables, functions, types, etc.

### 2.2 Lean标识符规则 | Lean Identifier Rules

```lean
-- 基本标识符规则
def valid_identifier : Nat := 1
def camelCase : Nat := 2
def snake_case : Nat := 3
def PascalCase : Nat := 4

-- 特殊字符标识符
def `special-identifier` : Nat := 5
def `with spaces` : Nat := 6
def `with-unicode-α` : Nat := 7
```

### 2.3 标识符分类 | Identifier Categories

#### 2.3.1 变量标识符 | Variable Identifiers

```lean
-- 局部变量
def example : Nat := 
  let x := 1
  let y := 2
  x + y

-- 全局变量
def global_var : Nat := 42
```

#### 2.3.2 函数标识符 | Function Identifiers

```lean
-- 函数定义
def add (a b : Nat) : Nat := a + b

-- 递归函数
def factorial : Nat → Nat
  | 0 => 1
  | n + 1 => (n + 1) * factorial n
```

#### 2.3.3 类型标识符 | Type Identifiers

```lean
-- 类型定义
inductive MyType
  | constructor1 : MyType
  | constructor2 : Nat → MyType

-- 类型别名
def MyAlias := Nat
```

---

## 3. 关键字系统 | Keyword System

### 3.1 声明关键字 | Declaration Keywords

```lean
-- def: 定义函数或值
def my_function : Nat → Nat := λ x => x + 1

-- theorem: 定义定理
theorem my_theorem : ∀ n : Nat, n + 0 = n := by
  intro n
  rw [Nat.add_zero]

-- lemma: 定义引理
lemma my_lemma : ∀ n : Nat, n * 1 = n := by
  intro n
  rw [Nat.mul_one]

-- axiom: 定义公理
axiom my_axiom : ∀ n : Nat, n ≥ 0
```

### 3.2 控制流关键字 | Control Flow Keywords

```lean
-- if-then-else
def conditional (n : Nat) : String :=
  if n > 0 then "positive"
  else if n < 0 then "negative"
  else "zero"

-- match: 模式匹配
def pattern_match (n : Nat) : String :=
  match n with
  | 0 => "zero"
  | 1 => "one"
  | _ => "other"
```

### 3.3 类型系统关键字 | Type System Keywords

```lean
-- inductive: 归纳类型
inductive List (α : Type)
  | nil : List α
  | cons : α → List α → List α

-- structure: 结构体
structure Point where
  x : Nat
  y : Nat

-- class: 类型类
class Monoid (α : Type) where
  mul : α → α → α
  one : α
```

### 3.4 命名空间关键字 | Namespace Keywords

```lean
-- namespace: 命名空间
namespace MyNamespace
  def my_function : Nat := 1
end MyNamespace

-- section: 节
section MySection
  variable (α : Type)
  def generic_function : α → α := λ x => x
end MySection
```

---

## 4. 命名约定 | Naming Conventions

### 4.1 函数命名 | Function Naming

```lean
-- 使用小写字母和下划线
def add_numbers (a b : Nat) : Nat := a + b

-- 使用描述性名称
def calculate_factorial (n : Nat) : Nat :=
  match n with
  | 0 => 1
  | n + 1 => (n + 1) * calculate_factorial n
```

### 4.2 类型命名 | Type Naming

```lean
-- 使用PascalCase
inductive BinaryTree (α : Type)
  | leaf : BinaryTree α
  | node : α → BinaryTree α → BinaryTree α → BinaryTree α

-- 结构体命名
structure ComplexNumber where
  real : Float
  imaginary : Float
```

### 4.3 变量命名 | Variable Naming

```lean
-- 使用有意义的名称
def process_list (input_list : List Nat) : List Nat :=
  let filtered_list := input_list.filter (λ x => x > 0)
  let doubled_list := filtered_list.map (λ x => x * 2)
  doubled_list
```

### 4.4 常量命名 | Constant Naming

```lean
-- 使用大写字母和下划线
def MAX_ITERATIONS : Nat := 1000
def DEFAULT_TIMEOUT : Nat := 5000
```

---

## 5. 代码示例 | Code Examples

### 5.1 完整示例 | Complete Example

```lean
-- 标识符和关键字使用示例
namespace IdentifierExample

-- 类型定义
inductive Tree (α : Type)
  | empty : Tree α
  | node : α → Tree α → Tree α → Tree α

-- 函数定义
def tree_size {α : Type} : Tree α → Nat
  | Tree.empty => 0
  | Tree.node _ left right => 1 + tree_size left + tree_size right

-- 定理定义
theorem tree_size_non_negative {α : Type} (t : Tree α) : tree_size t ≥ 0 := by
  induction t with
  | empty => rw [tree_size]; exact Nat.zero_le 0
  | node _ left right ih_left ih_right =>
    rw [tree_size]
    have h1 : tree_size left ≥ 0 := ih_left
    have h2 : tree_size right ≥ 0 := ih_right
    exact Nat.le_add_of_nonneg_right (Nat.le_add_of_nonneg_left h1)

end IdentifierExample
```

### 5.2 命名约定示例 | Naming Convention Examples

```lean
-- 良好的命名约定
def calculate_fibonacci (n : Nat) : Nat :=
  if n ≤ 1 then n
  else calculate_fibonacci (n - 1) + calculate_fibonacci (n - 2)

-- 类型类定义
class Semigroup (α : Type) where
  mul : α → α → α
  mul_assoc : ∀ a b c, mul (mul a b) c = mul a (mul b c)

-- 实例定义
instance : Semigroup Nat where
  mul := Nat.mul
  mul_assoc := Nat.mul_assoc
```

---

## 6. 相关性与本地跳转 | Relevance & Local Navigation

### 6.1 与Analysis目录的关联

- 与形式化方法相关：标识符系统是形式化语言的基础
- 与逻辑系统相关：关键字定义体现了逻辑结构

### 6.2 与Refactor目录的关联

- 与编程语言设计相关：命名约定影响代码可读性
- 与软件工程相关：标识符系统影响代码维护

### 6.3 本地跳转链接

- [返回上级目录](../01-总览.md)
- [基本语法元素总览](01-总览.md)
- [表达式系统](../03-表达式系统/01-总览.md)
- [声明机制](../04-声明机制/01-总览.md)

---

*最后更新时间：2025年1月*
*版本：1.0*
*状态：已完成*
