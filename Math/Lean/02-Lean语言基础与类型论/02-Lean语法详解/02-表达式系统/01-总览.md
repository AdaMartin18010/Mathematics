# 02-è¡¨è¾¾å¼ç³»ç»Ÿ | Expression System

## ğŸ“‹ ç›®å½• | Table of Contents

- [02-è¡¨è¾¾å¼ç³»ç»Ÿ | Expression System](#02-è¡¨è¾¾å¼ç³»ç»Ÿ--expression-system)
  - [ğŸ“‹ ç›®å½• | Table of Contents](#-ç›®å½•--table-of-contents)
  - [1. ä¸»é¢˜ç®€ä»‹ | Topic Introduction](#1-ä¸»é¢˜ç®€ä»‹--topic-introduction)
  - [2. ä¸»é¢˜ä¸»çº¿ä¸æ ‘å½¢ç»“æ„ | Mainline & Tree Structure](#2-ä¸»é¢˜ä¸»çº¿ä¸æ ‘å½¢ç»“æ„--mainline--tree-structure)
    - [2.1 å‡½æ•°è¡¨è¾¾å¼ | Function Expressions](#21-å‡½æ•°è¡¨è¾¾å¼--function-expressions)
    - [2.2 ç±»å‹è¡¨è¾¾å¼ | Type Expressions](#22-ç±»å‹è¡¨è¾¾å¼--type-expressions)
    - [2.3 æ¨¡å¼åŒ¹é…è¡¨è¾¾å¼ | Pattern Matching Expressions](#23-æ¨¡å¼åŒ¹é…è¡¨è¾¾å¼--pattern-matching-expressions)
    - [2.4 è®¡ç®—è¡¨è¾¾å¼ | Computation Expressions](#24-è®¡ç®—è¡¨è¾¾å¼--computation-expressions)
  - [3. æ¦‚å¿µå®šä¹‰ | Concept Definition](#3-æ¦‚å¿µå®šä¹‰--concept-definition)
  - [4. ç†è®ºå†å²ä¸ä»£è¡¨äººç‰© | Theoretical History & Key Figures](#4-ç†è®ºå†å²ä¸ä»£è¡¨äººç‰©--theoretical-history--key-figures)
  - [5. ç°ä»£å‘å±•ä¸å‰æ²¿æŒ‘æˆ˜ | Modern Development & Frontier Challenges](#5-ç°ä»£å‘å±•ä¸å‰æ²¿æŒ‘æˆ˜--modern-development--frontier-challenges)
  - [6. ç›¸å…³æ€§ä¸æœ¬åœ°è·³è½¬ | Relevance & Local Navigation](#6-ç›¸å…³æ€§ä¸æœ¬åœ°è·³è½¬--relevance--local-navigation)
  - [7. è¿›åº¦æ—¥å¿—ä¸æ–­ç‚¹æ ‡è®° | Progress Log & Breakpoint Marking](#7-è¿›åº¦æ—¥å¿—ä¸æ–­ç‚¹æ ‡è®°--progress-log--breakpoint-marking)
  - [8. ä»£ç ç¤ºä¾‹ | Code Examples](#8-ä»£ç ç¤ºä¾‹--code-examples)

---

## 1. ä¸»é¢˜ç®€ä»‹ | Topic Introduction

æœ¬ä¸»é¢˜æ·±å…¥æ¢è®¨Leanè¯­è¨€ä¸­çš„è¡¨è¾¾å¼ç³»ç»Ÿï¼ŒåŒ…æ‹¬å‡½æ•°è¡¨è¾¾å¼ã€ç±»å‹è¡¨è¾¾å¼ã€æ¨¡å¼åŒ¹é…è¡¨è¾¾å¼ã€è®¡ç®—è¡¨è¾¾å¼ç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œä¸ºæŒæ¡Leanè¯­è¨€çš„è¡¨è¾¾å¼æ„é€ å’Œè®¡ç®—æä¾›å…¨é¢çš„ç†è®ºæŒ‡å¯¼ã€‚

This topic provides an in-depth exploration of Lean's expression system, including function expressions, type expressions, pattern matching expressions, computation expressions, and other core concepts, offering comprehensive theoretical guidance for mastering Lean's expression construction and computation.

---

## 2. ä¸»é¢˜ä¸»çº¿ä¸æ ‘å½¢ç»“æ„ | Mainline & Tree Structure

### 2.1 å‡½æ•°è¡¨è¾¾å¼ | Function Expressions

- å‡½æ•°å®šä¹‰ä¸è°ƒç”¨
- é«˜é˜¶å‡½æ•°ä¸å‡½æ•°ç»„åˆ
- åŒ¿åå‡½æ•°ä¸é—­åŒ…

### 2.2 ç±»å‹è¡¨è¾¾å¼ | Type Expressions

- åŸºæœ¬ç±»å‹æ„é€ 
- ä¾èµ–ç±»å‹æ„é€ 
- ç±»å‹æ—ä¸ç±»å‹ç±»

### 2.3 æ¨¡å¼åŒ¹é…è¡¨è¾¾å¼ | Pattern Matching Expressions

- åŸºæœ¬æ¨¡å¼åŒ¹é…
- å®ˆå«æ¨¡å¼ä¸æ¡ä»¶åŒ¹é…
- åµŒå¥—æ¨¡å¼åŒ¹é…

### 2.4 è®¡ç®—è¡¨è¾¾å¼ | Computation Expressions

- è®¡ç®—é“¾ä¸ç­‰å¼é“¾
- æ¡ä»¶è®¡ç®—ä¸åˆ†æ”¯
- é€’å½’è®¡ç®—ä¸è¿­ä»£

---

## 3. æ¦‚å¿µå®šä¹‰ | Concept Definition

### 3.1 å‡½æ•°è¡¨è¾¾å¼ | Function Expressions

- **ä¸­æ–‡å®šä¹‰**ï¼šå‡½æ•°è¡¨è¾¾å¼æ˜¯Leanè¯­è¨€ä¸­ç”¨äºå®šä¹‰å’Œè°ƒç”¨å‡½æ•°çš„è¯­æ³•æ„é€ ï¼ŒåŒ…æ‹¬å‡½æ•°å®šä¹‰ã€å‡½æ•°åº”ç”¨ã€é«˜é˜¶å‡½æ•°ç­‰ã€‚
- **English Definition**: Function expressions are syntactic constructs in Lean used to define and call functions, including function definitions, function applications, higher-order functions, etc.

### 3.2 ç±»å‹è¡¨è¾¾å¼ | Type Expressions

- **ä¸­æ–‡å®šä¹‰**ï¼šç±»å‹è¡¨è¾¾å¼æ˜¯Leanè¯­è¨€ä¸­ç”¨äºæ„é€ å’Œè¡¨ç¤ºç±»å‹çš„è¯­æ³•æ„é€ ï¼ŒåŒ…æ‹¬åŸºæœ¬ç±»å‹ã€ä¾èµ–ç±»å‹ã€ç±»å‹æ—ç­‰ã€‚
- **English Definition**: Type expressions are syntactic constructs in Lean used to construct and represent types, including basic types, dependent types, type families, etc.

### 3.3 æ¨¡å¼åŒ¹é…è¡¨è¾¾å¼ | Pattern Matching Expressions

- **ä¸­æ–‡å®šä¹‰**ï¼šæ¨¡å¼åŒ¹é…è¡¨è¾¾å¼æ˜¯Leanè¯­è¨€ä¸­ç”¨äºæ ¹æ®æ•°æ®ç»“æ„å½¢çŠ¶è¿›è¡Œæ¡ä»¶åˆ†æ”¯çš„è¯­æ³•æ„é€ ã€‚
- **English Definition**: Pattern matching expressions are syntactic constructs in Lean used for conditional branching based on data structure shapes.

### 3.4 è®¡ç®—è¡¨è¾¾å¼ | Computation Expressions

- **ä¸­æ–‡å®šä¹‰**ï¼šè®¡ç®—è¡¨è¾¾å¼æ˜¯Leanè¯­è¨€ä¸­ç”¨äºæ‰§è¡Œè®¡ç®—å’Œæ¨å¯¼çš„è¯­æ³•æ„é€ ï¼ŒåŒ…æ‹¬è®¡ç®—é“¾ã€æ¡ä»¶è®¡ç®—ç­‰ã€‚
- **English Definition**: Computation expressions are syntactic constructs in Lean used to perform computation and derivation, including computation chains, conditional computation, etc.

---

## 4. ç†è®ºå†å²ä¸ä»£è¡¨äººç‰© | Theoretical History & Key Figures

### 4.1 å‡½æ•°å¼ç¼–ç¨‹è¡¨è¾¾å¼ç³»ç»Ÿ | Functional Programming Expression Systems

- **å†å²èƒŒæ™¯**ï¼šä»Lambdaæ¼”ç®—åˆ°ç°ä»£å‡½æ•°å¼è¯­è¨€çš„è¡¨è¾¾å¼ç³»ç»Ÿæ¼”è¿›
- **è®¾è®¡åŸåˆ™**ï¼šå¯è¯»æ€§ã€ä¸€è‡´æ€§ã€ç®€æ´æ€§ç­‰è¡¨è¾¾å¼ç³»ç»Ÿè®¾è®¡åŸåˆ™
- **æŠ€æœ¯å½±å“**ï¼šè¡¨è¾¾å¼ç³»ç»Ÿå¯¹è¯­è¨€ä½¿ç”¨å’Œå¼€å‘æ•ˆç‡çš„å½±å“

### 4.2 Leanè¯­è¨€è¡¨è¾¾å¼ç‰¹è‰² | Lean Language Expression Features

- **è®¾è®¡ç†å¿µ**ï¼šåŸºäºæ•°å­¦ç¬¦å·å’Œé€»è¾‘è¡¨è¾¾å¼çš„è¡¨è¾¾å¼è®¾è®¡
- **æŠ€æœ¯ä¼˜åŠ¿**ï¼šç±»å‹å®‰å…¨ã€è¡¨è¾¾åŠ›å¼ºã€æ˜“äºå½¢å¼åŒ–éªŒè¯
- **åº”ç”¨ä»·å€¼**ï¼šåœ¨æ•°å­¦è¯æ˜å’Œè½¯ä»¶éªŒè¯ä¸­çš„ç‹¬ç‰¹ä¼˜åŠ¿

---

## 5. ç°ä»£å‘å±•ä¸å‰æ²¿æŒ‘æˆ˜ | Modern Development & Frontier Challenges

### 5.1 è¡¨è¾¾å¼ç³»ç»Ÿæ‰©å±• | Expression System Extension

- **è‡ªå®šä¹‰è¡¨è¾¾å¼**ï¼šæ”¯æŒç”¨æˆ·è‡ªå®šä¹‰è¡¨è¾¾å¼è¯­æ³•
- **è¡¨è¾¾å¼ä¼˜åŒ–**ï¼šç¼–è¯‘æ—¶è¡¨è¾¾å¼ä¼˜åŒ–å’Œç®€åŒ–
- **ç‰¹æ®Šè¡¨è¾¾å¼**ï¼šæ•°å­¦ç¬¦å·å’Œç‰¹æ®Šè¡¨è¾¾å¼æ”¯æŒ

### 5.2 è¡¨è¾¾å¼åˆ†æä¸å·¥å…·æ”¯æŒ | Expression Analysis & Tool Support

- **ç±»å‹æ¨å¯¼**ï¼šè‡ªåŠ¨ç±»å‹æ¨å¯¼å’Œæ£€æŸ¥
- **è¡¨è¾¾å¼é‡æ„**ï¼šè¡¨è¾¾å¼æ„ŸçŸ¥çš„ä»£ç é‡æ„
- **æ€§èƒ½åˆ†æ**ï¼šè¡¨è¾¾å¼æ€§èƒ½åˆ†æå’Œä¼˜åŒ–

---

## 6. ç›¸å…³æ€§ä¸æœ¬åœ°è·³è½¬ | Relevance & Local Navigation

### 6.1 ä¸Analysisç›®å½•çš„å…³è”

- **å½¢å¼åŒ–æ–¹æ³•**ï¼šä¸Analysis/03-å½¢å¼åŒ–æ–¹æ³•ä¸å…ƒæ•°å­¦/å…³è”
- **é€»è¾‘åŸºç¡€**ï¼šä¸Analysis/04-é€»è¾‘ä¸å…¬ç†ç³»ç»Ÿ/å…³è”
- **å¯è®¡ç®—æ€§**ï¼šä¸Analysis/06-å¯è®¡ç®—æ€§ä¸è‡ªåŠ¨æœºç†è®º/å…³è”

### 6.2 ä¸Refactorç›®å½•çš„å…³è”

- **æ•°å­¦åŸºç¡€**ï¼šä¸Refactor/02-æ•°å­¦åŸºç¡€ä¸é€»è¾‘/å…³è”
- **ä»£æ•°ç»“æ„**ï¼šä¸Refactor/03-ä»£æ•°ç»“æ„ä¸ç†è®º/å…³è”
- **åˆ†æå­¦**ï¼šä¸Refactor/04-åˆ†æå­¦/å…³è”

### 6.3 æœ¬åœ°è·³è½¬é“¾æ¥ï¼ˆæ‰å¹³ä¼˜å…ˆï¼‰

- [00-å¹³é“ºç´¢å¼•](./00-å¹³é“ºç´¢å¼•.md)
- [01-å‡½æ•°è¡¨è¾¾å¼.md](./01-å‡½æ•°è¡¨è¾¾å¼.md)
- [02-ç±»å‹è¡¨è¾¾å¼.md](./02-ç±»å‹è¡¨è¾¾å¼.md) | æ—§ï¼š`02-ç±»å‹è¡¨è¾¾å¼/01-æ€»è§ˆ.md`
- [03-æ¨¡å¼åŒ¹é…è¡¨è¾¾å¼.md](./03-æ¨¡å¼åŒ¹é…è¡¨è¾¾å¼.md) | æ—§ï¼š`03-æ¨¡å¼åŒ¹é…è¡¨è¾¾å¼/01-æ€»è§ˆ.md`
- [04-è®¡ç®—è¡¨è¾¾å¼.md](./04-è®¡ç®—è¡¨è¾¾å¼.md) | æ—§ï¼š`04-è®¡ç®—è¡¨è¾¾å¼/01-æ€»è§ˆ.md`

---

## 7. è¿›åº¦æ—¥å¿—ä¸æ–­ç‚¹æ ‡è®° | Progress Log & Breakpoint Marking

### 7.1 å½“å‰è¿›åº¦

- âœ… åˆ›å»ºè¡¨è¾¾å¼ç³»ç»Ÿæ€»è§ˆæ–‡ä»¶
- ğŸ”„ å»ºç«‹å­ç›®å½•ç»“æ„
- â³ å¼€å‘å„ä¸»é¢˜è¯¦ç»†å†…å®¹

### 7.2 æ–­ç‚¹æ ‡è®°

- **æ–­ç‚¹1**ï¼šå®Œæˆæ€»è§ˆæ–‡ä»¶åˆ›å»º
- **æ–­ç‚¹2**ï¼šå»ºç«‹01-å‡½æ•°è¡¨è¾¾å¼ç›®å½•
- **æ–­ç‚¹3**ï¼šå»ºç«‹02-ç±»å‹è¡¨è¾¾å¼ç›®å½•
- **æ–­ç‚¹4**ï¼šå»ºç«‹03-æ¨¡å¼åŒ¹é…è¡¨è¾¾å¼ç›®å½•
- **æ–­ç‚¹5**ï¼šå»ºç«‹04-è®¡ç®—è¡¨è¾¾å¼ç›®å½•

### 7.3 ä¸‹ä¸€æ­¥è®¡åˆ’

1. åˆ›å»º01-å‡½æ•°è¡¨è¾¾å¼ç›®å½•åŠå…¶å†…å®¹
2. åˆ›å»º02-ç±»å‹è¡¨è¾¾å¼ç›®å½•åŠå…¶å†…å®¹
3. åˆ›å»º03-æ¨¡å¼åŒ¹é…è¡¨è¾¾å¼ç›®å½•åŠå…¶å†…å®¹
4. åˆ›å»º04-è®¡ç®—è¡¨è¾¾å¼ç›®å½•åŠå…¶å†…å®¹
5. å®Œå–„å„ç›®å½•é—´çš„å…³è”å’Œæœ¬åœ°è·³è½¬

---

## 8. ä»£ç ç¤ºä¾‹ | Code Examples

### 8.1 å‡½æ•°è¡¨è¾¾å¼ç¤ºä¾‹

```lean
-- åŸºæœ¬å‡½æ•°å®šä¹‰
def square (x : Nat) : Nat := x * x

-- å‡½æ•°è°ƒç”¨
def result := square 5

-- é«˜é˜¶å‡½æ•°
def apply_twice {Î± : Type} (f : Î± â†’ Î±) (x : Î±) : Î± := f (f x)

-- å‡½æ•°ç»„åˆ
def compose {Î± Î² Î³ : Type} (f : Î² â†’ Î³) (g : Î± â†’ Î²) : Î± â†’ Î³ :=
  fun x => f (g x)

-- åŒ¿åå‡½æ•°
def anonymous_function := fun x => x + 1

-- é—­åŒ…
def create_adder (n : Nat) : Nat â†’ Nat :=
  fun x => x + n
```

### 8.2 ç±»å‹è¡¨è¾¾å¼ç¤ºä¾‹

```lean
-- åŸºæœ¬ç±»å‹æ„é€ 
def basic_type : Type := Nat

-- å‡½æ•°ç±»å‹æ„é€ 
def function_type : Type := Nat â†’ Nat

-- ä¾èµ–ç±»å‹æ„é€ 
def dependent_type (n : Nat) : Type := Vector Nat n

-- ç±»å‹æ—æ„é€ 
def type_family (Î± : Type) : Type := List Î±

-- ç±»å‹ç±»æ„é€ 
class Monoid (Î± : Type) where
  mul : Î± â†’ Î± â†’ Î±
  one : Î±
  mul_assoc : âˆ€ a b c, mul (mul a b) c = mul a (mul b c)
  one_mul : âˆ€ a, mul one a = a
  mul_one : âˆ€ a, mul a one = a
```

### 8.3 æ¨¡å¼åŒ¹é…è¡¨è¾¾å¼ç¤ºä¾‹

```lean
-- åŸºæœ¬æ¨¡å¼åŒ¹é…
def length {Î± : Type} : List Î± â†’ Nat
  | [] => 0
  | _ :: xs => 1 + length xs

-- å®ˆå«æ¨¡å¼
def abs : Int â†’ Nat
  | n => if n â‰¥ 0 then n.toNat else (-n).toNat

-- åµŒå¥—æ¨¡å¼åŒ¹é…
def complex_match : List (Nat Ã— String) â†’ String
  | [] => "empty"
  | [(n, s)] => s
  | (n, s) :: _ :: _ => s

-- æ¨¡å¼åŒ¹é…ä¸ç±»å‹
def head {Î± : Type} : List Î± â†’ Option Î±
  | [] => none
  | h :: _ => some h
```

### 8.4 è®¡ç®—è¡¨è¾¾å¼ç¤ºä¾‹

```lean
-- è®¡ç®—é“¾
def calculation_chain (a b c : Nat) : Nat :=
  let step1 := a + b
  let step2 := step1 * c
  let step3 := step2 - a
  step3

-- æ¡ä»¶è®¡ç®—
def conditional_computation (n : Nat) : Nat :=
  if n > 0 then
    let doubled := n * 2
    let squared := doubled * doubled
    squared
  else
    0

-- é€’å½’è®¡ç®—
def factorial : Nat â†’ Nat
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

-- ç­‰å¼é“¾
def equality_chain (a b c : Nat) : Prop :=
  a + b + c = c + b + a
```

---

*æœ€åæ›´æ–°æ—¶é—´ï¼š2025å¹´1æœˆ*
*ç‰ˆæœ¬ï¼š1.0*
*çŠ¶æ€ï¼šè¿›è¡Œä¸­*
