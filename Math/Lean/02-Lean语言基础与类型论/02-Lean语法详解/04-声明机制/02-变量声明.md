# 02-变量声明 | Variable Declarations

## 目录

- [02-变量声明 | Variable Declarations](#02-变量声明--variable-declarations)
  - [目录](#目录)
  - [1. 主题简介 | Topic Introduction](#1-主题简介--topic-introduction)
  - [2. 基本变量声明 | Basic Variable Declaration](#2-基本变量声明--basic-variable-declaration)
    - [2.1 简单变量声明 | Simple Variable Declaration](#21-简单变量声明--simple-variable-declaration)
    - [2.2 函数参数变量 | Function Parameter Variables](#22-函数参数变量--function-parameter-variables)
    - [2.3 计算表达式变量 | Computed Expression Variables](#23-计算表达式变量--computed-expression-variables)
  - [3. Let表达式 | Let Expressions](#3-let表达式--let-expressions)
    - [3.1 基本Let表达式 | Basic Let Expressions](#31-基本let表达式--basic-let-expressions)
    - [3.2 Let表达式的高级用法 | Advanced Let Usage](#32-let表达式的高级用法--advanced-let-usage)
    - [3.3 Let表达式的类型推导 | Type Inference in Let](#33-let表达式的类型推导--type-inference-in-let)
  - [4. 模式匹配变量 | Pattern Matching Variables](#4-模式匹配变量--pattern-matching-variables)
    - [4.1 基本模式匹配 | Basic Pattern Matching](#41-基本模式匹配--basic-pattern-matching)
    - [4.2 复杂模式匹配 | Complex Pattern Matching](#42-复杂模式匹配--complex-pattern-matching)
    - [4.3 模式匹配变量绑定 | Pattern Matching Variable Binding](#43-模式匹配变量绑定--pattern-matching-variable-binding)
  - [5. 变量作用域 | Variable Scope](#5-变量作用域--variable-scope)
    - [5.1 局部作用域 | Local Scope](#51-局部作用域--local-scope)
    - [5.2 函数作用域 | Function Scope](#52-函数作用域--function-scope)
    - [5.3 命名空间作用域 | Namespace Scope](#53-命名空间作用域--namespace-scope)
  - [6. 代码示例 | Code Examples](#6-代码示例--code-examples)
    - [6.1 完整示例 | Complete Example](#61-完整示例--complete-example)
    - [6.2 高级变量模式 | Advanced Variable Patterns](#62-高级变量模式--advanced-variable-patterns)
  - [7. 相关性与本地跳转 | Relevance \& Local Navigation](#7-相关性与本地跳转--relevance--local-navigation)
    - [7.1 与Analysis目录的关联](#71-与analysis目录的关联)
    - [7.2 与Refactor目录的关联](#72-与refactor目录的关联)
    - [7.3 本地跳转链接](#73-本地跳转链接)

---

## 1. 主题简介 | Topic Introduction

本主题深入探讨Lean语言中的变量声明系统，包括基本变量绑定、let表达式、模式匹配变量和作用域规则，为理解Lean的变量管理机制提供基础。

This topic delves into the variable declaration system in Lean language, including basic variable binding, let expressions, pattern matching variables, and scope rules, providing the foundation for understanding Lean's variable management mechanisms.

---

## 2. 基本变量声明 | Basic Variable Declaration

### 2.1 简单变量声明 | Simple Variable Declaration

```lean
-- 基本变量声明
def basic_example : Nat :=
  let x := 1
  let y := 2
  x + y

-- 带类型注解的变量
def typed_variables : Nat :=
  let x : Nat := 10
  let y : Nat := 20
  x + y

-- 多变量声明
def multiple_variables : Nat :=
  let a := 1
  let b := 2
  let c := 3
  a + b + c
```

### 2.2 函数参数变量 | Function Parameter Variables

```lean
-- 函数参数作为变量
def function_with_variables (x y : Nat) : Nat :=
  let sum := x + y
  let product := x * y
  sum + product

-- 参数模式匹配
def pattern_function : Nat → Nat
  | 0 => 0
  | n + 1 => 
    let prev := pattern_function n
    prev + n + 1
```

### 2.3 计算表达式变量 | Computed Expression Variables

```lean
-- 计算表达式赋值
def computed_variables : Nat :=
  let base := 5
  let squared := base * base
  let cubed := squared * base
  cubed

-- 条件变量
def conditional_variables (n : Nat) : Nat :=
  let is_even := n % 2 = 0
  let result := if is_even then n / 2 else n * 3 + 1
  result
```

---

## 3. Let表达式 | Let Expressions

### 3.1 基本Let表达式 | Basic Let Expressions

```lean
-- 基本let表达式
def let_example : Nat :=
  let x := 1
  let y := 2
  x + y

-- 嵌套let表达式
def nested_let : Nat :=
  let x := 1
  let y := 
    let a := 2
    let b := 3
    a + b
  x + y
```

### 3.2 Let表达式的高级用法 | Advanced Let Usage

```lean
-- 函数调用结果赋值
def function_result_let : Nat :=
  let doubled := (λ x => x * 2) 5
  let squared := (λ x => x * x) doubled
  squared

-- 条件let表达式
def conditional_let (n : Nat) : Nat :=
  let value := if n > 0 then n else 1
  let result := value * 2
  result

-- 模式匹配let表达式
def pattern_let : List Nat → Nat :=
  λ xs => 
    let (head, tail) := match xs with
      | [] => (0, [])
      | x :: xs => (x, xs)
    head + tail.length
```

### 3.3 Let表达式的类型推导 | Type Inference in Let

```lean
-- 类型推导示例
def inferred_let :=
  let x := 1        -- 自动推导为 Nat
  let y := "hello"  -- 自动推导为 String
  x

-- 显式类型注解
def explicit_let : Nat :=
  let x : Nat := 1
  let y : Nat := 2
  x + y

-- 泛型let表达式
def generic_let {α : Type} (x : α) : α :=
  let value := x
  value
```

---

## 4. 模式匹配变量 | Pattern Matching Variables

### 4.1 基本模式匹配 | Basic Pattern Matching

```lean
-- 列表模式匹配
def list_pattern : List Nat → Nat :=
  | [] => 0
  | x :: xs => 
    let head := x
    let tail_length := list_pattern xs
    head + tail_length

-- 元组模式匹配
def tuple_pattern : Nat × Nat → Nat :=
  λ (x, y) => 
    let sum := x + y
    let product := x * y
    sum + product
```

### 4.2 复杂模式匹配 | Complex Pattern Matching

```lean
-- 嵌套模式匹配
inductive Tree (α : Type)
  | leaf : Tree α
  | node : α → Tree α → Tree α → Tree α

def tree_pattern {α : Type} : Tree α → Nat :=
  | Tree.leaf => 0
  | Tree.node value left right => 
    let left_size := tree_pattern left
    let right_size := tree_pattern right
    1 + left_size + right_size

-- 条件模式匹配
def conditional_pattern : List Nat → Nat :=
  | [] => 0
  | [x] => x
  | x :: y :: xs => 
    let first := x
    let second := y
    let rest := conditional_pattern xs
    first + second + rest
```

### 4.3 模式匹配变量绑定 | Pattern Matching Variable Binding

```lean
-- 变量绑定模式匹配
def binding_pattern : List Nat → Nat :=
  | [] => 0
  | x :: xs => 
    let head_value := x
    let tail_sum := binding_pattern xs
    head_value + tail_sum

-- 忽略某些值
def ignore_pattern : List Nat → Nat :=
  | [] => 0
  | _ :: xs => 
    let tail_count := ignore_pattern xs
    1 + tail_count

-- 条件绑定
def conditional_binding (xs : List Nat) : Nat :=
  match xs with
  | [] => 0
  | x :: xs => 
    let is_positive := x > 0
    let tail_sum := conditional_binding xs
    if is_positive then x + tail_sum else tail_sum
```

---

## 5. 变量作用域 | Variable Scope

### 5.1 局部作用域 | Local Scope

```lean
-- 局部变量作用域
def local_scope_example : Nat :=
  let x := 1
  let y := 2
  let z := x + y  -- 可以访问x和y
  z

-- 嵌套作用域
def nested_scope : Nat :=
  let x := 1
  let y := 
    let x := 2  -- 遮蔽外层的x
    x + 1
  x + y  -- 使用外层的x
```

### 5.2 函数作用域 | Function Scope

```lean
-- 函数参数作用域
def function_scope (x : Nat) : Nat :=
  let y := x + 1
  let z := y * 2
  z

-- 嵌套函数作用域
def nested_function : Nat → Nat :=
  λ x => 
    let inner_function := λ y => y + x  -- 可以访问外层参数x
    inner_function 5
```

### 5.3 命名空间作用域 | Namespace Scope

```lean
-- 命名空间作用域
namespace VariableScope

def global_var : Nat := 42

def function_with_global : Nat :=
  let local_var := 10
  global_var + local_var

end VariableScope

-- 访问命名空间变量
def access_namespace : Nat :=
  VariableScope.global_var
```

---

## 6. 代码示例 | Code Examples

### 6.1 完整示例 | Complete Example

```lean
/-- 变量声明示例模块
   演示各种变量声明和使用的模式 -/
namespace VariableExamples

-- 基本变量使用
def calculate_area (width height : Nat) : Nat :=
  let area := width * height
  let perimeter := 2 * (width + height)
  area + perimeter

-- 复杂变量计算
def fibonacci_with_variables (n : Nat) : Nat :=
  if n ≤ 1 then
    n
  else
    let prev := fibonacci_with_variables (n - 1)
    let prev_prev := fibonacci_with_variables (n - 2)
    prev + prev_prev

-- 列表处理变量
def process_list_with_variables (xs : List Nat) : Nat :=
  match xs with
  | [] => 0
  | x :: xs => 
    let head_value := x
    let tail_sum := process_list_with_variables xs
    let doubled_head := head_value * 2
    doubled_head + tail_sum

-- 条件变量处理
def conditional_variable_processing (n : Nat) : Nat :=
  let is_even := n % 2 = 0
  let processed_value := 
    if is_even then
      let half := n / 2
      half * 2
    else
      let triple := n * 3
      triple + 1
  processed_value

end VariableExamples
```

### 6.2 高级变量模式 | Advanced Variable Patterns

```lean
-- 高级变量使用模式
namespace AdvancedVariables

-- 函数组合变量
def function_composition_variables : Nat → Nat :=
  λ x => 
    let add_one := λ y => y + 1
    let double := λ y => y * 2
    let composed := double ∘ add_one
    composed x

-- 递归变量模式
def recursive_variable_pattern (n : Nat) : Nat :=
  let rec helper (acc : Nat) (current : Nat) : Nat :=
    if current = 0 then
      acc
    else
      let new_acc := acc + current
      let new_current := current - 1
      helper new_acc new_current
  helper 0 n

-- 状态变量模式
def state_variable_pattern (xs : List Nat) : Nat :=
  let rec process_with_state (remaining : List Nat) (sum : Nat) : Nat :=
    match remaining with
    | [] => sum
    | x :: xs => 
      let new_sum := sum + x
      let new_remaining := xs
      process_with_state new_remaining new_sum
  process_with_state xs 0

end AdvancedVariables
```

---

## 7. 相关性与本地跳转 | Relevance & Local Navigation

### 7.1 与Analysis目录的关联

- 与形式化方法相关：变量声明是形式化表达的基础
- 与逻辑系统相关：变量作用域体现了逻辑结构

### 7.2 与Refactor目录的关联

- 与编程语言设计相关：变量管理影响语言表达能力
- 与软件工程相关：变量作用域影响代码维护性

### 7.3 本地跳转链接

- [返回上级目录](../01-总览.md)
- [声明机制总览](01-总览.md)
- [基本语法元素](../02-基本语法元素/01-总览.md)
- [表达式系统](../03-表达式系统/01-总览.md)

---

*最后更新时间：2025年1月*
*版本：1.0*
*状态：已完成*
