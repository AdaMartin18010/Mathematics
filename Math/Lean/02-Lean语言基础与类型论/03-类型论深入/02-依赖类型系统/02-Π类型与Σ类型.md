# Π类型与Σ类型 | Π Types and Σ Types

## 概述 | Overview

Π类型（依赖函数类型）和Σ类型（依赖积类型）是依赖类型论中的核心概念，它们扩展了简单类型论中的函数类型和积类型，使其能够表达更丰富的类型依赖关系。

Π types (dependent function types) and Σ types (dependent product types) are core concepts in dependent type theory, extending simple type theory's function types and product types to express richer type dependencies.

## 1. Π类型（依赖函数类型）| Π Types (Dependent Function Types)

### 1.1 形式化定义 | Formal Definition

Π类型表示一个函数类型，其中返回值的类型依赖于输入参数的值。

```lean
-- Π类型的基本语法
Π (x : A), B x
-- 或者使用更简洁的语法
∀ (x : A), B x
```

### 1.2 理论基础 | Theoretical Foundation

Π类型是简单类型论中函数类型 `A → B` 的推广，允许返回类型 `B x` 依赖于输入参数 `x` 的值。

**形式化规则**：

- **形成规则**：如果 `A : Type` 且 `B : A → Type`，则 `Π (x : A), B x : Type`
- **引入规则**：如果 `f : Π (x : A), B x`，则 `f a : B a`
- **消除规则**：如果 `f : Π (x : A), B x` 且 `a : A`，则 `f a : B a`

### 1.3 Lean代码示例 | Lean Code Examples

```lean
-- 基本Π类型示例
def identity : Π (A : Type), A → A :=
  λ A x => x

-- 依赖函数类型示例
def vector_map : Π (A B : Type) (n : ℕ), (A → B) → vector A n → vector B n
| A B 0 f v := vector.nil
| A B (n+1) f (vector.cons h t) := vector.cons (f h) (vector_map A B n f t)

-- 使用Π类型定义数学函数
def sum_to_n : Π (n : ℕ), ℕ
| 0 := 0
| (n+1) := (n+1) + sum_to_n n

-- 类型族上的Π类型
def family_map : Π {A : Type} {B : A → Type}, 
  (Π (a : A), B a) → Π (a : A), B a :=
  λ f a => f a
```

### 1.4 应用场景 | Application Scenarios

- **数学函数**：定义依赖于参数类型的函数
- **数据结构**：定义依赖于大小的数据结构操作
- **定理证明**：表达依赖于参数的命题
- **程序验证**：确保类型安全的数据处理

## 2. Σ类型（依赖积类型）| Σ Types (Dependent Product Types)

### 2.1 形式化定义 | Formal Definition

Σ类型表示一个积类型，其中第二个分量的类型依赖于第一个分量的值。

```lean
-- Σ类型的基本语法
Σ (x : A), B x
-- 或者使用更简洁的语法
{x : A // B x}
```

### 2.2 理论基础 | Theoretical Foundation

Σ类型是简单类型论中积类型 `A × B` 的推广，允许第二个类型 `B x` 依赖于第一个分量 `x` 的值。

**形式化规则**：

- **形成规则**：如果 `A : Type` 且 `B : A → Type`，则 `Σ (x : A), B x : Type`
- **引入规则**：如果 `a : A` 且 `b : B a`，则 `⟨a, b⟩ : Σ (x : A), B x`
- **消除规则**：如果 `p : Σ (x : A), B x`，则 `p.1 : A` 且 `p.2 : B p.1`

### 2.3 Lean代码示例 | Lean Code Examples

```lean
-- 基本Σ类型示例
def pair_with_proof : Σ (n : ℕ), n > 0 :=
  ⟨1, nat.zero_lt_one⟩

-- 依赖积类型示例
def vector_with_length : Σ (A : Type) (n : ℕ), vector A n :=
  ⟨ℕ, 3, vector.cons 1 (vector.cons 2 (vector.cons 3 vector.nil))⟩

-- 存在量词的形式化
def exists_even : Σ (n : ℕ), even n :=
  ⟨2, even_two⟩

-- 类型族上的Σ类型
def dependent_pair : Σ {A : Type} (a : A), A :=
  ⟨ℕ, 0, 0⟩

-- 使用Σ类型定义子集
def positive_nat : Type := Σ (n : ℕ), n > 0

def add_positive : positive_nat → positive_nat → positive_nat :=
  λ ⟨n, hn⟩ ⟨m, hm⟩ => ⟨n + m, add_pos hn hm⟩
```

### 2.4 应用场景 | Application Scenarios

- **存在性证明**：形式化存在量词
- **子集定义**：定义带有约束的类型
- **数据结构**：定义带有证明的数据
- **程序验证**：确保数据满足特定条件

## 3. Π类型与Σ类型的关系 | Relationship Between Π and Σ Types

### 3.1 Curry-Howard对应 | Curry-Howard Correspondence

在命题即类型的观点下：

- Π类型对应全称量词 ∀
- Σ类型对应存在量词 ∃

```lean
-- 全称量词的形式化
def forall_prop : Π (P : ℕ → Prop), (Π (n : ℕ), P n) → Prop :=
  λ P f => ∀ n, P n

-- 存在量词的形式化
def exists_prop : Π (P : ℕ → Prop), (Σ (n : ℕ), P n) → Prop :=
  λ P ⟨n, p⟩ => ∃ n, P n
```

### 3.2 类型等价性 | Type Equivalence

某些情况下，Π类型和Σ类型可以相互转换：

```lean
-- Π类型到Σ类型的转换
def pi_to_sigma : (Π (A : Type), A → A) → Σ (f : Type → Type → Type), 
  Π (A : Type), f A A :=
  λ f => ⟨λ A B => A → B, λ A => f A⟩

-- Σ类型到Π类型的转换（部分情况）
def sigma_to_pi : (Σ (A : Type), A) → Π (P : Type → Prop), 
  (Π (A : Type), A → P A) → Prop :=
  λ ⟨A, a⟩ P f => P A (f A a)
```

## 4. 高级应用 | Advanced Applications

### 4.1 类型族与索引类型 | Type Families and Indexed Types

```lean
-- 使用Π类型定义类型族
def type_family : Π (n : ℕ), Type :=
  λ n => fin n

-- 使用Σ类型定义索引类型
def indexed_type : Σ (n : ℕ), fin n :=
  ⟨3, ⟨0, nat.zero_lt_three⟩⟩
```

### 4.2 依赖模式匹配 | Dependent Pattern Matching

```lean
-- 在Π类型上进行模式匹配
def dependent_match : Π (n : ℕ), fin n → ℕ
| 0 f := absurd f (fin.not_lt_zero f)
| (n+1) ⟨i, h⟩ := i

-- 在Σ类型上进行模式匹配
def sigma_match : Σ (n : ℕ), fin n → ℕ
| ⟨0, f⟩ := absurd f (fin.not_lt_zero f)
| ⟨n+1, ⟨i, h⟩⟩ := i
```

### 4.3 定理证明应用 | Theorem Proving Applications

```lean
-- 使用Π类型证明定理
theorem forall_implies_exists : 
  Π (P : ℕ → Prop), (Π (n : ℕ), P n) → (Σ (n : ℕ), P n) :=
  λ P f => ⟨0, f 0⟩

-- 使用Σ类型构造反例
theorem not_forall_implies_exists_not :
  Π (P : ℕ → Prop), ¬(Π (n : ℕ), P n) → (Σ (n : ℕ), ¬P n) :=
  λ P h => sorry  -- 需要经典逻辑
```

## 5. 性能与优化 | Performance and Optimization

### 5.1 类型推导优化 | Type Inference Optimization

```lean
-- 显式类型注解优化推导
def optimized_pi : Π (A : Type), A → A :=
  λ (A : Type) (x : A) => x

-- 使用类型族优化
def optimized_sigma : Σ (A : Type), A :=
  ⟨ℕ, 0⟩
```

### 5.2 内存管理 | Memory Management

- Π类型通常通过闭包实现
- Σ类型通常通过结构体实现
- 依赖类型可能影响编译优化

## 6. 最佳实践 | Best Practices

### 6.1 类型设计原则 | Type Design Principles

1. **明确性**：使用清晰的类型注解
2. **一致性**：保持类型族的一致性
3. **可读性**：选择有意义的类型名称
4. **效率性**：考虑类型推导的性能影响

### 6.2 代码组织 | Code Organization

```lean
-- 将复杂类型定义为别名
def vector_type (A : Type) (n : ℕ) : Type := vector A n

-- 使用类型类简化依赖类型
class has_length (α : Type) :=
  (length : α → ℕ)

instance : has_length (list α) :=
  ⟨list.length⟩
```

## 7. 总结 | Summary

Π类型和Σ类型是依赖类型论的核心概念，它们：

- **扩展表达能力**：支持类型依赖关系
- **增强类型安全**：提供更精确的类型检查
- **支持定理证明**：通过Curry-Howard对应支持逻辑推理
- **促进代码复用**：通过类型族实现通用算法

这些类型为Lean提供了强大的表达能力，使其能够处理复杂的数学结构和程序验证需求。

---

*最后更新时间：2025年1月*
*版本：1.0*
*状态：完成*
