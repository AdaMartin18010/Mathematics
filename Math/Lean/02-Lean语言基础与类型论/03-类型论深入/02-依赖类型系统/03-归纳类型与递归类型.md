# 03-归纳类型与递归类型 | Inductive Types and Recursive Types

## 概述 | Overview

归纳类型（Inductive Types）和递归类型（Recursive Types）是依赖类型系统中的核心概念，它们为定义复杂的数据结构和逻辑结构提供了强大的表达能力。归纳类型通过构造函数定义，而递归类型则通过类型级别的递归实现。

Inductive types and recursive types are core concepts in dependent type systems, providing powerful expressive capabilities for defining complex data structures and logical structures. Inductive types are defined through constructors, while recursive types are implemented through type-level recursion.

## 1. 归纳类型基础 | Inductive Types Fundamentals

### 1.1 归纳类型定义 | Inductive Type Definition

归纳类型是Lean中最基本的数据类型定义方式，通过指定构造函数来定义类型的结构。

```lean
-- 自然数的归纳定义
inductive Nat : Type where
  | zero : Nat
  | succ : Nat → Nat

-- 列表的归纳定义
inductive List (α : Type) : Type where
  | nil : List α
  | cons : α → List α → List α

-- 二叉树的归纳定义
inductive Tree (α : Type) : Type where
  | leaf : Tree α
  | node : α → Tree α → Tree α → Tree α
```

### 1.2 参数化归纳类型 | Parameterized Inductive Types

参数化归纳类型允许类型依赖于其他类型参数，这是多态性的基础。

```lean
-- 参数化列表类型
inductive List (α : Type) : Type where
  | nil : List α
  | cons : α → List α → List α

-- 参数化树类型
inductive Tree (α : Type) : Type where
  | leaf : Tree α
  | node : α → Tree α → Tree α → Tree α

-- 参数化向量类型（长度索引）
inductive Vec (α : Type) : Nat → Type where
  | nil : Vec α 0
  | cons : {n : Nat} → α → Vec α n → Vec α (n + 1)
```

### 1.3 索引归纳类型 | Indexed Inductive Types

索引归纳类型使用索引来进一步细化类型，这是依赖类型系统的核心特性。

```lean
-- 长度索引的向量
inductive Vec (α : Type) : Nat → Type where
  | nil : Vec α 0
  | cons : {n : Nat} → α → Vec α n → Vec α (n + 1)

-- 平衡二叉树
inductive BalancedTree (α : Type) : Nat → Type where
  | leaf : BalancedTree α 0
  | node : {h : Nat} → α → BalancedTree α h → BalancedTree α h → BalancedTree α (h + 1)

-- 有序列表
inductive SortedList (α : Type) [LE α] : Type where
  | nil : SortedList α
  | cons : (x : α) → (xs : SortedList α) → 
          (∀ y ∈ xs, x ≤ y) → SortedList α
```

## 2. 递归类型理论 | Recursive Type Theory

### 2.1 递归类型定义 | Recursive Type Definition

递归类型通过类型级别的递归来定义，通常用于表示无限的数据结构。

```lean
-- 递归类型定义
inductive Stream (α : Type) : Type where
  | mk : α → (Unit → Stream α) → Stream α

-- 使用递归类型定义无限流
def head {α : Type} : Stream α → α
  | Stream.mk x _ => x

def tail {α : Type} : Stream α → Stream α
  | Stream.mk _ f => f ()

-- 构造无限流
def constStream (x : α) : Stream α :=
  Stream.mk x (fun _ => constStream x)
```

### 2.2 互递归类型 | Mutually Recursive Types

互递归类型允许多个类型相互依赖，形成复杂的类型系统。

```lean
-- 互递归类型定义
mutual
  inductive Tree (α : Type) : Type where
    | leaf : α → Tree α
    | node : Forest α → Tree α

  inductive Forest (α : Type) : Type where
    | nil : Forest α
    | cons : Tree α → Forest α → Forest α
end

-- 互递归函数定义
mutual
  def Tree.size {α : Type} : Tree α → Nat
    | Tree.leaf _ => 1
    | Tree.node f => Forest.size f

  def Forest.size {α : Type} : Forest α → Nat
    | Forest.nil => 0
    | Forest.cons t f => Tree.size t + Forest.size f
end
```

## 3. 高级归纳类型技术 | Advanced Inductive Type Techniques

### 3.1 归纳类型模式匹配 | Pattern Matching on Inductive Types

模式匹配是处理归纳类型的基本技术，Lean提供了强大的模式匹配支持。

```lean
-- 自然数模式匹配
def Nat.add : Nat → Nat → Nat
  | Nat.zero, n => n
  | Nat.succ m, n => Nat.succ (Nat.add m n)

-- 列表模式匹配
def List.length {α : Type} : List α → Nat
  | List.nil => 0
  | List.cons _ xs => 1 + List.length xs

-- 向量模式匹配
def Vec.head {α : Type} {n : Nat} : Vec α (n + 1) → α
  | Vec.cons x _ => x

def Vec.tail {α : Type} {n : Nat} : Vec α (n + 1) → Vec α n
  | Vec.cons _ xs => xs
```

### 3.2 归纳类型递归函数 | Recursive Functions on Inductive Types

递归函数是处理归纳类型的核心工具，需要确保终止性。

```lean
-- 结构递归：自然数加法
def Nat.add : Nat → Nat → Nat
  | Nat.zero, n => n
  | Nat.succ m, n => Nat.succ (Nat.add m n)

-- 结构递归：列表连接
def List.append {α : Type} : List α → List α → List α
  | List.nil, ys => ys
  | List.cons x xs, ys => List.cons x (List.append xs ys)

-- 结构递归：树的高度
def Tree.height {α : Type} : Tree α → Nat
  | Tree.leaf => 0
  | Tree.node _ left right => 1 + max (Tree.height left) (Tree.height right)
```

## 4. 实际应用与最佳实践 | Practical Applications and Best Practices

### 4.1 数据结构实现 | Data Structure Implementation

归纳类型和递归类型广泛用于实现各种数据结构。

```lean
-- 红黑树实现
inductive Color : Type where
  | red : Color
  | black : Color

inductive RBTree (α : Type) [LE α] : Type where
  | empty : RBTree α
  | node : Color → α → RBTree α → RBTree α → RBTree α

-- 红黑树插入
def RBTree.insert {α : Type} [LE α] (x : α) : RBTree α → RBTree α
  | RBTree.empty => RBTree.node Color.red x RBTree.empty RBTree.empty
  | RBTree.node c y left right =>
    if x ≤ y then
      RBTree.node c y (RBTree.insert x left) right
    else
      RBTree.node c y left (RBTree.insert x right)
```

### 4.2 语言实现 | Language Implementation

归纳类型常用于实现编程语言的抽象语法树。

```lean
-- 简单表达式语言
inductive Expr : Type where
  | const : Nat → Expr
  | var : String → Expr
  | add : Expr → Expr → Expr
  | mul : Expr → Expr → Expr
  | let : String → Expr → Expr → Expr

-- 表达式求值
def Expr.eval (env : String → Nat) : Expr → Nat
  | Expr.const n => n
  | Expr.var x => env x
  | Expr.add e1 e2 => Expr.eval env e1 + Expr.eval env e2
  | Expr.mul e1 e2 => Expr.eval env e1 * Expr.eval env e2
  | Expr.let x e1 e2 => 
    let v1 := Expr.eval env e1
    let env' := fun y => if y = x then v1 else env y
    Expr.eval env' e2
```

## 5. 理论背景与前沿发展 | Theoretical Background and Frontier Development

### 5.1 理论基础 | Theoretical Foundation

归纳类型和递归类型的理论基础包括：

- **构造演算（Calculus of Constructions）**：为归纳类型提供理论基础
- **Martin-Löf类型论**：提供直觉主义逻辑和类型论的统一框架
- **同伦类型论（Homotopy Type Theory）**：扩展类型论以包含同伦理论

### 5.2 前沿研究方向 | Frontier Research Directions

- **高阶归纳类型（Higher Inductive Types）**：在同伦类型论中引入路径和同伦
- **归纳-递归类型（Inductive-Recursive Types）**：结合归纳和递归定义
- **参数化高阶抽象语法（PHOAS）**：用于语言实现的高级技术

## 6. 总结 | Summary

归纳类型和递归类型是Lean类型系统的核心组成部分，它们提供了：

1. **强大的表达能力**：能够定义复杂的数据结构和逻辑结构
2. **类型安全保证**：通过类型系统确保程序的正确性
3. **自动化证明支持**：支持归纳证明和模式匹配
4. **模块化设计**：支持可重用的类型定义

这些特性使Lean成为形式化数学和程序验证的强大工具，在学术界和工业界都有广泛应用。

---

**参考资源 | References**:

- Lean 4官方文档：<https://leanprover.github.io/lean4/doc/>
- 剑桥大学类型论课程：<https://www.cl.cam.ac.uk/teaching/2021/ConceptsPL/>
- 卡内基梅隆大学形式化方法课程：<https://www.cs.cmu.edu/~rwh/courses/hott/>
- 同伦类型论：<https://homotopytypetheory.org/book/>
