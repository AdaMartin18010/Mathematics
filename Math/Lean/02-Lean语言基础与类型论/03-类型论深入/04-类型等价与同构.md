# 04-类型等价与同构 | Type Equivalence & Isomorphism

## 目录

- [04-类型等价与同构 | Type Equivalence \& Isomorphism](#04-类型等价与同构--type-equivalence--isomorphism)
  - [目录](#目录)
  - [1. 主题简介 | Topic Introduction](#1-主题简介--topic-introduction)
  - [2. 类型等价 | Type Equivalence](#2-类型等价--type-equivalence)
  - [3. 类型同构 | Type Isomorphism](#3-类型同构--type-isomorphism)
  - [4. 类型族 | Type Families](#4-类型族--type-families)
  - [5. 代码示例 | Code Examples](#5-代码示例--code-examples)
  - [6. 相关性与本地跳转 | Relevance \& Local Navigation](#6-相关性与本地跳转--relevance--local-navigation)

---

## 1. 主题简介 | Topic Introduction

本主题介绍Lean中的类型等价、同构和类型族概念，这些是类型论中的核心概念，用于描述类型之间的关系。

This topic introduces the concepts of type equivalence, isomorphism, and type families in Lean, which are core concepts in type theory for describing relationships between types.

---

## 2. 类型等价 | Type Equivalence

- 类型等价描述两个类型在某种意义下的相等性。
- 通常通过双射函数来定义类型等价。

```lean
-- 类型等价定义
def TypeEquiv (α β : Type) := 
  Σ f : α → β, Σ g : β → α, 
  (∀ x, g (f x) = x) ∧ (∀ y, f (g y) = y)

-- 自然数与正整数的等价
def NatPosEquiv : TypeEquiv Nat (Σ n : Nat, n > 0) :=
  ⟨λ n => ⟨n + 1, Nat.succ_pos n⟩,
   λ p => p.1 - 1,
   λ n => by simp,
   λ p => by simp⟩
```

---

## 3. 类型同构 | Type Isomorphism

- 类型同构是类型等价的一种特殊形式。
- 两个类型同构意味着它们具有相同的结构。

```lean
-- 类型同构示例
def ListUnitIso (α : Type) : TypeEquiv (List α) (List Unit) :=
  ⟨λ xs => xs.map (λ _ => ()),
   λ xs => xs.map (λ _ => default),
   λ xs => by simp,
   λ xs => by simp⟩

-- 笛卡尔积的同构
def ProdIso (α β γ : Type) : 
  TypeEquiv (α × (β × γ)) ((α × β) × γ) :=
  ⟨λ p => ⟨⟨p.1, p.2.1⟩, p.2.2⟩,
   λ p => ⟨p.1.1, ⟨p.1.2, p.2⟩⟩,
   λ p => by cases p; simp,
   λ p => by cases p; cases p.1; simp⟩
```

---

## 4. 类型族 | Type Families

- 类型族是参数化的类型集合。
- 每个参数值对应一个具体的类型。

```lean
-- 类型族定义
def TypeFamily (I : Type) := I → Type

-- 向量类型族
def VectorFamily : TypeFamily Nat := λ n => Vector Nat n

-- 选项类型族
def OptionFamily (α : Type) : TypeFamily Bool :=
  λ b => if b then α else Unit

-- 使用类型族
def vector_example : VectorFamily 3 := ⟨[1,2,3], rfl⟩
def option_example : OptionFamily Nat true := 5
```

---

## 5. 代码示例 | Code Examples

```lean
-- 完整的类型等价证明
namespace TypeEquivalence

-- 单位类型与空类型的等价
def UnitEmptyEquiv : TypeEquiv Unit Empty :=
  ⟨λ u => match u with | () => nomatch,
   λ e => nomatch e,
   λ u => by cases u; simp,
   λ e => nomatch e⟩

-- 列表与树的可选表示
inductive Tree (α : Type)
  | leaf : Tree α
  | node : α → Tree α → Tree α → Tree α

def ListTreeEquiv (α : Type) : TypeEquiv (List α) (Tree α) :=
  ⟨λ xs => match xs with
    | [] => Tree.leaf
    | x :: xs => Tree.node x (ListTreeEquiv α).1 xs Tree.leaf,
   λ t => match t with
    | Tree.leaf => []
    | Tree.node x l r => x :: (ListTreeEquiv α).2.1 l,
   λ xs => by induction xs; simp,
   λ t => by induction t; simp⟩

end TypeEquivalence
```

---

## 6. 相关性与本地跳转 | Relevance & Local Navigation

- [返回上级目录](../01-总览.md)
- [类型论深入总览](01-总览.md)
- [类型系统基础](02-类型系统基础.md)
- [依赖类型与归纳类型](03-依赖类型与归纳类型.md)
- [Lean语法详解](../02-Lean语法详解/01-总览.md)

---

*最后更新时间：2025年1月*
*版本：1.0*
*状态：已完成*
