# 02-纯函数与副作用 | Pure Functions & Side Effects

## 目录

- [02-纯函数与副作用 | Pure Functions \& Side Effects](#02-纯函数与副作用--pure-functions--side-effects)
  - [目录](#目录)
  - [1. 主题简介 | Topic Introduction](#1-主题简介--topic-introduction)
  - [2. 纯函数概念 | Pure Function Concepts](#2-纯函数概念--pure-function-concepts)
  - [3. 引用透明性 | Referential Transparency](#3-引用透明性--referential-transparency)
  - [4. 副作用管理 | Side Effect Management](#4-副作用管理--side-effect-management)
  - [5. 代码示例 | Code Examples](#5-代码示例--code-examples)
  - [6. 相关性与本地跳转 | Relevance \& Local Navigation](#6-相关性与本地跳转--relevance--local-navigation)

---

## 1. 主题简介 | Topic Introduction

本主题介绍Lean中纯函数的概念、引用透明性以及副作用管理，这些是函数式编程的核心原则。

This topic introduces the concepts of pure functions, referential transparency, and side effect management in Lean, which are core principles of functional programming.

---

## 2. 纯函数概念 | Pure Function Concepts

- 纯函数：给定相同输入总是产生相同输出，无副作用。
- 纯函数易于测试、推理和优化。

```lean
-- 纯函数示例
def pure_add (a b : Nat) : Nat := a + b
def pure_square (x : Nat) : Nat := x * x
def pure_factorial : Nat → Nat
  | 0 => 1
  | n + 1 => (n + 1) * pure_factorial n

-- 非纯函数（在Lean中通常避免）
-- def impure_function : Nat → IO Nat := λ n => IO.println "side effect" >> return n
```

---

## 3. 引用透明性 | Referential Transparency

- 引用透明性：表达式可以替换为其值而不改变程序行为。
- 这是函数式编程的重要特性。

```lean
-- 引用透明性示例
def ref_transparent_example : Nat :=
  let x := pure_add 2 3
  let y := pure_add 2 3  -- 可以替换为 5
  x + y

-- 等价于
def ref_transparent_equivalent : Nat :=
  let x := 5
  let y := 5
  x + y
```

---

## 4. 副作用管理 | Side Effect Management

- Lean通过类型系统管理副作用。
- IO类型用于表示有副作用的计算。

```lean
-- 副作用管理示例
def side_effect_example : IO Unit := do
  IO.println "Hello, World!"
  let input ← IO.getLine
  IO.println s!"You entered: {input}"

-- 纯函数与IO分离
def pure_calculation (x : Nat) : Nat := x * x + 1
def io_wrapper : IO Unit := do
  let result := pure_calculation 5
  IO.println s!"Result: {result}"
```

---

## 5. 代码示例 | Code Examples

```lean
-- 纯函数库示例
namespace PureFunctions

-- 数学运算纯函数
def math_operations : Nat → Nat → Nat := λ x y =>
  let sum := x + y
  let product := x * y
  let difference := x - y
  sum + product + difference

-- 列表处理纯函数
def list_operations {α : Type} : List α → List α → List α := λ xs ys =>
  let reversed := xs.reverse
  let concatenated := reversed ++ ys
  concatenated.reverse

-- 高阶纯函数
def apply_twice {α : Type} (f : α → α) (x : α) : α := f (f x)
def compose {α β γ : Type} (f : β → γ) (g : α → β) : α → γ := λ x => f (g x)

-- 测试纯函数
def test_pure_functions : Nat :=
  let double := λ x => x * 2
  let add_one := λ x => x + 1
  let combined := compose add_one double
  apply_twice combined 3

end PureFunctions
```

---

## 6. 相关性与本地跳转 | Relevance & Local Navigation

- [返回上级目录](../01-总览.md)
- [函数式编程实践总览](01-总览.md)
- [Lean语法详解](../02-Lean语法详解/01-总览.md)
- [类型论深入](../03-类型论深入/01-总览.md)

---

*最后更新时间：2025年1月*
*版本：1.0*
*状态：已完成*
