# 关键字详解 | Keywords Detailed Explanation

## 概述 | Overview

Lean语言包含多种关键字，用于定义不同的语言构造。理解这些关键字是掌握Lean语法的关键。

The Lean language contains various keywords used to define different language constructs. Understanding these keywords is key to mastering Lean syntax.

## 声明关键字 | Declaration Keywords

### 1. 变量声明 | Variable Declaration

```lean
-- variable: 声明变量 | Declare variables
variable (x : Nat)
variable (y : String)
variable (z : List Nat)

-- 多个变量声明 | Multiple variable declarations
variable (a b c : Nat)
variable (f : Nat → Nat)
```

### 2. 定义关键字 | Definition Keywords

```lean
-- def: 定义函数或值 | Define functions or values
def add (x y : Nat) : Nat := x + y
def constant : Nat := 42

-- theorem: 定义定理 | Define theorems
theorem add_comm (a b : Nat) : a + b = b + a := by
  sorry

-- lemma: 定义引理 | Define lemmas
lemma add_zero (a : Nat) : a + 0 = a := by
  sorry
```

### 3. 类型定义 | Type Definitions

```lean
-- inductive: 定义归纳类型 | Define inductive types
inductive Nat where
  | zero : Nat
  | succ (n : Nat) : Nat

-- structure: 定义结构体 | Define structures
structure Point where
  x : Float
  y : Float
  deriving Repr

-- class: 定义类型类 | Define type classes
class Add (α : Type) where
  add : α → α → α
```

## 控制流关键字 | Control Flow Keywords

### 1. 条件语句 | Conditional Statements

```lean
-- if-then-else | if-then-else
def max (a b : Nat) : Nat :=
  if a > b then a else b

-- 嵌套条件 | Nested conditions
def sign (x : Int) : Int :=
  if x > 0 then 1
  else if x < 0 then -1
  else 0
```

### 2. 模式匹配 | Pattern Matching

```lean
-- match-with | match-with
def factorial (n : Nat) : Nat :=
  match n with
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

-- 复杂模式匹配 | Complex pattern matching
def listLength (xs : List α) : Nat :=
  match xs with
  | [] => 0
  | _ :: tail => 1 + listLength tail
```

### 3. 循环构造 | Loop Constructs

```lean
-- for循环 | for loops
def sumRange (n : Nat) : Nat :=
  let mut sum := 0
  for i in [0:n] do
    sum := sum + i
  sum

-- while循环 | while loops
def countdown (n : Nat) : List Nat :=
  let mut result := []
  let mut i := n
  while i > 0 do
    result := i :: result
    i := i - 1
  result
```

## 作用域关键字 | Scope Keywords

### 1. 命名空间 | Namespaces

```lean
-- namespace-end | namespace-end
namespace Math
  def add (x y : Nat) : Nat := x + y
  def multiply (x y : Nat) : Nat := x * y
end Math

-- 访问命名空间内容 | Access namespace contents
#check Math.add
#check Math.multiply
```

### 2. 节 | Sections

```lean
-- section-end | section-end
section MySection
  variable (α : Type)
  variable (f : α → α)
  
  def applyTwice (x : α) : α := f (f x)
end MySection
```

### 3. 模块系统 | Module System

```lean
-- import: 导入模块 | Import modules
import Mathlib.Data.Nat.Basic
import Mathlib.Data.List.Basic

-- export: 导出定义 | Export definitions
export MyModule (myFunction, myType)
```

## 证明关键字 | Proof Keywords

### 1. 证明策略 | Proof Tactics

```lean
-- by: 开始证明 | Start proof
theorem add_zero (a : Nat) : a + 0 = a := by
  rfl

-- sorry: 占位证明 | Placeholder proof
theorem complex_theorem : True := by
  sorry
```

### 2. 证明构造 | Proof Construction

```lean
-- have: 中间结果 | Intermediate results
theorem example_proof (a b : Nat) : a + b = b + a := by
  have h : a + b = b + a := add_comm a b
  exact h

-- let: 局部定义 | Local definitions
theorem let_example (a b : Nat) : (a + b) * 2 = 2 * a + 2 * b := by
  let c := a + b
  rw [mul_add, add_mul]
  rfl
```

## 高级关键字 | Advanced Keywords

### 1. 宏系统 | Macro System

```lean
-- macro: 定义宏 | Define macros
macro "my_macro" x:term : term => `(x + 1)

-- 使用宏 | Use macro
#eval my_macro 5  -- 结果: 6
```

### 2. 属性 | Attributes

```lean
-- @[attribute]: 添加属性 | Add attributes
@[simp] theorem add_zero (a : Nat) : a + 0 = a := by
  rfl

@[inline] def fastAdd (x y : Nat) : Nat := x + y
```

### 3. 实例 | Instances

```lean
-- instance: 定义类型类实例 | Define type class instances
instance : Add Nat where
  add := Nat.add

instance [Add α] : Add (List α) where
  add := List.zipWith (· + ·)
```

## 关键字优先级 | Keyword Precedence

```lean
-- 关键字优先级示例 | Keyword precedence examples
-- 1. 最高优先级: 类型声明
variable (x : Nat)

-- 2. 定义优先级
def f (x : Nat) : Nat := x

-- 3. 控制流优先级
if x > 0 then f x else 0

-- 4. 表达式优先级
x + y * z  -- 等同于 x + (y * z)
```

## 最佳实践 | Best Practices

### 1. 关键字使用 | Keyword Usage

```lean
-- 优先使用def而非variable | Prefer def over variable
def myConstant : Nat := 42  -- 推荐
variable (myConstant : Nat) -- 避免

-- 使用适当的证明关键字 | Use appropriate proof keywords
theorem simple : True := trivial  -- 简单证明
theorem complex : ∀ n : Nat, n + 0 = n := by  -- 复杂证明
  intro n
  rfl
```

### 2. 作用域管理 | Scope Management

```lean
-- 合理使用命名空间 | Use namespaces appropriately
namespace Data
  structure User where
    name : String
    age : Nat
end Data

-- 避免全局污染 | Avoid global pollution
-- 使用section限制作用域 | Use sections to limit scope
section LocalScope
  variable (x : Nat)
  def localFunction : Nat := x + 1
end LocalScope
```

## 相关链接 | Related Links

- [01-标识符规则](./01-标识符规则.md)
- [02-运算符与注释](../02-运算符与注释/README.md)
- [类型系统基础](../../02-类型系统基础/README.md)

## 练习 | Exercises

1. 使用不同关键字定义函数和类型
2. 创建包含多种控制流结构的程序
3. 设计合理的命名空间结构

---

*最后更新：2025年1月*
*版本：1.0*
