# å…³é”®å­—è¯¦è§£ | Keywords Detailed Explanation

## ğŸ“‹ ç›®å½• | Table of Contents

- [å…³é”®å­—è¯¦è§£ | Keywords Detailed Explanation](#å…³é”®å­—è¯¦è§£--keywords-detailed-explanation)
  - [ğŸ“‹ ç›®å½• | Table of Contents](#-ç›®å½•--table-of-contents)
  - [æ¦‚è¿° | Overview](#æ¦‚è¿°--overview)
  - [å£°æ˜å…³é”®å­— | Declaration Keywords](#å£°æ˜å…³é”®å­—--declaration-keywords)
    - [1. å˜é‡å£°æ˜ | Variable Declaration](#1-å˜é‡å£°æ˜--variable-declaration)
    - [2. å®šä¹‰å…³é”®å­— | Definition Keywords](#2-å®šä¹‰å…³é”®å­—--definition-keywords)
    - [3. ç±»å‹å®šä¹‰ | Type Definitions](#3-ç±»å‹å®šä¹‰--type-definitions)
  - [æ§åˆ¶æµå…³é”®å­— | Control Flow Keywords](#æ§åˆ¶æµå…³é”®å­—--control-flow-keywords)
    - [1. æ¡ä»¶è¯­å¥ | Conditional Statements](#1-æ¡ä»¶è¯­å¥--conditional-statements)
    - [2. æ¨¡å¼åŒ¹é… | Pattern Matching](#2-æ¨¡å¼åŒ¹é…--pattern-matching)
    - [3. å¾ªç¯æ„é€  | Loop Constructs](#3-å¾ªç¯æ„é€ --loop-constructs)
  - [ä½œç”¨åŸŸå…³é”®å­— | Scope Keywords](#ä½œç”¨åŸŸå…³é”®å­—--scope-keywords)
    - [1. å‘½åç©ºé—´ | Namespaces](#1-å‘½åç©ºé—´--namespaces)
    - [2. èŠ‚ | Sections](#2-èŠ‚--sections)
    - [3. æ¨¡å—ç³»ç»Ÿ | Module System](#3-æ¨¡å—ç³»ç»Ÿ--module-system)
  - [è¯æ˜å…³é”®å­— | Proof Keywords](#è¯æ˜å…³é”®å­—--proof-keywords)
    - [1. è¯æ˜ç­–ç•¥ | Proof Tactics](#1-è¯æ˜ç­–ç•¥--proof-tactics)
    - [2. è¯æ˜æ„é€  | Proof Construction](#2-è¯æ˜æ„é€ --proof-construction)
  - [é«˜çº§å…³é”®å­— | Advanced Keywords](#é«˜çº§å…³é”®å­—--advanced-keywords)
    - [1. å®ç³»ç»Ÿ | Macro System](#1-å®ç³»ç»Ÿ--macro-system)
    - [2. å±æ€§ | Attributes](#2-å±æ€§--attributes)
    - [3. å®ä¾‹ | Instances](#3-å®ä¾‹--instances)
  - [å…³é”®å­—ä¼˜å…ˆçº§ | Keyword Precedence](#å…³é”®å­—ä¼˜å…ˆçº§--keyword-precedence)
  - [æœ€ä½³å®è·µ | Best Practices](#æœ€ä½³å®è·µ--best-practices)
    - [1. å…³é”®å­—ä½¿ç”¨ | Keyword Usage](#1-å…³é”®å­—ä½¿ç”¨--keyword-usage)
    - [2. ä½œç”¨åŸŸç®¡ç† | Scope Management](#2-ä½œç”¨åŸŸç®¡ç†--scope-management)
  - [ç›¸å…³é“¾æ¥ | Related Links](#ç›¸å…³é“¾æ¥--related-links)
  - [ç»ƒä¹  | Exercises](#ç»ƒä¹ --exercises)

## æ¦‚è¿° | Overview

Leanè¯­è¨€åŒ…å«å¤šç§å…³é”®å­—ï¼Œç”¨äºå®šä¹‰ä¸åŒçš„è¯­è¨€æ„é€ ã€‚ç†è§£è¿™äº›å…³é”®å­—æ˜¯æŒæ¡Leanè¯­æ³•çš„å…³é”®ã€‚

The Lean language contains various keywords used to define different language constructs. Understanding these keywords is key to mastering Lean syntax.

## å£°æ˜å…³é”®å­— | Declaration Keywords

### 1. å˜é‡å£°æ˜ | Variable Declaration

```lean
-- variable: å£°æ˜å˜é‡ | Declare variables
variable (x : Nat)
variable (y : String)
variable (z : List Nat)

-- å¤šä¸ªå˜é‡å£°æ˜ | Multiple variable declarations
variable (a b c : Nat)
variable (f : Nat â†’ Nat)
```

### 2. å®šä¹‰å…³é”®å­— | Definition Keywords

```lean
-- def: å®šä¹‰å‡½æ•°æˆ–å€¼ | Define functions or values
def add (x y : Nat) : Nat := x + y
def constant : Nat := 42

-- theorem: å®šä¹‰å®šç† | Define theorems
theorem add_comm (a b : Nat) : a + b = b + a := by
  sorry

-- lemma: å®šä¹‰å¼•ç† | Define lemmas
lemma add_zero (a : Nat) : a + 0 = a := by
  sorry
```

### 3. ç±»å‹å®šä¹‰ | Type Definitions

```lean
-- inductive: å®šä¹‰å½’çº³ç±»å‹ | Define inductive types
inductive Nat where
  | zero : Nat
  | succ (n : Nat) : Nat

-- structure: å®šä¹‰ç»“æ„ä½“ | Define structures
structure Point where
  x : Float
  y : Float
  deriving Repr

-- class: å®šä¹‰ç±»å‹ç±» | Define type classes
class Add (Î± : Type) where
  add : Î± â†’ Î± â†’ Î±
```

## æ§åˆ¶æµå…³é”®å­— | Control Flow Keywords

### 1. æ¡ä»¶è¯­å¥ | Conditional Statements

```lean
-- if-then-else | if-then-else
def max (a b : Nat) : Nat :=
  if a > b then a else b

-- åµŒå¥—æ¡ä»¶ | Nested conditions
def sign (x : Int) : Int :=
  if x > 0 then 1
  else if x < 0 then -1
  else 0
```

### 2. æ¨¡å¼åŒ¹é… | Pattern Matching

```lean
-- match-with | match-with
def factorial (n : Nat) : Nat :=
  match n with
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

-- å¤æ‚æ¨¡å¼åŒ¹é… | Complex pattern matching
def listLength (xs : List Î±) : Nat :=
  match xs with
  | [] => 0
  | _ :: tail => 1 + listLength tail
```

### 3. å¾ªç¯æ„é€  | Loop Constructs

```lean
-- forå¾ªç¯ | for loops
def sumRange (n : Nat) : Nat :=
  let mut sum := 0
  for i in [0:n] do
    sum := sum + i
  sum

-- whileå¾ªç¯ | while loops
def countdown (n : Nat) : List Nat :=
  let mut result := []
  let mut i := n
  while i > 0 do
    result := i :: result
    i := i - 1
  result
```

## ä½œç”¨åŸŸå…³é”®å­— | Scope Keywords

### 1. å‘½åç©ºé—´ | Namespaces

```lean
-- namespace-end | namespace-end
namespace Math
  def add (x y : Nat) : Nat := x + y
  def multiply (x y : Nat) : Nat := x * y
end Math

-- è®¿é—®å‘½åç©ºé—´å†…å®¹ | Access namespace contents
#check Math.add
#check Math.multiply
```

### 2. èŠ‚ | Sections

```lean
-- section-end | section-end
section MySection
  variable (Î± : Type)
  variable (f : Î± â†’ Î±)
  
  def applyTwice (x : Î±) : Î± := f (f x)
end MySection
```

### 3. æ¨¡å—ç³»ç»Ÿ | Module System

```lean
-- import: å¯¼å…¥æ¨¡å— | Import modules
import Mathlib.Data.Nat.Basic
import Mathlib.Data.List.Basic

-- export: å¯¼å‡ºå®šä¹‰ | Export definitions
export MyModule (myFunction, myType)
```

## è¯æ˜å…³é”®å­— | Proof Keywords

### 1. è¯æ˜ç­–ç•¥ | Proof Tactics

```lean
-- by: å¼€å§‹è¯æ˜ | Start proof
theorem add_zero (a : Nat) : a + 0 = a := by
  rfl

-- sorry: å ä½è¯æ˜ | Placeholder proof
theorem complex_theorem : True := by
  sorry
```

### 2. è¯æ˜æ„é€  | Proof Construction

```lean
-- have: ä¸­é—´ç»“æœ | Intermediate results
theorem example_proof (a b : Nat) : a + b = b + a := by
  have h : a + b = b + a := add_comm a b
  exact h

-- let: å±€éƒ¨å®šä¹‰ | Local definitions
theorem let_example (a b : Nat) : (a + b) * 2 = 2 * a + 2 * b := by
  let c := a + b
  rw [mul_add, add_mul]
  rfl
```

## é«˜çº§å…³é”®å­— | Advanced Keywords

### 1. å®ç³»ç»Ÿ | Macro System

```lean
-- macro: å®šä¹‰å® | Define macros
macro "my_macro" x:term : term => `(x + 1)

-- ä½¿ç”¨å® | Use macro
#eval my_macro 5  -- ç»“æœ: 6
```

### 2. å±æ€§ | Attributes

```lean
-- @[attribute]: æ·»åŠ å±æ€§ | Add attributes
@[simp] theorem add_zero (a : Nat) : a + 0 = a := by
  rfl

@[inline] def fastAdd (x y : Nat) : Nat := x + y
```

### 3. å®ä¾‹ | Instances

```lean
-- instance: å®šä¹‰ç±»å‹ç±»å®ä¾‹ | Define type class instances
instance : Add Nat where
  add := Nat.add

instance [Add Î±] : Add (List Î±) where
  add := List.zipWith (Â· + Â·)
```

## å…³é”®å­—ä¼˜å…ˆçº§ | Keyword Precedence

```lean
-- å…³é”®å­—ä¼˜å…ˆçº§ç¤ºä¾‹ | Keyword precedence examples
-- 1. æœ€é«˜ä¼˜å…ˆçº§: ç±»å‹å£°æ˜
variable (x : Nat)

-- 2. å®šä¹‰ä¼˜å…ˆçº§
def f (x : Nat) : Nat := x

-- 3. æ§åˆ¶æµä¼˜å…ˆçº§
if x > 0 then f x else 0

-- 4. è¡¨è¾¾å¼ä¼˜å…ˆçº§
x + y * z  -- ç­‰åŒäº x + (y * z)
```

## æœ€ä½³å®è·µ | Best Practices

### 1. å…³é”®å­—ä½¿ç”¨ | Keyword Usage

```lean
-- ä¼˜å…ˆä½¿ç”¨defè€Œévariable | Prefer def over variable
def myConstant : Nat := 42  -- æ¨è
variable (myConstant : Nat) -- é¿å…

-- ä½¿ç”¨é€‚å½“çš„è¯æ˜å…³é”®å­— | Use appropriate proof keywords
theorem simple : True := trivial  -- ç®€å•è¯æ˜
theorem complex : âˆ€ n : Nat, n + 0 = n := by  -- å¤æ‚è¯æ˜
  intro n
  rfl
```

### 2. ä½œç”¨åŸŸç®¡ç† | Scope Management

```lean
-- åˆç†ä½¿ç”¨å‘½åç©ºé—´ | Use namespaces appropriately
namespace Data
  structure User where
    name : String
    age : Nat
end Data

-- é¿å…å…¨å±€æ±¡æŸ“ | Avoid global pollution
-- ä½¿ç”¨sectioné™åˆ¶ä½œç”¨åŸŸ | Use sections to limit scope
section LocalScope
  variable (x : Nat)
  def localFunction : Nat := x + 1
end LocalScope
```

## ç›¸å…³é“¾æ¥ | Related Links

- [01-æ ‡è¯†ç¬¦è§„åˆ™](./01-æ ‡è¯†ç¬¦è§„åˆ™.md)
- [02-è¿ç®—ç¬¦ä¸æ³¨é‡Š](../02-è¿ç®—ç¬¦ä¸æ³¨é‡Š/README.md)
- [ç±»å‹ç³»ç»ŸåŸºç¡€](../../02-ç±»å‹ç³»ç»ŸåŸºç¡€/README.md)

## ç»ƒä¹  | Exercises

1. ä½¿ç”¨ä¸åŒå…³é”®å­—å®šä¹‰å‡½æ•°å’Œç±»å‹
2. åˆ›å»ºåŒ…å«å¤šç§æ§åˆ¶æµç»“æ„çš„ç¨‹åº
3. è®¾è®¡åˆç†çš„å‘½åç©ºé—´ç»“æ„

---

*æœ€åæ›´æ–°ï¼š2025å¹´1æœˆ*
*ç‰ˆæœ¬ï¼š1.0*
