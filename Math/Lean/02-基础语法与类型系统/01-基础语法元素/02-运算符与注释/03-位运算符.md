# ä½è¿ç®—ç¬¦ | Bitwise Operators

## ğŸ“‹ ç›®å½• | Table of Contents

- [ä½è¿ç®—ç¬¦ | Bitwise Operators](#ä½è¿ç®—ç¬¦--bitwise-operators)
  - [ğŸ“‹ ç›®å½• | Table of Contents](#-ç›®å½•--table-of-contents)
  - [1. æ¦‚è¿° | Overview](#1-æ¦‚è¿°--overview)
  - [2. åŸºæœ¬ä½è¿ç®—ç¬¦ | Basic Bitwise Operators](#2-åŸºæœ¬ä½è¿ç®—ç¬¦--basic-bitwise-operators)
    - [æŒ‰ä½ä¸ (AND) | Bitwise AND](#æŒ‰ä½ä¸-and--bitwise-and)
    - [æŒ‰ä½æˆ– (OR) | Bitwise OR](#æŒ‰ä½æˆ–-or--bitwise-or)
    - [æŒ‰ä½å¼‚æˆ– (XOR) | Bitwise XOR](#æŒ‰ä½å¼‚æˆ–-xor--bitwise-xor)
    - [æŒ‰ä½å–å (NOT) | Bitwise NOT](#æŒ‰ä½å–å-not--bitwise-not)
  - [3. ä½ç§»è¿ç®—ç¬¦ | Bit Shift Operators](#3-ä½ç§»è¿ç®—ç¬¦--bit-shift-operators)
    - [å·¦ç§»è¿ç®—ç¬¦ | Left Shift Operator](#å·¦ç§»è¿ç®—ç¬¦--left-shift-operator)
    - [å³ç§»è¿ç®—ç¬¦ | Right Shift Operator](#å³ç§»è¿ç®—ç¬¦--right-shift-operator)
  - [4. ä½æ“ä½œå®ç”¨å‡½æ•° | Bit Manipulation Utility Functions](#4-ä½æ“ä½œå®ç”¨å‡½æ•°--bit-manipulation-utility-functions)
    - [ä½è®¡æ•°å‡½æ•° | Bit Counting Functions](#ä½è®¡æ•°å‡½æ•°--bit-counting-functions)
    - [ä½ä½ç½®å‡½æ•° | Bit Position Functions](#ä½ä½ç½®å‡½æ•°--bit-position-functions)
  - [5. ä½æ©ç æ“ä½œ | Bit Mask Operations](#5-ä½æ©ç æ“ä½œ--bit-mask-operations)
    - [åŸºæœ¬ä½æ©ç  | Basic Bit Masks](#åŸºæœ¬ä½æ©ç --basic-bit-masks)
    - [ä½å­—æ®µæ“ä½œ | Bit Field Operations](#ä½å­—æ®µæ“ä½œ--bit-field-operations)
  - [6. ä½æ“ä½œç®—æ³• | Bit Manipulation Algorithms](#6-ä½æ“ä½œç®—æ³•--bit-manipulation-algorithms)
    - [å¿«é€Ÿå¹‚ç®—æ³• | Fast Exponentiation](#å¿«é€Ÿå¹‚ç®—æ³•--fast-exponentiation)
    - [æ±‰æ˜è·ç¦» | Hamming Distance](#æ±‰æ˜è·ç¦»--hamming-distance)
  - [7. ä½æ“ä½œä¼˜åŒ–æŠ€å·§ | Bit Manipulation Optimization Tips](#7-ä½æ“ä½œä¼˜åŒ–æŠ€å·§--bit-manipulation-optimization-tips)
    - [å¸¸ç”¨ä½æ“ä½œæŠ€å·§ | Common Bit Manipulation Tricks](#å¸¸ç”¨ä½æ“ä½œæŠ€å·§--common-bit-manipulation-tricks)
    - [ä½æ“ä½œå¸¸é‡ | Bit Manipulation Constants](#ä½æ“ä½œå¸¸é‡--bit-manipulation-constants)
  - [8. å®é™…åº”ç”¨ç¤ºä¾‹ | Practical Application Examples](#8-å®é™…åº”ç”¨ç¤ºä¾‹--practical-application-examples)
    - [ä½é›†åˆ | Bit Sets](#ä½é›†åˆ--bit-sets)
    - [ä½æ ‡å¿— | Bit Flags](#ä½æ ‡å¿—--bit-flags)
  - [9. æœ€ä½³å®è·µ | Best Practices](#9-æœ€ä½³å®è·µ--best-practices)
    - [æ€§èƒ½è€ƒè™‘ | Performance Considerations](#æ€§èƒ½è€ƒè™‘--performance-considerations)
    - [å¯è¯»æ€§ | Readability](#å¯è¯»æ€§--readability)
  - [ç»ƒä¹  | Exercises](#ç»ƒä¹ --exercises)

## 1. æ¦‚è¿° | Overview

ä½è¿ç®—ç¬¦æ˜¯ç”¨äºå¯¹æ•´æ•°è¿›è¡Œä½çº§æ“ä½œçš„è¿ç®—ç¬¦ã€‚åœ¨Leanä¸­ï¼Œä½è¿ç®—ç¬¦ä¸»è¦ç”¨äºè‡ªç„¶æ•°å’Œæ•´æ•°çš„äºŒè¿›åˆ¶ä½æ“ä½œï¼Œæ˜¯åº•å±‚ç¼–ç¨‹å’Œä¼˜åŒ–çš„é‡è¦å·¥å…·ã€‚

Bitwise operators are used for bit-level operations on integers. In Lean, bitwise operators are primarily used for binary bit operations on natural numbers and integers, serving as important tools for low-level programming and optimization.

## 2. åŸºæœ¬ä½è¿ç®—ç¬¦ | Basic Bitwise Operators

### æŒ‰ä½ä¸ (AND) | Bitwise AND

```lean
-- æŒ‰ä½ä¸æ“ä½œ
#eval 5 &&& 3  -- ç»“æœ: 1
-- äºŒè¿›åˆ¶: 101 &&& 011 = 001

-- å‡½æ•°ä¸­çš„æŒ‰ä½ä¸
def bitwise_and (x y : Nat) : Nat := x &&& y
#eval bitwise_and 12 10  -- ç»“æœ: 8
-- äºŒè¿›åˆ¶: 1100 &&& 1010 = 1000

-- æ£€æŸ¥ç‰¹å®šä½
def is_bit_set (n : Nat) (pos : Nat) : Bool :=
  (n &&& (1 <<< pos)) â‰  0
#eval is_bit_set 5 0  -- true (æœ€ä½ä½ä¸º1)
#eval is_bit_set 5 1  -- false (ç¬¬äºŒä½ä¸º0)
```

### æŒ‰ä½æˆ– (OR) | Bitwise OR

```lean
-- æŒ‰ä½æˆ–æ“ä½œ
#eval 5 ||| 3  -- ç»“æœ: 7
-- äºŒè¿›åˆ¶: 101 ||| 011 = 111

-- å‡½æ•°ä¸­çš„æŒ‰ä½æˆ–
def bitwise_or (x y : Nat) : Nat := x ||| y
#eval bitwise_or 8 4  -- ç»“æœ: 12
-- äºŒè¿›åˆ¶: 1000 ||| 0100 = 1100

-- è®¾ç½®ç‰¹å®šä½
def set_bit (n : Nat) (pos : Nat) : Nat :=
  n ||| (1 <<< pos)
#eval set_bit 0 2  -- ç»“æœ: 4 (è®¾ç½®ç¬¬2ä½)
#eval set_bit 5 1  -- ç»“æœ: 7 (è®¾ç½®ç¬¬1ä½)
```

### æŒ‰ä½å¼‚æˆ– (XOR) | Bitwise XOR

```lean
-- æŒ‰ä½å¼‚æˆ–æ“ä½œ
#eval 5 ^^^ 3  -- ç»“æœ: 6
-- äºŒè¿›åˆ¶: 101 ^^^ 011 = 110

-- å‡½æ•°ä¸­çš„æŒ‰ä½å¼‚æˆ–
def bitwise_xor (x y : Nat) : Nat := x ^^^ y
#eval bitwise_xor 12 10  -- ç»“æœ: 6
-- äºŒè¿›åˆ¶: 1100 ^^^ 1010 = 0110

-- åˆ‡æ¢ç‰¹å®šä½
def toggle_bit (n : Nat) (pos : Nat) : Nat :=
  n ^^^ (1 <<< pos)
#eval toggle_bit 5 0  -- ç»“æœ: 4 (åˆ‡æ¢æœ€ä½ä½)
#eval toggle_bit 5 1  -- ç»“æœ: 7 (åˆ‡æ¢ç¬¬äºŒä½)
```

### æŒ‰ä½å–å (NOT) | Bitwise NOT

```lean
-- æŒ‰ä½å–åæ“ä½œ
#eval ~~~5  -- ç»“æœ: å¾ˆå¤§çš„æ•°ï¼ˆæ‰€æœ‰ä½å–åï¼‰

-- å‡½æ•°ä¸­çš„æŒ‰ä½å–å
def bitwise_not (x : Nat) : Nat := ~~~x
#eval bitwise_not 0  -- ç»“æœ: å¾ˆå¤§çš„æ•°

-- æ¸…é™¤ç‰¹å®šä½
def clear_bit (n : Nat) (pos : Nat) : Nat :=
  n &&& ~~~(1 <<< pos)
#eval clear_bit 7 1  -- ç»“æœ: 5 (æ¸…é™¤ç¬¬1ä½)
-- äºŒè¿›åˆ¶: 111 &&& 101 = 101
```

## 3. ä½ç§»è¿ç®—ç¬¦ | Bit Shift Operators

### å·¦ç§»è¿ç®—ç¬¦ | Left Shift Operator

```lean
-- å·¦ç§»æ“ä½œ
#eval 5 <<< 2  -- ç»“æœ: 20
-- äºŒè¿›åˆ¶: 101 <<< 2 = 10100

-- å‡½æ•°ä¸­çš„å·¦ç§»
def left_shift (x : Nat) (n : Nat) : Nat := x <<< n
#eval left_shift 3 3  -- ç»“æœ: 24
-- äºŒè¿›åˆ¶: 11 <<< 3 = 11000

-- ä¹˜ä»¥2çš„å¹‚
def multiply_by_power_of_two (x : Nat) (n : Nat) : Nat :=
  x <<< n
#eval multiply_by_power_of_two 7 2  -- ç»“æœ: 28 (7 * 4)
```

### å³ç§»è¿ç®—ç¬¦ | Right Shift Operator

```lean
-- å³ç§»æ“ä½œ
#eval 20 >>> 2  -- ç»“æœ: 5
-- äºŒè¿›åˆ¶: 10100 >>> 2 = 101

-- å‡½æ•°ä¸­çš„å³ç§»
def right_shift (x : Nat) (n : Nat) : Nat := x >>> n
#eval right_shift 24 3  -- ç»“æœ: 3
-- äºŒè¿›åˆ¶: 11000 >>> 3 = 11

-- é™¤ä»¥2çš„å¹‚
def divide_by_power_of_two (x : Nat) (n : Nat) : Nat :=
  x >>> n
#eval divide_by_power_of_two 28 2  -- ç»“æœ: 7 (28 / 4)
```

## 4. ä½æ“ä½œå®ç”¨å‡½æ•° | Bit Manipulation Utility Functions

### ä½è®¡æ•°å‡½æ•° | Bit Counting Functions

```lean
-- è®¡ç®—è®¾ç½®ä½çš„æ•°é‡
def count_set_bits (n : Nat) : Nat :=
  match n with
  | 0 => 0
  | n + 1 => count_set_bits n + (if n &&& 1 = 1 then 1 else 0)

-- ä½¿ç”¨å†…ç½®å‡½æ•°ï¼ˆå¦‚æœå¯ç”¨ï¼‰
def popcount (n : Nat) : Nat :=
  -- è¿™é‡Œå¯ä»¥ä½¿ç”¨æ›´é«˜æ•ˆçš„å®ç°
  count_set_bits n

#eval popcount 5  -- ç»“æœ: 2 (101æœ‰2ä¸ªè®¾ç½®ä½)
#eval popcount 7  -- ç»“æœ: 3 (111æœ‰3ä¸ªè®¾ç½®ä½)
```

### ä½ä½ç½®å‡½æ•° | Bit Position Functions

```lean
-- æ‰¾åˆ°æœ€é«˜è®¾ç½®ä½çš„ä½ç½®
def highest_set_bit (n : Nat) : Option Nat :=
  if n = 0 then none
  else
    let rec find (pos : Nat) (mask : Nat) : Nat :=
      if mask > n then pos - 1
      else find (pos + 1) (mask <<< 1)
    some (find 0 1)

#eval highest_set_bit 5  -- some 2 (æœ€é«˜ä½åœ¨ç¬¬2ä½)
#eval highest_set_bit 8  -- some 3 (æœ€é«˜ä½åœ¨ç¬¬3ä½)

-- æ‰¾åˆ°æœ€ä½è®¾ç½®ä½çš„ä½ç½®
def lowest_set_bit (n : Nat) : Option Nat :=
  if n = 0 then none
  else
    let rec find (pos : Nat) (mask : Nat) : Option Nat :=
      if mask > n then none
      else if n &&& mask â‰  0 then some pos
      else find (pos + 1) (mask <<< 1)
    find 0 1

#eval lowest_set_bit 6  -- some 1 (æœ€ä½è®¾ç½®ä½åœ¨ç¬¬1ä½)
#eval lowest_set_bit 8  -- some 3 (æœ€ä½è®¾ç½®ä½åœ¨ç¬¬3ä½)
```

## 5. ä½æ©ç æ“ä½œ | Bit Mask Operations

### åŸºæœ¬ä½æ©ç  | Basic Bit Masks

```lean
-- åˆ›å»ºä½æ©ç 
def create_mask (width : Nat) : Nat :=
  (1 <<< width) - 1

#eval create_mask 4  -- ç»“æœ: 15 (äºŒè¿›åˆ¶: 1111)

-- æå–ç‰¹å®šä½èŒƒå›´
def extract_bits (n : Nat) (start len : Nat) : Nat :=
  let mask := create_mask len
  (n >>> start) &&& mask

#eval extract_bits 0b11010110 2 4  -- ç»“æœ: 5 (æå–ç¬¬2-5ä½)
-- äºŒè¿›åˆ¶: 11010110 >>> 2 = 00110101, &&& 1111 = 0101
```

### ä½å­—æ®µæ“ä½œ | Bit Field Operations

```lean
-- è®¾ç½®ä½å­—æ®µ
def set_bit_field (n : Nat) (start len : Nat) (value : Nat) : Nat :=
  let mask := create_mask len
  let cleared := n &&& ~~~(mask <<< start)
  cleared ||| ((value &&& mask) <<< start)

#eval set_bit_field 0b11010110 2 4 3  -- ç»“æœ: 0b11001110
-- åœ¨ç¬¬2-5ä½è®¾ç½®å€¼3 (0011)

-- è·å–ä½å­—æ®µ
def get_bit_field (n : Nat) (start len : Nat) : Nat :=
  extract_bits n start len

#eval get_bit_field 0b11010110 2 4  -- ç»“æœ: 5
```

## 6. ä½æ“ä½œç®—æ³• | Bit Manipulation Algorithms

### å¿«é€Ÿå¹‚ç®—æ³• | Fast Exponentiation

```lean
-- ä½¿ç”¨ä½æ“ä½œçš„å¿«é€Ÿå¹‚
def fast_power (base : Nat) (exp : Nat) : Nat :=
  let rec aux (result : Nat) (base : Nat) (exp : Nat) : Nat :=
    if exp = 0 then result
    else if exp &&& 1 = 1 then
      aux (result * base) (base * base) (exp >>> 1)
    else
      aux result (base * base) (exp >>> 1)
  aux 1 base exp

#eval fast_power 2 10  -- ç»“æœ: 1024
#eval fast_power 3 5   -- ç»“æœ: 243
```

### æ±‰æ˜è·ç¦» | Hamming Distance

```lean
-- è®¡ç®—ä¸¤ä¸ªæ•°çš„æ±‰æ˜è·ç¦»ï¼ˆä¸åŒä½çš„æ•°é‡ï¼‰
def hamming_distance (x y : Nat) : Nat :=
  popcount (x ^^^ y)

#eval hamming_distance 5 3  -- ç»“æœ: 2 (101å’Œ011æœ‰2ä½ä¸åŒ)
#eval hamming_distance 7 0  -- ç»“æœ: 3 (111å’Œ000æœ‰3ä½ä¸åŒ)
```

## 7. ä½æ“ä½œä¼˜åŒ–æŠ€å·§ | Bit Manipulation Optimization Tips

### å¸¸ç”¨ä½æ“ä½œæŠ€å·§ | Common Bit Manipulation Tricks

```lean
-- æ£€æŸ¥æ˜¯å¦ä¸º2çš„å¹‚
def is_power_of_two (n : Nat) : Bool :=
  n â‰  0 && (n &&& (n - 1)) = 0

#eval is_power_of_two 8   -- true
#eval is_power_of_two 6   -- false
#eval is_power_of_two 0   -- false

-- è·å–æœ€ä½è®¾ç½®ä½
def get_lowest_set_bit (n : Nat) : Nat :=
  n &&& (-n : Int).toNat

-- æ¸…é™¤æœ€ä½è®¾ç½®ä½
def clear_lowest_set_bit (n : Nat) : Nat :=
  n &&& (n - 1)

#eval clear_lowest_set_bit 6  -- ç»“æœ: 4 (110 -> 100)
```

### ä½æ“ä½œå¸¸é‡ | Bit Manipulation Constants

```lean
-- å¸¸ç”¨ä½æ©ç 
def ALL_BITS_SET : Nat := ~~~0
def LOWER_HALF_MASK : Nat := 0xFFFFFFFF
def UPPER_HALF_MASK : Nat := 0xFFFFFFFF00000000

-- ä½ä½ç½®å¸¸é‡
def BIT_0 : Nat := 1
def BIT_1 : Nat := 2
def BIT_2 : Nat := 4
def BIT_3 : Nat := 8
def BIT_4 : Nat := 16
def BIT_5 : Nat := 32
def BIT_6 : Nat := 64
def BIT_7 : Nat := 128
```

## 8. å®é™…åº”ç”¨ç¤ºä¾‹ | Practical Application Examples

### ä½é›†åˆ | Bit Sets

```lean
-- ä½¿ç”¨è‡ªç„¶æ•°è¡¨ç¤ºä½é›†åˆ
def empty_set : Nat := 0
def add_element (set : Nat) (element : Nat) : Nat :=
  set ||| (1 <<< element)
def remove_element (set : Nat) (element : Nat) : Nat :=
  set &&& ~~~(1 <<< element)
def has_element (set : Nat) (element : Nat) : Bool :=
  (set &&& (1 <<< element)) â‰  0

-- ç¤ºä¾‹ä½¿ç”¨
def my_set := add_element (add_element empty_set 2) 5
#eval has_element my_set 2  -- true
#eval has_element my_set 3  -- false
```

### ä½æ ‡å¿— | Bit Flags

```lean
-- å®šä¹‰ä½æ ‡å¿—
def FLAG_READ : Nat := 1
def FLAG_WRITE : Nat := 2
def FLAG_EXECUTE : Nat := 4
def FLAG_HIDDEN : Nat := 8

-- ä½æ ‡å¿—æ“ä½œ
def set_flag (flags : Nat) (flag : Nat) : Nat :=
  flags ||| flag
def clear_flag (flags : Nat) (flag : Nat) : Nat :=
  flags &&& ~~~flag
def has_flag (flags : Nat) (flag : Nat) : Bool :=
  (flags &&& flag) â‰  0

-- ç¤ºä¾‹ä½¿ç”¨
def file_flags := set_flag (set_flag 0 FLAG_READ) FLAG_WRITE
#eval has_flag file_flags FLAG_READ   -- true
#eval has_flag file_flags FLAG_WRITE  -- true
#eval has_flag file_flags FLAG_EXECUTE -- false
```

## 9. æœ€ä½³å®è·µ | Best Practices

### æ€§èƒ½è€ƒè™‘ | Performance Considerations

```lean
-- ä½¿ç”¨ä½æ“ä½œæ›¿ä»£é™¤æ³•
def divide_by_2 (n : Nat) : Nat := n >>> 1
def multiply_by_2 (n : Nat) : Nat := n <<< 1

-- ä½¿ç”¨ä½æ“ä½œæ£€æŸ¥å¥‡å¶æ€§
def is_even (n : Nat) : Bool := (n &&& 1) = 0
def is_odd (n : Nat) : Bool := (n &&& 1) = 1

-- ä½¿ç”¨ä½æ“ä½œäº¤æ¢å˜é‡ï¼ˆXORæŠ€å·§ï¼‰
def swap_variables (a b : Nat) : Nat Ã— Nat :=
  let a' := a ^^^ b
  let b' := a' ^^^ b
  let a'' := a' ^^^ b'
  (a'', b')
```

### å¯è¯»æ€§ | Readability

```lean
-- ä½¿ç”¨æœ‰æ„ä¹‰çš„å¸¸é‡å
def BYTE_MASK : Nat := 0xFF
def WORD_MASK : Nat := 0xFFFF
def DWORD_MASK : Nat := 0xFFFFFFFF

-- ä½¿ç”¨æè¿°æ€§çš„å‡½æ•°å
def extract_byte (value : Nat) (byte_index : Nat) : Nat :=
  (value >>> (byte_index * 8)) &&& BYTE_MASK

-- æ·»åŠ æ³¨é‡Šè¯´æ˜ä½æ“ä½œçš„ç›®çš„
def pack_rgb (r g b : Nat) : Nat :=
  -- å°†RGBå€¼æ‰“åŒ…ä¸º32ä½æ•´æ•°: RRRRRRRR GGGGGGGG BBBBBBBB
  (r <<< 16) ||| (g <<< 8) ||| b
```

---

*ç›¸å…³é“¾æ¥ï¼š*

- [ç®—æœ¯è¿ç®—ç¬¦](./01-ç®—æœ¯è¿ç®—ç¬¦.md)
- [é€»è¾‘è¿ç®—ç¬¦](./02-é€»è¾‘è¿ç®—ç¬¦.md)
- [æ³¨é‡Šç³»ç»Ÿ](./04-æ³¨é‡Šç³»ç»Ÿ.md)
- [ç±»å‹ç³»ç»ŸåŸºç¡€](../../02-ç±»å‹ç³»ç»ŸåŸºç¡€.md)
- [æ ‡è¯†ç¬¦ä¸å…³é”®å­—](../01-æ ‡è¯†ç¬¦ä¸å…³é”®å­—/01-æ€»è§ˆ.md)
- [å­—é¢é‡ä¸å¸¸é‡](../03-å­—é¢é‡ä¸å¸¸é‡/01-æ€»è§ˆ.md)

## ç»ƒä¹  | Exercises

1. å®ç°ä½é›†åˆçš„å¹¶é›†ã€äº¤é›†å’Œå·®é›†æ“ä½œ
2. åˆ›å»ºä½æ ‡å¿—ç®¡ç†ç³»ç»Ÿ
3. å®ç°é«˜æ•ˆçš„ä½è®¡æ•°å’Œä½ä½ç½®æŸ¥æ‰¾ç®—æ³•
4. è®¾è®¡ä½æ“ä½œä¼˜åŒ–çš„æ•°å­¦å‡½æ•°

---

*æœ€åæ›´æ–°ï¼š2025å¹´1æœˆ*
*ç‰ˆæœ¬ï¼š1.0*
