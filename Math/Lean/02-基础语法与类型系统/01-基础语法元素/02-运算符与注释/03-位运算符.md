# 位运算符 | Bitwise Operators

## 📋 目录 | Table of Contents

- [位运算符 | Bitwise Operators](#位运算符--bitwise-operators)
  - [📋 目录 | Table of Contents](#-目录--table-of-contents)
  - [1. 概述 | Overview](#1-概述--overview)
  - [2. 基本位运算符 | Basic Bitwise Operators](#2-基本位运算符--basic-bitwise-operators)
    - [按位与 (AND) | Bitwise AND](#按位与-and--bitwise-and)
    - [按位或 (OR) | Bitwise OR](#按位或-or--bitwise-or)
    - [按位异或 (XOR) | Bitwise XOR](#按位异或-xor--bitwise-xor)
    - [按位取反 (NOT) | Bitwise NOT](#按位取反-not--bitwise-not)
  - [3. 位移运算符 | Bit Shift Operators](#3-位移运算符--bit-shift-operators)
    - [左移运算符 | Left Shift Operator](#左移运算符--left-shift-operator)
    - [右移运算符 | Right Shift Operator](#右移运算符--right-shift-operator)
  - [4. 位操作实用函数 | Bit Manipulation Utility Functions](#4-位操作实用函数--bit-manipulation-utility-functions)
    - [位计数函数 | Bit Counting Functions](#位计数函数--bit-counting-functions)
    - [位位置函数 | Bit Position Functions](#位位置函数--bit-position-functions)
  - [5. 位掩码操作 | Bit Mask Operations](#5-位掩码操作--bit-mask-operations)
    - [基本位掩码 | Basic Bit Masks](#基本位掩码--basic-bit-masks)
    - [位字段操作 | Bit Field Operations](#位字段操作--bit-field-operations)
  - [6. 位操作算法 | Bit Manipulation Algorithms](#6-位操作算法--bit-manipulation-algorithms)
    - [快速幂算法 | Fast Exponentiation](#快速幂算法--fast-exponentiation)
    - [汉明距离 | Hamming Distance](#汉明距离--hamming-distance)
  - [7. 位操作优化技巧 | Bit Manipulation Optimization Tips](#7-位操作优化技巧--bit-manipulation-optimization-tips)
    - [常用位操作技巧 | Common Bit Manipulation Tricks](#常用位操作技巧--common-bit-manipulation-tricks)
    - [位操作常量 | Bit Manipulation Constants](#位操作常量--bit-manipulation-constants)
  - [8. 实际应用示例 | Practical Application Examples](#8-实际应用示例--practical-application-examples)
    - [位集合 | Bit Sets](#位集合--bit-sets)
    - [位标志 | Bit Flags](#位标志--bit-flags)
  - [9. 最佳实践 | Best Practices](#9-最佳实践--best-practices)
    - [性能考虑 | Performance Considerations](#性能考虑--performance-considerations)
    - [可读性 | Readability](#可读性--readability)
  - [练习 | Exercises](#练习--exercises)

## 1. 概述 | Overview

位运算符是用于对整数进行位级操作的运算符。在Lean中，位运算符主要用于自然数和整数的二进制位操作，是底层编程和优化的重要工具。

Bitwise operators are used for bit-level operations on integers. In Lean, bitwise operators are primarily used for binary bit operations on natural numbers and integers, serving as important tools for low-level programming and optimization.

## 2. 基本位运算符 | Basic Bitwise Operators

### 按位与 (AND) | Bitwise AND

```lean
-- 按位与操作
#eval 5 &&& 3  -- 结果: 1
-- 二进制: 101 &&& 011 = 001

-- 函数中的按位与
def bitwise_and (x y : Nat) : Nat := x &&& y
#eval bitwise_and 12 10  -- 结果: 8
-- 二进制: 1100 &&& 1010 = 1000

-- 检查特定位
def is_bit_set (n : Nat) (pos : Nat) : Bool :=
  (n &&& (1 <<< pos)) ≠ 0
#eval is_bit_set 5 0  -- true (最低位为1)
#eval is_bit_set 5 1  -- false (第二位为0)
```

### 按位或 (OR) | Bitwise OR

```lean
-- 按位或操作
#eval 5 ||| 3  -- 结果: 7
-- 二进制: 101 ||| 011 = 111

-- 函数中的按位或
def bitwise_or (x y : Nat) : Nat := x ||| y
#eval bitwise_or 8 4  -- 结果: 12
-- 二进制: 1000 ||| 0100 = 1100

-- 设置特定位
def set_bit (n : Nat) (pos : Nat) : Nat :=
  n ||| (1 <<< pos)
#eval set_bit 0 2  -- 结果: 4 (设置第2位)
#eval set_bit 5 1  -- 结果: 7 (设置第1位)
```

### 按位异或 (XOR) | Bitwise XOR

```lean
-- 按位异或操作
#eval 5 ^^^ 3  -- 结果: 6
-- 二进制: 101 ^^^ 011 = 110

-- 函数中的按位异或
def bitwise_xor (x y : Nat) : Nat := x ^^^ y
#eval bitwise_xor 12 10  -- 结果: 6
-- 二进制: 1100 ^^^ 1010 = 0110

-- 切换特定位
def toggle_bit (n : Nat) (pos : Nat) : Nat :=
  n ^^^ (1 <<< pos)
#eval toggle_bit 5 0  -- 结果: 4 (切换最低位)
#eval toggle_bit 5 1  -- 结果: 7 (切换第二位)
```

### 按位取反 (NOT) | Bitwise NOT

```lean
-- 按位取反操作
#eval ~~~5  -- 结果: 很大的数（所有位取反）

-- 函数中的按位取反
def bitwise_not (x : Nat) : Nat := ~~~x
#eval bitwise_not 0  -- 结果: 很大的数

-- 清除特定位
def clear_bit (n : Nat) (pos : Nat) : Nat :=
  n &&& ~~~(1 <<< pos)
#eval clear_bit 7 1  -- 结果: 5 (清除第1位)
-- 二进制: 111 &&& 101 = 101
```

## 3. 位移运算符 | Bit Shift Operators

### 左移运算符 | Left Shift Operator

```lean
-- 左移操作
#eval 5 <<< 2  -- 结果: 20
-- 二进制: 101 <<< 2 = 10100

-- 函数中的左移
def left_shift (x : Nat) (n : Nat) : Nat := x <<< n
#eval left_shift 3 3  -- 结果: 24
-- 二进制: 11 <<< 3 = 11000

-- 乘以2的幂
def multiply_by_power_of_two (x : Nat) (n : Nat) : Nat :=
  x <<< n
#eval multiply_by_power_of_two 7 2  -- 结果: 28 (7 * 4)
```

### 右移运算符 | Right Shift Operator

```lean
-- 右移操作
#eval 20 >>> 2  -- 结果: 5
-- 二进制: 10100 >>> 2 = 101

-- 函数中的右移
def right_shift (x : Nat) (n : Nat) : Nat := x >>> n
#eval right_shift 24 3  -- 结果: 3
-- 二进制: 11000 >>> 3 = 11

-- 除以2的幂
def divide_by_power_of_two (x : Nat) (n : Nat) : Nat :=
  x >>> n
#eval divide_by_power_of_two 28 2  -- 结果: 7 (28 / 4)
```

## 4. 位操作实用函数 | Bit Manipulation Utility Functions

### 位计数函数 | Bit Counting Functions

```lean
-- 计算设置位的数量
def count_set_bits (n : Nat) : Nat :=
  match n with
  | 0 => 0
  | n + 1 => count_set_bits n + (if n &&& 1 = 1 then 1 else 0)

-- 使用内置函数（如果可用）
def popcount (n : Nat) : Nat :=
  -- 这里可以使用更高效的实现
  count_set_bits n

#eval popcount 5  -- 结果: 2 (101有2个设置位)
#eval popcount 7  -- 结果: 3 (111有3个设置位)
```

### 位位置函数 | Bit Position Functions

```lean
-- 找到最高设置位的位置
def highest_set_bit (n : Nat) : Option Nat :=
  if n = 0 then none
  else
    let rec find (pos : Nat) (mask : Nat) : Nat :=
      if mask > n then pos - 1
      else find (pos + 1) (mask <<< 1)
    some (find 0 1)

#eval highest_set_bit 5  -- some 2 (最高位在第2位)
#eval highest_set_bit 8  -- some 3 (最高位在第3位)

-- 找到最低设置位的位置
def lowest_set_bit (n : Nat) : Option Nat :=
  if n = 0 then none
  else
    let rec find (pos : Nat) (mask : Nat) : Option Nat :=
      if mask > n then none
      else if n &&& mask ≠ 0 then some pos
      else find (pos + 1) (mask <<< 1)
    find 0 1

#eval lowest_set_bit 6  -- some 1 (最低设置位在第1位)
#eval lowest_set_bit 8  -- some 3 (最低设置位在第3位)
```

## 5. 位掩码操作 | Bit Mask Operations

### 基本位掩码 | Basic Bit Masks

```lean
-- 创建位掩码
def create_mask (width : Nat) : Nat :=
  (1 <<< width) - 1

#eval create_mask 4  -- 结果: 15 (二进制: 1111)

-- 提取特定位范围
def extract_bits (n : Nat) (start len : Nat) : Nat :=
  let mask := create_mask len
  (n >>> start) &&& mask

#eval extract_bits 0b11010110 2 4  -- 结果: 5 (提取第2-5位)
-- 二进制: 11010110 >>> 2 = 00110101, &&& 1111 = 0101
```

### 位字段操作 | Bit Field Operations

```lean
-- 设置位字段
def set_bit_field (n : Nat) (start len : Nat) (value : Nat) : Nat :=
  let mask := create_mask len
  let cleared := n &&& ~~~(mask <<< start)
  cleared ||| ((value &&& mask) <<< start)

#eval set_bit_field 0b11010110 2 4 3  -- 结果: 0b11001110
-- 在第2-5位设置值3 (0011)

-- 获取位字段
def get_bit_field (n : Nat) (start len : Nat) : Nat :=
  extract_bits n start len

#eval get_bit_field 0b11010110 2 4  -- 结果: 5
```

## 6. 位操作算法 | Bit Manipulation Algorithms

### 快速幂算法 | Fast Exponentiation

```lean
-- 使用位操作的快速幂
def fast_power (base : Nat) (exp : Nat) : Nat :=
  let rec aux (result : Nat) (base : Nat) (exp : Nat) : Nat :=
    if exp = 0 then result
    else if exp &&& 1 = 1 then
      aux (result * base) (base * base) (exp >>> 1)
    else
      aux result (base * base) (exp >>> 1)
  aux 1 base exp

#eval fast_power 2 10  -- 结果: 1024
#eval fast_power 3 5   -- 结果: 243
```

### 汉明距离 | Hamming Distance

```lean
-- 计算两个数的汉明距离（不同位的数量）
def hamming_distance (x y : Nat) : Nat :=
  popcount (x ^^^ y)

#eval hamming_distance 5 3  -- 结果: 2 (101和011有2位不同)
#eval hamming_distance 7 0  -- 结果: 3 (111和000有3位不同)
```

## 7. 位操作优化技巧 | Bit Manipulation Optimization Tips

### 常用位操作技巧 | Common Bit Manipulation Tricks

```lean
-- 检查是否为2的幂
def is_power_of_two (n : Nat) : Bool :=
  n ≠ 0 && (n &&& (n - 1)) = 0

#eval is_power_of_two 8   -- true
#eval is_power_of_two 6   -- false
#eval is_power_of_two 0   -- false

-- 获取最低设置位
def get_lowest_set_bit (n : Nat) : Nat :=
  n &&& (-n : Int).toNat

-- 清除最低设置位
def clear_lowest_set_bit (n : Nat) : Nat :=
  n &&& (n - 1)

#eval clear_lowest_set_bit 6  -- 结果: 4 (110 -> 100)
```

### 位操作常量 | Bit Manipulation Constants

```lean
-- 常用位掩码
def ALL_BITS_SET : Nat := ~~~0
def LOWER_HALF_MASK : Nat := 0xFFFFFFFF
def UPPER_HALF_MASK : Nat := 0xFFFFFFFF00000000

-- 位位置常量
def BIT_0 : Nat := 1
def BIT_1 : Nat := 2
def BIT_2 : Nat := 4
def BIT_3 : Nat := 8
def BIT_4 : Nat := 16
def BIT_5 : Nat := 32
def BIT_6 : Nat := 64
def BIT_7 : Nat := 128
```

## 8. 实际应用示例 | Practical Application Examples

### 位集合 | Bit Sets

```lean
-- 使用自然数表示位集合
def empty_set : Nat := 0
def add_element (set : Nat) (element : Nat) : Nat :=
  set ||| (1 <<< element)
def remove_element (set : Nat) (element : Nat) : Nat :=
  set &&& ~~~(1 <<< element)
def has_element (set : Nat) (element : Nat) : Bool :=
  (set &&& (1 <<< element)) ≠ 0

-- 示例使用
def my_set := add_element (add_element empty_set 2) 5
#eval has_element my_set 2  -- true
#eval has_element my_set 3  -- false
```

### 位标志 | Bit Flags

```lean
-- 定义位标志
def FLAG_READ : Nat := 1
def FLAG_WRITE : Nat := 2
def FLAG_EXECUTE : Nat := 4
def FLAG_HIDDEN : Nat := 8

-- 位标志操作
def set_flag (flags : Nat) (flag : Nat) : Nat :=
  flags ||| flag
def clear_flag (flags : Nat) (flag : Nat) : Nat :=
  flags &&& ~~~flag
def has_flag (flags : Nat) (flag : Nat) : Bool :=
  (flags &&& flag) ≠ 0

-- 示例使用
def file_flags := set_flag (set_flag 0 FLAG_READ) FLAG_WRITE
#eval has_flag file_flags FLAG_READ   -- true
#eval has_flag file_flags FLAG_WRITE  -- true
#eval has_flag file_flags FLAG_EXECUTE -- false
```

## 9. 最佳实践 | Best Practices

### 性能考虑 | Performance Considerations

```lean
-- 使用位操作替代除法
def divide_by_2 (n : Nat) : Nat := n >>> 1
def multiply_by_2 (n : Nat) : Nat := n <<< 1

-- 使用位操作检查奇偶性
def is_even (n : Nat) : Bool := (n &&& 1) = 0
def is_odd (n : Nat) : Bool := (n &&& 1) = 1

-- 使用位操作交换变量（XOR技巧）
def swap_variables (a b : Nat) : Nat × Nat :=
  let a' := a ^^^ b
  let b' := a' ^^^ b
  let a'' := a' ^^^ b'
  (a'', b')
```

### 可读性 | Readability

```lean
-- 使用有意义的常量名
def BYTE_MASK : Nat := 0xFF
def WORD_MASK : Nat := 0xFFFF
def DWORD_MASK : Nat := 0xFFFFFFFF

-- 使用描述性的函数名
def extract_byte (value : Nat) (byte_index : Nat) : Nat :=
  (value >>> (byte_index * 8)) &&& BYTE_MASK

-- 添加注释说明位操作的目的
def pack_rgb (r g b : Nat) : Nat :=
  -- 将RGB值打包为32位整数: RRRRRRRR GGGGGGGG BBBBBBBB
  (r <<< 16) ||| (g <<< 8) ||| b
```

---

*相关链接：*

- [算术运算符](./01-算术运算符.md)
- [逻辑运算符](./02-逻辑运算符.md)
- [注释系统](./04-注释系统.md)
- [类型系统基础](../../02-类型系统基础.md)
- [标识符与关键字](../01-标识符与关键字/01-总览.md)
- [字面量与常量](../03-字面量与常量/01-总览.md)

## 练习 | Exercises

1. 实现位集合的并集、交集和差集操作
2. 创建位标志管理系统
3. 实现高效的位计数和位位置查找算法
4. 设计位操作优化的数学函数

---

*最后更新：2025年1月*
*版本：1.0*
