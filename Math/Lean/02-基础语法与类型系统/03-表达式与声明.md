# 表达式与声明 | Expressions and Declarations

## 1. 表达式系统 | Expression System

### 基本表达式 | Basic Expressions

```lean
-- 字面量表达式
#check 42 : Nat
#check "hello" : String
#check true : Bool

-- 变量表达式
variable (x : Nat) (y : String)
#check x : Nat
#check y : String

-- 函数应用表达式
def add (a b : Nat) : Nat := a + b
#check add 3 4 : Nat
```

### 复合表达式 | Compound Expressions

```lean
-- 算术表达式
#check (2 + 3) * 4 : Nat
#check 2 + 3 * 4 : Nat

-- 逻辑表达式
#check True ∧ False : Prop
#check (p q : Prop) → p ∨ q : Prop

-- 条件表达式
#check if true then 1 else 2 : Nat
```

## 2. 函数定义 | Function Definitions

### 简单函数定义 | Simple Function Definitions

```lean
-- 无参数函数
def constant_function : Nat := 42

-- 单参数函数
def square (x : Nat) : Nat := x * x

-- 多参数函数
def add_three (x y z : Nat) : Nat := x + y + z

-- 智能类型推断
def multiply (x y) := x * y  -- 类型被推断为 Nat → Nat → Nat

-- 点记号语法（Lean4新特性）
def double := (· * 2)  -- 等价于 fun x => x * 2
def add := (· + ·)     -- 等价于 fun x y => x + y
```

### 复杂函数定义 | Complex Function Definitions

```lean
-- 带模式匹配的函数
def factorial : Nat → Nat
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

-- 带守卫的函数
def safe_divide (a b : Nat) (h : b ≠ 0) : Nat := by
  have : 0 < b := Nat.pos_of_ne_zero (Nat.ne_of_ne_of_eq h rfl)
  exact a / b

-- 递归函数
def fibonacci : Nat → Nat
  | 0 => 0
  | 1 => 1
  | n + 2 => fibonacci n + fibonacci (n + 1)
```

## 3. 变量声明 | Variable Declarations

### 全局变量 | Global Variables

```lean
-- 全局变量声明
variable (global_nat : Nat)
variable (global_string : String)

-- 使用全局变量
def use_global : Nat := global_nat + 1
```

### 局部变量 | Local Variables

```lean
-- let表达式
def local_example : Nat :=
  let x := 5
  let y := 3
  x + y

-- 局部变量作用域
def scope_example : Nat :=
  let x := 10
  let y := x + 5  -- y可以访问x
  y
-- x在此处不可访问
```

## 4. 类型声明 | Type Declarations

### 类型别名 | Type Aliases

```lean
-- 简单类型别名
abbrev NaturalNumber := Nat
abbrev Text := String

-- 参数化类型别名
abbrev Pair (α β : Type) := α × β
abbrev Triple (α β γ : Type) := α × β × γ

-- 使用类型别名
def example_pair : Pair Nat String := (42, "hello")
```

### 归纳类型声明 | Inductive Type Declarations

```lean
-- 简单归纳类型
inductive Color where
  | red : Color
  | green : Color
  | blue : Color

-- 参数化归纳类型
inductive Option (α : Type) where
  | none : Option α
  | some (val : α) : Option α

-- 递归归纳类型
inductive Tree (α : Type) where
  | leaf (value : α) : Tree α
  | node (left right : Tree α) : Tree α
```

## 5. 类型类声明 | Type Class Declarations

### 类型类定义 | Type Class Definitions

```lean
-- 基本类型类
class Add (α : Type) where
  add : α → α → α

-- 多参数类型类
class LE (α : Type) where
  le : α → α → Prop

-- 继承类型类
class AddCommGroup (α : Type) extends Add α, Neg α, Zero α where
  add_comm : ∀ a b : α, add a b = add b a
  add_assoc : ∀ a b c : α, add (add a b) c = add a (add b c)
  zero_add : ∀ a : α, add zero a = a
  add_left_neg : ∀ a : α, add (neg a) a = zero
```

### 类型类实例 | Type Class Instances

```lean
-- 基本实例
instance : Add Nat where
  add := Nat.add

-- 参数化实例
instance [Add α] : Add (List α) where
  add := List.zipWith (· + ·)

-- 条件实例
instance [Add α] [Add β] : Add (α × β) where
  add := fun ⟨a1, b1⟩ ⟨a2, b2⟩ => ⟨a1 + a2, b1 + b2⟩
```

## 6. 定理声明 | Theorem Declarations

### 基本定理 | Basic Theorems

```lean
-- 简单定理
theorem add_zero (n : Nat) : n + 0 = n := Nat.add_zero n

-- 带假设的定理
theorem add_comm (a b : Nat) : a + b = b + a := Nat.add_comm a b

-- 条件定理
theorem conditional_theorem (p q : Prop) : p → q → p ∧ q :=
  fun hp hq => ⟨hp, hq⟩
```

### 引理和例子 | Lemmas and Examples

```lean
-- 引理
lemma add_assoc (a b c : Nat) : (a + b) + c = a + (b + c) := Nat.add_assoc a b c

-- 例子
example (n : Nat) : n + 0 = n := Nat.add_zero n

-- 带证明的定理
theorem complex_theorem (n : Nat) : n * 0 = 0 := by
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.mul_succ, ih]
```

## 7. 模块声明 | Module Declarations

### 命名空间 | Namespaces

```lean
-- 命名空间定义
namespace Math
  def square (x : Nat) : Nat := x * x
  def cube (x : Nat) : Nat := x * x * x
  
  -- 在命名空间内可以访问其他定义
  def power_of_four (x : Nat) : Nat := square (square x)
end Math

-- 使用命名空间
#check Math.square 5
```

### 模块导入 | Module Imports

```lean
-- 导入模块
import Std
import Mathlib

-- 使用导入的定义
#check Nat.add_comm
```

## 8. 声明最佳实践 | Declaration Best Practices

### 命名约定 | Naming Conventions

```lean
-- 使用描述性名称
def calculate_fibonacci_number (n : Nat) : Nat :=
  match n with
  | 0 => 0
  | 1 => 1
  | n + 2 => calculate_fibonacci_number n + calculate_fibonacci_number (n + 1)

-- 类型参数使用希腊字母
def List.map {α β : Type} (f : α → β) : List α → List β
  | [] => []
  | x :: xs => f x :: List.map f xs
```

### 代码组织 | Code Organization

```lean
-- 相关定义放在一起
namespace Geometry
  def Point := Nat × Nat
  def distance (p1 p2 : Point) : Nat :=
    let ⟨x1, y1⟩ := p1
    let ⟨x2, y2⟩ := p2
    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)
end Geometry
```

---

*相关链接：*

- [基础语法元素](./01-基础语法元素.md)
- [类型系统基础](./02-类型系统基础.md)
- [模块与命名空间](./04-模块与命名空间.md)
- [Lean4语义分析：语法↔语义对应关系](../08-Lean4语义分析论证系统/02-Lean4语言语义深度分析/01-语法语义对应关系.md)
- [Lean4语义分析：类型推断语义分析](../08-Lean4语义分析论证系统/02-Lean4语言语义深度分析/02-类型系统语义分析.md#-类型推断语义分析--type-inference-semantic-analysis)
