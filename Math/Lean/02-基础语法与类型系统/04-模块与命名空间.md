# 模块与命名空间 | Modules and Namespaces

## 1. 模块系统 | Module System

### 模块导入 | Module Imports

```lean
-- 基本导入
import Std
import Mathlib

-- 条件导入
-- 也可按需精确导入 Mathlib4 模块（示例）：
-- import Mathlib/Data/Nat/Basic
-- import Mathlib/Algebra/Ring/Basic

-- 使用导入的定义
#check Nat.add_comm
#check List.map
```

### 模块导出 | Module Exports

```lean
-- 导出定义
export Mathlib.Data.Nat.Basic (Nat.add_comm Nat.add_assoc)
export Mathlib.Algebra.Group.Basic (Group.mul_assoc)

-- 使用导出的定义
-- #check add_comm  -- 不建议裸导出后直接使用
```

## 2. 命名空间 | Namespaces

### 命名空间定义 | Namespace Definitions

```lean
-- 基本命名空间
namespace Math
  def square (x : Nat) : Nat := x * x
  def cube (x : Nat) : Nat := x * x * x
  
  -- 嵌套命名空间
  namespace Advanced
    def power (x : Nat) (n : Nat) : Nat :=
      match n with
      | 0 => 1
      | n + 1 => x * power x n
  end Advanced
end Math

-- 使用命名空间
#check Math.square 5
#check Math.Advanced.power 2 3
```

### 命名空间操作 | Namespace Operations

```lean
-- 打开命名空间
open Math
#check square 5  -- 不需要前缀

-- 选择性打开
open Math (square cube)
#check square 5
#check cube 3
-- #check power 2 3  -- 错误，power未打开

-- 命名空间别名
namespace M := Math
#check M.square 5
```

## 3. 作用域管理 | Scope Management

### 局部作用域 | Local Scope

```lean
-- let表达式作用域
def scope_example : Nat :=
  let x := 5
  let y := x + 3  -- y可以访问x
  x + y
-- x和y在此处不可访问

-- 模式匹配作用域
def pattern_scope (xs : List Nat) : Nat :=
  match xs with
  | [] => 0
  | x :: xs => x + pattern_scope xs  -- 内层xs遮蔽外层xs
```

### 全局作用域 | Global Scope

```lean
-- 全局定义
def global_constant : Nat := 42

-- 在函数中使用全局定义
def use_global : Nat := global_constant + 1

-- 全局变量
variable (global_param : Nat)
def use_global_param : Nat := global_param * 2
```

## 4. 可见性控制 | Visibility Control

### 私有定义 | Private Definitions

```lean
-- 私有函数
private def internal_helper (x : Nat) : Nat := x + 1

-- 公共接口
def public_function (x : Nat) : Nat := internal_helper x

-- 私有定义在模块外不可见
-- #check internal_helper  -- 错误，如果从其他模块访问
```

### 受保护定义 | Protected Definitions

```lean
-- 受保护的定义
protected def protected_function (x : Nat) : Nat := x * 2

-- 受保护的定义需要完整路径访问
-- 在当前模块内可以直接使用
#check protected_function 5
-- 在其他模块中需要完整路径
```

## 5. 模块依赖 | Module Dependencies

### 依赖管理 | Dependency Management

```lean
-- 直接依赖
import Mathlib.Data.Nat.Basic

-- 传递依赖
import Mathlib.Algebra.Group.Basic  -- 自动导入其依赖

-- 避免循环依赖
-- 模块A导入模块B，模块B不应导入模块A
```

### 模块接口 | Module Interfaces

```lean
-- 定义模块接口
namespace Interface
  -- 公共类型
  def Point := Nat × Nat
  
  -- 公共函数
  def distance (p1 p2 : Point) : Nat :=
    let ⟨x1, y1⟩ := p1
    let ⟨x2, y2⟩ := p2
    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)
  
  -- 私有实现细节
  private def internal_calculation (x y : Nat) : Nat := x + y
end Interface
```

## 6. 命名空间最佳实践 | Namespace Best Practices

### 命名约定 | Naming Conventions

```lean
-- 使用描述性命名空间
namespace DataStructures
  namespace Tree
    def Node := Nat
    def Leaf := Unit
  end Tree
end DataStructures

-- 避免过深的嵌套
namespace Math.Algebra.Group.Theory  -- 过深
namespace GroupTheory  -- 更好
```

### 组织原则 | Organization Principles

```lean
-- 按功能组织
namespace Geometry
  def Point := Nat × Nat
  def Line := Point × Point
  def Circle := Point × Nat
end Geometry

namespace Algebra
  def Group := Type
  def Ring := Type
  def Field := Type
end Algebra
```

## 7. 模块系统高级特性 | Advanced Module System Features

### 条件编译 | Conditional Compilation

```lean
-- 条件定义
-- Lean 4 不推荐使用 C 风格条件编译宏；
-- 可用属性/常量判断或分离实现文件进行区分。
```

### 模块参数 | Module Parameters

```lean
-- 参数化模块
variable {α : Type} [Add α]

namespace Parameterized
  def double (x : α) : α := x + x
  def triple (x : α) : α := x + x + x
end Parameterized
```

## 8. 实际应用示例 | Practical Examples

### 数学库组织 | Mathematical Library Organization

```lean
-- 基础数学
namespace Math.Basic
  def Nat := Nat
  def Int := Int
  def Real := Real
end Math.Basic

-- 代数结构
namespace Math.Algebra
  def Group := Type
  def Ring := Type
  def Field := Type
end Math.Algebra

-- 分析学
namespace Math.Analysis
  def Limit := Type
  def Derivative := Type
  def Integral := Type
end Math.Analysis
```

### 数据结构库 | Data Structure Library

```lean
-- 基础数据结构
namespace DataStructures
  namespace List
    def append {α : Type} : List α → List α → List α
      | [], ys => ys
      | x :: xs, ys => x :: append xs ys
  end List
  
  namespace Tree
    def map {α β : Type} (f : α → β) : Tree α → Tree β
      | Tree.leaf x => Tree.leaf (f x)
      | Tree.node l r => Tree.node (map f l) (map f r)
  end Tree
end DataStructures
```

---

*相关链接：*

- [基础语法元素](./01-基础语法元素.md)
- [类型系统基础](./02-类型系统基础.md)
- [表达式与声明](./03-表达式与声明.md)
- [Lean4语义分析：深度语义解释理论](../08-Lean4语义分析论证系统/02-Lean4语言语义深度分析/04-深度语义解释理论.md)
- [Lean4语义分析：语义一致性证明](../08-Lean4语义分析论证系统/05-形式化证明与论证/01-语义一致性证明.md)
