# 归纳策略 | Induction Strategies

## 概述 | Overview

归纳策略是Lean证明助手中的核心策略之一，用于处理归纳数据类型和数学归纳法。它基于数学归纳原理，通过结构归纳和自然数归纳等方法，为定理证明提供了强大的自动化能力。

Induction strategies are core strategies in the Lean proof assistant, used for handling inductive data types and mathematical induction. Based on mathematical induction principles, they provide powerful automation capabilities for theorem proving through structural induction, natural number induction, and other methods.

## 1. 基本归纳策略 | Basic Induction Strategies

### 1.1 自然数归纳 | Natural Number Induction

自然数归纳是最基本的归纳策略，基于数学归纳原理。

```lean
-- 自然数归纳的基本形式
theorem nat_induction_example (P : ℕ → Prop) :
  P 0 → (∀ n, P n → P (n + 1)) → ∀ n, P n :=
  λ h0 hstep => nat.rec h0 hstep

-- 使用induction策略
theorem sum_formula (n : ℕ) : 
  list.sum (list.range (n + 1)) = n * (n + 1) / 2 :=
begin
  induction n with n ih,
  { -- 基础情况：n = 0
    simp [list.range, list.sum] },
  { -- 归纳步骤：n → n + 1
    simp [list.range, list.sum, ih],
    ring }
end
```

### 1.2 结构归纳 | Structural Induction

结构归纳用于处理归纳定义的数据类型。

```lean
-- 列表结构归纳
theorem list_induction_example {α : Type} (P : list α → Prop) :
  P [] → (∀ (x : α) (xs : list α), P xs → P (x :: xs)) → ∀ xs, P xs :=
  λ hnil hcons => list.rec hnil hcons

-- 使用induction策略处理列表
theorem list_length_non_negative {α : Type} (xs : list α) :
  xs.length ≥ 0 :=
begin
  induction xs with x xs ih,
  { -- 空列表情况
    simp [list.length] },
  { -- 非空列表情况
    simp [list.length],
    exact nat.zero_le _ }
end
```

## 2. 高级归纳策略 | Advanced Induction Strategies

### 2.1 强归纳法 | Strong Induction

强归纳法允许在归纳步骤中使用所有小于当前值的性质。

```lean
-- 强归纳法定义
theorem strong_induction (P : ℕ → Prop) :
  (∀ n, (∀ m < n, P m) → P n) → ∀ n, P n :=
  λ h => nat.strong_induction h

-- 使用强归纳法证明
theorem division_algorithm (a b : ℕ) (hb : b > 0) :
  ∃ q r, a = b * q + r ∧ r < b :=
begin
  induction a using nat.strong_induction with a ih,
  cases a,
  { -- a = 0 的情况
    use [0, 0],
    simp [mul_zero, add_zero],
    exact hb },
  { -- a > 0 的情况
    by_cases h : a < b,
    { -- a < b 的情况
      use [0, a],
      simp [mul_zero, add_zero],
      exact h },
    { -- a ≥ b 的情况
      have h₁ : a - b < a := nat.sub_lt_self (nat.pos_of_not_lt h) hb,
      have ⟨q, r, hq, hr⟩ := ih (a - b) h₁,
      use [q + 1, r],
      simp [hq, nat.add_sub_assoc, nat.add_comm],
      exact hr }}
end
```

### 2.2 双重归纳 | Double Induction

双重归纳用于处理两个变量的归纳。

```lean
-- 双重归纳示例
theorem double_induction_example (P : ℕ → ℕ → Prop) :
  (∀ m, P 0 m) → (∀ n, P n 0) → 
  (∀ n m, P n m → P (n + 1) m → P n (m + 1) → P (n + 1) (m + 1)) →
  ∀ n m, P n m :=
  λ h0 hm hn hstep => 
    nat.rec (λ m => hm m) (λ n ih m => 
      nat.rec (h0 n) (λ m ih' => hstep n m (ih m) ih') m) n

-- 使用双重归纳
theorem binomial_coefficient_positive (n k : ℕ) :
  n.choose k > 0 ↔ k ≤ n :=
begin
  induction n with n ih_n,
  { -- n = 0 的情况
    induction k with k ih_k,
    { simp [nat.choose] },
    { simp [nat.choose, nat.choose_zero_succ] }},
  { -- n → n + 1 的情况
    induction k with k ih_k,
    { simp [nat.choose_zero_right] },
    { simp [nat.choose_succ_succ],
      split,
      { intro h,
        have h₁ := nat.choose_pos (le_of_succ_le_succ (le_of_lt h)),
        have h₂ := nat.choose_pos (le_of_lt h),
        exact le_of_lt h },
      { intro h,
        exact nat.choose_pos h }}}
end
```

## 3. 自定义归纳策略 | Custom Induction Strategies

### 3.1 模式匹配归纳 | Pattern Matching Induction

```lean
-- 自定义归纳类型
inductive custom_tree (α : Type) : Type
| leaf : α → custom_tree α
| node : custom_tree α → custom_tree α → custom_tree α

-- 自定义归纳策略
theorem custom_tree_induction {α : Type} (P : custom_tree α → Prop) :
  (∀ a, P (custom_tree.leaf a)) →
  (∀ t₁ t₂, P t₁ → P t₂ → P (custom_tree.node t₁ t₂)) →
  ∀ t, P t :=
  λ hleaf hnode => custom_tree.rec hleaf hnode

-- 使用自定义归纳
theorem custom_tree_size_positive {α : Type} (t : custom_tree α) :
  tree_size t > 0 :=
begin
  induction t,
  { -- leaf 情况
    simp [tree_size] },
  { -- node 情况
    simp [tree_size],
    exact nat.add_pos_left ih_1 ih_2 }
end
```

### 3.2 递归函数归纳 | Recursive Function Induction

```lean
-- 递归函数定义
def recursive_function : ℕ → ℕ
| 0 := 1
| (n + 1) := recursive_function n + n + 1

-- 递归函数归纳
theorem recursive_function_property (n : ℕ) :
  recursive_function n ≥ 1 :=
begin
  induction n with n ih,
  { -- 基础情况
    simp [recursive_function] },
  { -- 递归情况
    simp [recursive_function],
    exact nat.add_pos_left ih (nat.succ_pos n) }
end
```

## 4. 归纳策略的数学应用 | Mathematical Applications of Induction Strategies

### 4.1 代数结构归纳 | Algebraic Structure Induction

```lean
-- 多项式归纳
theorem polynomial_degree_property (p : polynomial ℝ) :
  p.degree ≥ 0 ∨ p = 0 :=
begin
  induction p using polynomial.induction_on,
  { -- 零多项式
    right, refl },
  { -- 常数多项式
    left, simp [polynomial.degree_C] },
  { -- 非零多项式
    left, simp [polynomial.degree_X] },
  { -- 加法情况
    cases ih_1 with h₁ h₁,
    cases ih_2 with h₂ h₂,
    { left, exact max_le h₁ h₂ },
    { left, exact h₁ },
    { left, exact h₂ },
    { right, simp [h₁, h₂] }},
  { -- 乘法情况
    cases ih_1 with h₁ h₁,
    cases ih_2 with h₂ h₂,
    { left, simp [polynomial.degree_mul] },
    { right, simp [h₁] },
    { right, simp [h₂] },
    { right, simp [h₁, h₂] }}}
end
```

### 4.2 几何结构归纳 | Geometric Structure Induction

```lean
-- 几何图形归纳
inductive geometric_shape : Type
| point : geometric_shape
| line : geometric_shape → geometric_shape → geometric_shape
| circle : geometric_shape → ℝ → geometric_shape

-- 几何性质归纳
theorem geometric_property (s : geometric_shape) :
  shape_area s ≥ 0 :=
begin
  induction s,
  { -- 点的情况
    simp [shape_area] },
  { -- 线的情况
    simp [shape_area],
    exact add_nonneg ih_1 ih_2 },
  { -- 圆的情况
    simp [shape_area],
    exact mul_nonneg (le_of_lt pi_pos) (sq_nonneg r) }
end
```

## 5. 归纳策略的优化 | Optimization of Induction Strategies

### 5.1 归纳假设优化 | Induction Hypothesis Optimization

```lean
-- 优化归纳假设
theorem optimized_induction (P : ℕ → Prop) :
  P 0 → (∀ n, P n → P (n + 1)) → ∀ n, P n :=
begin
  intros h0 hstep,
  induction n with n ih,
  { exact h0 },
  { exact hstep n ih }
end

-- 使用更精确的归纳假设
theorem precise_induction (P : ℕ → Prop) :
  (∀ n, (∀ m < n, P m) → P n) → ∀ n, P n :=
begin
  intro h,
  induction n using nat.strong_induction,
  exact h n ih
end
```

### 5.2 归纳策略组合 | Induction Strategy Combination

```lean
-- 组合多种归纳策略
theorem combined_induction {α : Type} (P : list α → Prop) :
  P [] → (∀ x xs, P xs → P (x :: xs)) → ∀ xs, P xs :=
begin
  intros hnil hcons,
  induction xs with x xs ih,
  { exact hnil },
  { exact hcons x xs ih }
end

-- 嵌套归纳
theorem nested_induction {α β : Type} (P : list α → list β → Prop) :
  (∀ ys, P [] ys) →
  (∀ x xs ys, P xs ys → P (x :: xs) ys) →
  ∀ xs ys, P xs ys :=
begin
  intros hnil hcons,
  induction xs with x xs ih,
  { exact hnil },
  { intro ys,
    induction ys with y ys ih',
    { exact hcons x xs [] (ih []) },
    { exact hcons x xs (y :: ys) (ih (y :: ys)) }}
end
```

## 6. 归纳策略的证明技巧 | Proof Techniques for Induction Strategies

### 6.1 归纳基础处理 | Base Case Handling

```lean
-- 处理复杂的归纳基础
theorem complex_base_case (P : ℕ → Prop) :
  P 0 → P 1 → (∀ n ≥ 2, P n → P (n + 1)) → ∀ n, P n :=
begin
  intros h0 h1 hstep,
  induction n with n ih,
  { exact h0 },
  { cases n with n,
    { exact h1 },
    { exact hstep (n + 2) (le_add_self _ _) ih }}
end
```

### 6.2 归纳步骤处理 | Inductive Step Handling

```lean
-- 处理复杂的归纳步骤
theorem complex_inductive_step (P : ℕ → Prop) :
  P 0 → (∀ n, P n → P (2 * n) → P (2 * n + 1)) → ∀ n, P n :=
begin
  intros h0 hstep,
  induction n using nat.strong_induction,
  cases n,
  { exact h0 },
  { have h₁ := ih (n / 2) (nat.div_lt_self (nat.succ_pos n) (nat.succ_pos 1)),
    have h₂ := ih (n / 2) (nat.div_lt_self (nat.succ_pos n) (nat.succ_pos 1)),
    exact hstep (n / 2) h₁ h₂ }
end
```

## 7. 归纳策略的最佳实践 | Best Practices for Induction Strategies

### 7.1 策略选择原则 | Strategy Selection Principles

1. **简单优先**：优先使用简单的归纳策略
2. **结构匹配**：选择与数据结构匹配的归纳策略
3. **假设利用**：充分利用归纳假设
4. **证明简化**：选择能简化证明的归纳策略

### 7.2 错误处理 | Error Handling

```lean
-- 处理归纳失败的情况
theorem induction_failure_handling (P : ℕ → Prop) :
  P 0 → (∀ n, P n → P (n + 1)) → ∀ n, P n :=
begin
  intros h0 hstep,
  induction n with n ih,
  { exact h0 },
  { try { exact hstep n ih },
    -- 如果直接应用失败，尝试其他方法
    try { exact hstep n ih <|> sorry }}
end
```

## 8. 总结 | Summary

归纳策略是Lean证明助手中的核心工具，它们：

- **提供自动化**：自动处理归纳证明的结构
- **增强表达能力**：支持复杂的归纳模式
- **提高证明效率**：减少手动证明的工作量
- **保证正确性**：确保归纳证明的严格性

这些策略为Lean提供了强大的归纳证明能力，使其能够高效地处理各种数学定理的证明。

---

*最后更新时间：2025年1月*
*版本：1.0*
*状态：完成*
