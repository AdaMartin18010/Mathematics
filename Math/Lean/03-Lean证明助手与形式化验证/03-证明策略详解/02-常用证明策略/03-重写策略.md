# 03-重写策略 | Rewrite Strategy

## 概述 | Overview

重写策略（Rewrite Strategy）是Lean证明助手中的核心证明策略，它允许使用等式、等价关系和定义来重写目标或假设。重写策略基于替换原理，是自动化证明和手动证明中不可或缺的工具。

Rewrite strategy is a core proof tactic in Lean proof assistant that allows rewriting goals or hypotheses using equations, equivalence relations, and definitions. Based on the principle of substitution, rewrite strategy is an indispensable tool in both automated and manual proof.

## 1. 基本重写操作 | Basic Rewrite Operations

### 1.1 简单重写 | Simple Rewrite

```lean
-- 基本重写语法
theorem basic_rewrite_example (a b : Nat) : a + b = b + a := by
  rw [Nat.add_comm]  -- 使用交换律重写

-- 重写假设
theorem rewrite_hypothesis (a b c : Nat) (h : a = b) : a + c = b + c := by
  rw [h]  -- 使用假设h重写目标

-- 重写目标中的特定部分
theorem selective_rewrite (a b c : Nat) : (a + b) + c = a + (b + c) := by
  rw [Nat.add_assoc]  -- 使用结合律重写
```

### 1.2 方向性重写 | Directional Rewrite

```lean
-- 从左到右重写（默认）
theorem left_to_right (a b : Nat) : a + 0 = a := by
  rw [Nat.add_zero]

-- 从右到左重写
theorem right_to_left (a : Nat) : a = a + 0 := by
  rw [←Nat.add_zero]  -- 使用←符号

-- 双向重写
theorem bidirectional (a b : Nat) : a + b = b + a := by
  rw [Nat.add_comm]
  rw [←Nat.add_comm]  -- 反向重写
```

### 1.3 条件重写 | Conditional Rewrite

```lean
-- 条件重写
theorem conditional_rewrite (a b : Nat) (h : a = b) : a * 2 = b * 2 := by
  rw [h]  -- 使用条件h进行重写

-- 多重条件重写
theorem multiple_conditions (a b c : Nat) (h1 : a = b) (h2 : b = c) : a = c := by
  rw [h1, h2]  -- 依次使用多个条件

-- 选择性条件重写
theorem selective_conditional (a b c : Nat) (h : a = b) : a + c = b + c := by
  rw [h] at *  -- 在所有地方使用h
```

## 2. 高级重写技术 | Advanced Rewrite Techniques

### 2.1 模式匹配重写 | Pattern Matching Rewrite

```lean
-- 模式匹配重写
theorem pattern_rewrite (a b : Nat) : (a + b) + (a + b) = 2 * (a + b) := by
  rw [←Nat.mul_two]  -- 使用模式匹配

-- 复杂模式重写
theorem complex_pattern (a b c : Nat) : 
  (a + b) + (c + d) = (a + c) + (b + d) := by
  rw [Nat.add_assoc, Nat.add_comm b c, ←Nat.add_assoc]

-- 嵌套模式重写
theorem nested_pattern (a b c : Nat) : 
  ((a + b) + c) + d = a + (b + (c + d)) := by
  rw [Nat.add_assoc, Nat.add_assoc]
```

### 2.2 重写策略组合 | Rewrite Strategy Combination

```lean
-- 重写与其他策略组合
theorem rewrite_with_simp (a b : Nat) : a + b + 0 = b + a := by
  rw [Nat.add_zero]  -- 先重写
  simp [Nat.add_comm]  -- 再简化

-- 重写与归纳组合
theorem rewrite_with_induction (n : Nat) : n + 0 = n := by
  induction n with
  | zero => rw [Nat.add_zero]
  | succ n ih => 
    rw [Nat.add_succ]
    rw [ih]

-- 重写与cases组合
theorem rewrite_with_cases (n : Nat) : n = 0 ∨ n > 0 := by
  cases n with
  | zero => left; rfl
  | succ n => right; rw [Nat.succ_pos]
```

### 2.3 重写策略优化 | Rewrite Strategy Optimization

```lean
-- 优化重写顺序
theorem optimized_rewrite (a b c : Nat) : 
  (a + b) + (c + 0) = a + (b + c) := by
  rw [Nat.add_zero]  -- 先简化常数
  rw [Nat.add_assoc]  -- 再使用结合律

-- 避免循环重写
theorem avoid_cyclic_rewrite (a b : Nat) : a + b = b + a := by
  rw [Nat.add_comm]  -- 只重写一次
  -- 避免重复重写导致循环

-- 使用重写缓存
theorem cached_rewrite (a b c : Nat) : 
  (a + b) + c = a + (b + c) := by
  rw [Nat.add_assoc]  -- 使用预定义的定理
```

## 3. 实际应用与最佳实践 | Practical Applications and Best Practices

### 3.1 代数证明应用 | Algebraic Proof Applications

```lean
-- 代数恒等式证明
theorem algebraic_identity (a b : Nat) : (a + b)² = a² + 2*a*b + b² := by
  rw [Nat.pow_two, Nat.pow_two, Nat.pow_two]
  rw [Nat.mul_add, Nat.add_mul, Nat.add_mul]
  rw [Nat.mul_comm a b, Nat.add_assoc, Nat.add_assoc]
  rw [←Nat.add_assoc (a*a) (a*b) (a*b)]
  rw [Nat.add_comm (a*b) (b*b)]

-- 多项式展开
theorem polynomial_expansion (a b c : Nat) : 
  (a + b + c)² = a² + b² + c² + 2*a*b + 2*a*c + 2*b*c := by
  rw [Nat.pow_two]
  rw [Nat.add_mul, Nat.add_mul]
  rw [Nat.mul_add, Nat.mul_add, Nat.mul_add]
  rw [Nat.mul_comm, Nat.mul_comm, Nat.mul_comm]
  -- 继续展开...
```

### 3.2 逻辑证明应用 | Logical Proof Applications

```lean
-- 逻辑等价性证明
theorem logical_equivalence (p q : Prop) : 
  (p → q) ↔ (¬q → ¬p) := by
  constructor
  · intro h1 h2 h3
    rw [←h1] at h3
    contradiction
  · intro h1 h2
    rw [h1]
    intro h3
    contradiction

-- 德摩根定律
theorem de_morgan (p q : Prop) : 
  ¬(p ∧ q) ↔ (¬p ∨ ¬q) := by
  constructor
  · intro h
    by_cases hp : p
    · by_cases hq : q
      · contradiction
      · right; exact hq
    · left; exact hp
  · intro h
    intro h2
    cases h with
    | inl hp => contradiction
    | inr hq => contradiction
```

### 3.3 数据结构证明应用 | Data Structure Proof Applications

```lean
-- 列表操作证明
theorem list_append_assoc {α : Type} (xs ys zs : List α) : 
  (xs ++ ys) ++ zs = xs ++ (ys ++ zs) := by
  induction xs with
  | nil => rw [List.nil_append, List.nil_append]
  | cons x xs ih => 
    rw [List.cons_append, List.cons_append, List.cons_append]
    rw [ih]

-- 树操作证明
theorem tree_size_lemma {α : Type} (t : Tree α) : 
  Tree.size t > 0 := by
  induction t with
  | leaf => rw [Tree.size_leaf]; simp
  | node _ left right ih1 ih2 =>
    rw [Tree.size_node]
    simp [ih1, ih2]
```

## 4. 性能优化与最佳实践 | Performance Optimization and Best Practices

### 4.1 重写效率优化 | Rewrite Efficiency Optimization

```lean
-- 选择最有效的重写规则
theorem efficient_rewrite (a b : Nat) : a + b + 0 = b + a := by
  rw [Nat.add_zero]  -- 先简化
  rw [Nat.add_comm]  -- 再交换

-- 避免不必要的重写
theorem avoid_unnecessary_rewrite (a b : Nat) : a + b = b + a := by
  rw [Nat.add_comm]  -- 只重写一次
  -- 不要重复重写

-- 使用重写缓存
theorem use_rewrite_cache (a b c : Nat) : 
  (a + b) + c = a + (b + c) := by
  rw [Nat.add_assoc]  -- 使用预定义定理
```

### 4.2 重写策略选择 | Rewrite Strategy Selection

```lean
-- 选择合适的重写策略
theorem strategy_selection (a b : Nat) : a + b = b + a := by
  -- 对于简单等式，使用rw
  rw [Nat.add_comm]

-- 对于复杂表达式，使用simp
theorem complex_expression (a b c : Nat) : 
  a + b + c + 0 = c + b + a := by
  simp [Nat.add_comm, Nat.add_assoc, Nat.add_zero]

-- 对于条件重写，使用rw
theorem conditional_rewrite_example (a b : Nat) (h : a = b) : 
  a + 1 = b + 1 := by
  rw [h]
```

## 5. 理论背景与前沿发展 | Theoretical Background and Frontier Development

### 5.1 理论基础 | Theoretical Foundation

重写策略的理论基础包括：

- **等式推理（Equational Reasoning）**：基于等式替换的推理方法
- **重写系统（Rewrite Systems）**：形式化的重写规则系统
- **合一理论（Unification Theory）**：模式匹配的理论基础

### 5.2 前沿研究方向 | Frontier Research Directions

- **高阶重写**：支持高阶函数和类型构造函数的重写
- **条件重写**：支持复杂条件约束的重写规则
- **并行重写**：支持并行执行的重写策略

## 6. 总结 | Summary

重写策略是Lean证明助手中的核心工具，它提供了：

1. **强大的表达能力**：支持复杂的等式推理和模式匹配
2. **类型安全保证**：确保重写操作的类型正确性
3. **自动化支持**：与Lean的自动化证明系统无缝集成
4. **灵活性**：支持多种重写方向和策略组合

这些特性使重写策略成为形式化证明和程序验证中不可或缺的技术，在数学证明、程序验证、定理证明等领域有广泛应用。

---

**参考资源 | References**:

- Lean 4官方文档：<https://leanprover.github.io/lean4/doc/>
- 剑桥大学证明论课程：<https://www.cl.cam.ac.uk/teaching/2021/ConceptsPL/>
- 卡内基梅隆大学形式化方法课程：<https://www.cs.cmu.edu/~rwh/courses/hott/>
- 重写系统理论：<https://ncatlab.org/nlab/show/rewrite+system>
