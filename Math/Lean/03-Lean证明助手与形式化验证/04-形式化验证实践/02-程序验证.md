# 02-程序验证 | Program Verification

## 目录

- [02-程序验证 | Program Verification](#02-程序验证--program-verification)
  - [目录](#目录)
  - [1. 主题简介 | Topic Introduction](#1-主题简介--topic-introduction)
  - [2. 程序正确性验证 | Program Correctness Verification](#2-程序正确性验证--program-correctness-verification)
  - [3. 循环不变式 | Loop Invariants](#3-循环不变式--loop-invariants)
  - [4. 前置条件与后置条件 | Preconditions \& Postconditions](#4-前置条件与后置条件--preconditions--postconditions)
  - [5. 代码示例 | Code Examples](#5-代码示例--code-examples)
  - [6. 相关性与本地跳转 | Relevance \& Local Navigation](#6-相关性与本地跳转--relevance--local-navigation)

---

## 1. 主题简介 | Topic Introduction

本主题介绍Lean中的程序验证技术，包括程序正确性验证、循环不变式、前置条件和后置条件等，这些是形式化验证的核心内容。

This topic introduces program verification techniques in Lean, including program correctness verification, loop invariants, preconditions and postconditions, which are core content of formal verification.

---

## 2. 程序正确性验证 | Program Correctness Verification

- 程序正确性验证确保程序满足其规范。
- 包括部分正确性和完全正确性。

```lean
-- 程序正确性验证示例
def factorial_correct (n : Nat) : Nat :=
  if n = 0 then 1
  else n * factorial_correct (n - 1)

-- 正确性定理
theorem factorial_correctness (n : Nat) : 
  factorial_correct n = factorial n := by
  induction n with
  | zero => rfl
  | succ n ih =>
    rw [factorial_correct, factorial]
    simp [ih]
```

---

## 3. 循环不变式 | Loop Invariants

- 循环不变式是循环执行过程中始终保持的性质。
- 用于证明循环的正确性。

```lean
-- 循环不变式示例
def sum_array (arr : List Nat) : Nat :=
  let rec loop (acc : Nat) (xs : List Nat) : Nat :=
    match xs with
    | [] => acc
    | x :: xs => loop (acc + x) xs
  loop 0 arr

-- 循环不变式证明
theorem sum_array_correct (arr : List Nat) : 
  sum_array arr = arr.foldl (λ acc x => acc + x) 0 := by
  induction arr with
  | nil => rfl
  | cons x xs ih =>
    rw [sum_array, loop]
    simp [ih]
```

---

## 4. 前置条件与后置条件 | Preconditions & Postconditions

- 前置条件：程序执行前必须满足的条件。
- 后置条件：程序执行后必须满足的条件。

```lean
-- 前置条件和后置条件示例
def safe_division (a b : Nat) : Option Nat :=
  if b = 0 then none
  else some (a / b)

-- 验证前置条件
theorem safe_division_precondition (a b : Nat) : 
  b ≠ 0 → safe_division a b ≠ none := by
  intro h
  rw [safe_division]
  simp [h]

-- 验证后置条件
theorem safe_division_postcondition (a b : Nat) : 
  safe_division a b = some r → r = a / b := by
  intro h
  rw [safe_division] at h
  cases h with
  | some h => exact h
```

---

## 5. 代码示例 | Code Examples

```lean
-- 程序验证完整示例
namespace ProgramVerification

-- 数组排序验证
def insertion_sort (arr : List Nat) : List Nat :=
  let rec insert (x : Nat) (xs : List Nat) : List Nat :=
    match xs with
    | [] => [x]
    | y :: ys => 
      if x ≤ y then x :: xs
      else y :: insert x ys
  
  let rec sort (xs : List Nat) : List Nat :=
    match xs with
    | [] => []
    | x :: xs => insert x (sort xs)
  
  sort arr

-- 排序正确性验证
theorem insertion_sort_correct (arr : List Nat) : 
  is_sorted (insertion_sort arr) := by
  induction arr with
  | nil => exact is_sorted_nil
  | cons x xs ih =>
    rw [insertion_sort]
    exact insert_preserves_sorted x (insertion_sort xs) ih

-- 复杂程序验证
def binary_search (arr : List Nat) (target : Nat) : Option Nat :=
  let rec search (low high : Nat) : Option Nat :=
    if low > high then none
    else
      let mid := (low + high) / 2
      let mid_val := arr.get? mid
      match mid_val with
      | none => none
      | some val =>
        if val = target then some mid
        else if val < target then search (mid + 1) high
        else search low (mid - 1)
  
  search 0 (arr.length - 1)

-- 二分查找正确性
theorem binary_search_correct (arr : List Nat) (target : Nat) : 
  is_sorted arr → 
  binary_search arr target = some i → 
  arr.get? i = some target := by
  intro h_sorted h_result
  -- 证明实现
  sorry

end ProgramVerification
```

---

## 6. 相关性与本地跳转 | Relevance & Local Navigation

- [返回上级目录](../01-总览.md)
- [形式化验证实践总览](01-总览.md)
- [证明策略详解](../03-证明策略详解/01-总览.md)
- [交互式证明环境](../02-交互式证明环境/01-总览.md)

---

*最后更新时间：2025年1月*
*版本：1.0*
*状态：已完成*
