# Leanè¯æ˜ç­–ç•¥è¯¦è§£ | Lean Proof Tactics Guide

## ğŸ“‹ ç›®å½• | Table of Contents

- [Leanè¯æ˜ç­–ç•¥è¯¦è§£ | Lean Proof Tactics Guide](#leanè¯æ˜ç­–ç•¥è¯¦è§£--lean-proof-tactics-guide)
  - [ğŸ“‹ ç›®å½• | Table of Contents](#-ç›®å½•--table-of-contents)
  - [ğŸ”§ åŸºç¡€è¯æ˜ç­–ç•¥ | Basic Proof Tactics](#-åŸºç¡€è¯æ˜ç­–ç•¥--basic-proof-tactics)
    - [å¼•å…¥ç­–ç•¥ (Introduction Tactics)](#å¼•å…¥ç­–ç•¥-introduction-tactics)
      - [`intro` - å¼•å…¥å‡è®¾](#intro---å¼•å…¥å‡è®¾)
      - [`intros` - æ‰¹é‡å¼•å…¥](#intros---æ‰¹é‡å¼•å…¥)
    - [åº”ç”¨ç­–ç•¥ (Application Tactics)](#åº”ç”¨ç­–ç•¥-application-tactics)
      - [`exact` - ç²¾ç¡®åº”ç”¨](#exact---ç²¾ç¡®åº”ç”¨)
      - [`apply` - åº”ç”¨å®šç†](#apply---åº”ç”¨å®šç†)
      - [`refine` - ç²¾åŒ–åº”ç”¨](#refine---ç²¾åŒ–åº”ç”¨)
    - [æ„é€ ç­–ç•¥ (Construction Tactics)](#æ„é€ ç­–ç•¥-construction-tactics)
      - [`constructor` - æ„é€ åˆå–](#constructor---æ„é€ åˆå–)
      - [`left` / `right` - æ„é€ æå–](#left--right---æ„é€ æå–)
      - [`exists` - æ„é€ å­˜åœ¨é‡è¯](#exists---æ„é€ å­˜åœ¨é‡è¯)
  - [ğŸš€ é«˜çº§è¯æ˜ç­–ç•¥ | Advanced Proof Tactics](#-é«˜çº§è¯æ˜ç­–ç•¥--advanced-proof-tactics)
    - [é‡å†™ç­–ç•¥ (Rewriting Tactics)](#é‡å†™ç­–ç•¥-rewriting-tactics)
      - [`rw` - é‡å†™è¡¨è¾¾å¼](#rw---é‡å†™è¡¨è¾¾å¼)
      - [`simp` - ç®€åŒ–è¡¨è¾¾å¼](#simp---ç®€åŒ–è¡¨è¾¾å¼)
    - [å½’çº³ç­–ç•¥ (Induction Tactics)](#å½’çº³ç­–ç•¥-induction-tactics)
      - [`induction` - å½’çº³è¯æ˜](#induction---å½’çº³è¯æ˜)
      - [`cases` - æƒ…å†µåˆ†æ](#cases---æƒ…å†µåˆ†æ)
    - [è®¡ç®—ç­–ç•¥ (Computation Tactics)](#è®¡ç®—ç­–ç•¥-computation-tactics)
      - [`calc` - è®¡ç®—é“¾](#calc---è®¡ç®—é“¾)
      - [`ring` - ç¯è¿ç®—](#ring---ç¯è¿ç®—)
  - [ğŸ”— ç­–ç•¥ç»„åˆ | Tactic Combination](#-ç­–ç•¥ç»„åˆ--tactic-combination)
    - [ç­–ç•¥ç®¡é“ (Tactic Pipes)](#ç­–ç•¥ç®¡é“-tactic-pipes)
      - [`;` - é¡ºåºæ‰§è¡Œ](#---é¡ºåºæ‰§è¡Œ)
      - [`Â·` - å­ç›®æ ‡æ ‡è®°](#---å­ç›®æ ‡æ ‡è®°)
    - [ç­–ç•¥é€‰æ‹©å™¨ (Tactic Selectors)](#ç­–ç•¥é€‰æ‹©å™¨-tactic-selectors)
      - [`all_goals` - æ‰€æœ‰ç›®æ ‡](#all_goals---æ‰€æœ‰ç›®æ ‡)
      - [`any_goals` - ä»»æ„ç›®æ ‡](#any_goals---ä»»æ„ç›®æ ‡)
    - [æ¡ä»¶ç­–ç•¥ (Conditional Tactics)](#æ¡ä»¶ç­–ç•¥-conditional-tactics)
      - [`try` - å°è¯•ç­–ç•¥](#try---å°è¯•ç­–ç•¥)
      - [`repeat` - é‡å¤ç­–ç•¥](#repeat---é‡å¤ç­–ç•¥)
  - [ğŸ¤– è‡ªåŠ¨åŒ–ç­–ç•¥ | Automation Tactics](#-è‡ªåŠ¨åŒ–ç­–ç•¥--automation-tactics)
    - [æ™ºèƒ½ç­–ç•¥](#æ™ºèƒ½ç­–ç•¥)
      - [`linarith` - çº¿æ€§ç®—æœ¯](#linarith---çº¿æ€§ç®—æœ¯)
      - [`omega` - æ•´æ•°ç®—æœ¯](#omega---æ•´æ•°ç®—æœ¯)
      - [`decide` - å¯åˆ¤å®šå‘½é¢˜](#decide---å¯åˆ¤å®šå‘½é¢˜)
    - [æœç´¢ç­–ç•¥](#æœç´¢ç­–ç•¥)
      - [`assumption` - å‡è®¾æœç´¢](#assumption---å‡è®¾æœç´¢)
      - [`contradiction` - çŸ›ç›¾æœç´¢](#contradiction---çŸ›ç›¾æœç´¢)
  - [ğŸ› ï¸ è‡ªå®šä¹‰ç­–ç•¥ | Custom Tactics](#ï¸-è‡ªå®šä¹‰ç­–ç•¥--custom-tactics)
    - [å®å®šä¹‰ (Macro Definitions)](#å®å®šä¹‰-macro-definitions)
      - [ç®€å•å®](#ç®€å•å®)
      - [å‚æ•°åŒ–å®](#å‚æ•°åŒ–å®)
    - [ç­–ç•¥ç»„åˆå™¨ (Tactic Combinators)](#ç­–ç•¥ç»„åˆå™¨-tactic-combinators)
      - [è‡ªå®šä¹‰ç»„åˆå™¨](#è‡ªå®šä¹‰ç»„åˆå™¨)
  - [ğŸ“š æœ€ä½³å®è·µ | Best Practices](#-æœ€ä½³å®è·µ--best-practices)
    - [ç­–ç•¥é€‰æ‹©åŸåˆ™](#ç­–ç•¥é€‰æ‹©åŸåˆ™)
    - [å¸¸è§æ¨¡å¼](#å¸¸è§æ¨¡å¼)
      - [åˆå–è¯æ˜æ¨¡å¼](#åˆå–è¯æ˜æ¨¡å¼)
      - [æå–è¯æ˜æ¨¡å¼](#æå–è¯æ˜æ¨¡å¼)
      - [å­˜åœ¨è¯æ˜æ¨¡å¼](#å­˜åœ¨è¯æ˜æ¨¡å¼)
    - [è°ƒè¯•æŠ€å·§](#è°ƒè¯•æŠ€å·§)
      - [ä½¿ç”¨ `#print` æŸ¥çœ‹å®šä¹‰](#ä½¿ç”¨-print-æŸ¥çœ‹å®šä¹‰)
      - [ä½¿ç”¨ `#check` æ£€æŸ¥ç±»å‹](#ä½¿ç”¨-check-æ£€æŸ¥ç±»å‹)
      - [ä½¿ç”¨ `#eval` è®¡ç®—å€¼](#ä½¿ç”¨-eval-è®¡ç®—å€¼)
  - [ğŸ”— ç›¸å…³èµ„æº | Related Resources](#-ç›¸å…³èµ„æº--related-resources)

---

## ğŸ”§ åŸºç¡€è¯æ˜ç­–ç•¥ | Basic Proof Tactics

### å¼•å…¥ç­–ç•¥ (Introduction Tactics)

#### `intro` - å¼•å…¥å‡è®¾

```lean
-- å¼•å…¥å•ä¸ªå‡è®¾
theorem example1 (P Q : Prop) : P â†’ Q â†’ P := by
  intro hP  -- å¼•å…¥ P çš„è¯æ˜
  intro hQ  -- å¼•å…¥ Q çš„è¯æ˜
  exact hP  -- ä½¿ç”¨ P çš„è¯æ˜

-- å¼•å…¥å¤šä¸ªå‡è®¾
theorem example2 (P Q R : Prop) : P â†’ Q â†’ R â†’ P âˆ§ Q := by
  intro hP hQ hR
  constructor
  Â· exact hP
  Â· exact hQ
```

#### `intros` - æ‰¹é‡å¼•å…¥

```lean
theorem example3 (P Q R S : Prop) : P â†’ Q â†’ R â†’ S â†’ P âˆ§ Q âˆ§ R := by
  intros hP hQ hR hS
  constructor
  Â· exact hP
  Â· constructor
    Â· exact hQ
    Â· exact hR
```

### åº”ç”¨ç­–ç•¥ (Application Tactics)

#### `exact` - ç²¾ç¡®åº”ç”¨

```lean
theorem example4 (P : Prop) (h : P) : P := by
  exact h  -- ç›´æ¥ä½¿ç”¨å‡è®¾ h
```

#### `apply` - åº”ç”¨å®šç†

```lean
theorem example5 (P Q : Prop) (h1 : P â†’ Q) (h2 : P) : Q := by
  apply h1  -- åº”ç”¨ h1 : P â†’ Q
  exact h2  -- æä¾› P çš„è¯æ˜
```

#### `refine` - ç²¾åŒ–åº”ç”¨

```lean
theorem example6 (P Q R : Prop) (h : P â†’ Q â†’ R) (hP : P) (hQ : Q) : R := by
  refine h ?_ ?_  -- åº”ç”¨ hï¼Œç•™ä¸‹ä¸¤ä¸ªå­ç›®æ ‡
  Â· exact hP       -- è§£å†³ç¬¬ä¸€ä¸ªå­ç›®æ ‡
  Â· exact hQ       -- è§£å†³ç¬¬äºŒä¸ªå­ç›®æ ‡
```

### æ„é€ ç­–ç•¥ (Construction Tactics)

#### `constructor` - æ„é€ åˆå–

```lean
theorem example7 (P Q : Prop) (hP : P) (hQ : Q) : P âˆ§ Q := by
  constructor
  Â· exact hP  -- è¯æ˜ P
  Â· exact hQ  -- è¯æ˜ Q
```

#### `left` / `right` - æ„é€ æå–

```lean
theorem example8 (P Q : Prop) (hP : P) : P âˆ¨ Q := by
  left
  exact hP

theorem example9 (P Q : Prop) (hQ : Q) : P âˆ¨ Q := by
  right
  exact hQ
```

#### `exists` - æ„é€ å­˜åœ¨é‡è¯

```lean
theorem example10 : âˆƒ n : Nat, n > 0 := by
  exists 1
  simp
```

---

## ğŸš€ é«˜çº§è¯æ˜ç­–ç•¥ | Advanced Proof Tactics

### é‡å†™ç­–ç•¥ (Rewriting Tactics)

#### `rw` - é‡å†™è¡¨è¾¾å¼

```lean
theorem example11 (a b : Nat) (h : a = b) : a + 1 = b + 1 := by
  rw [h]  -- å°† a é‡å†™ä¸º b

-- é‡å†™å¤šä¸ªè¡¨è¾¾å¼
theorem example12 (a b c : Nat) (h1 : a = b) (h2 : b = c) : a = c := by
  rw [h1, h2]  -- å…ˆé‡å†™ h1ï¼Œå†é‡å†™ h2

-- é‡å†™æ–¹å‘æ§åˆ¶
theorem example13 (a b : Nat) (h : a = b) : b = a := by
  rw [â†h]  -- ä»å³åˆ°å·¦é‡å†™
```

#### `simp` - ç®€åŒ–è¡¨è¾¾å¼

```lean
theorem example14 (n : Nat) : n + 0 = n := by
  simp  -- è‡ªåŠ¨ç®€åŒ–

-- æŒ‡å®šç®€åŒ–è§„åˆ™
theorem example15 (n : Nat) : double n = n + n := by
  simp[double]  -- ä½¿ç”¨ double çš„å®šä¹‰è¿›è¡Œç®€åŒ–

-- ç®€åŒ–å¤šä¸ªè¡¨è¾¾å¼
theorem example16 (n : Nat) : n + 0 + 0 = n := by
  simp
```

### å½’çº³ç­–ç•¥ (Induction Tactics)

#### `induction` - å½’çº³è¯æ˜

```lean
theorem example17 (n : Nat) : n + 0 = n := by
  induction n with
  | zero => simp
  | succ n ih => 
    simp
    rw [ih]

-- å¼ºå½’çº³
theorem example18 (n : Nat) : n â‰¤ n * n := by
  induction n with
  | zero => simp
  | succ n ih =>
    simp
    linarith
```

#### `cases` - æƒ…å†µåˆ†æ

```lean
theorem example19 (n : Nat) : n = 0 âˆ¨ n > 0 := by
  cases n with
  | zero => left; rfl
  | succ n => right; simp

-- åˆ†æå¸ƒå°”å€¼
theorem example20 (b : Bool) : b = true âˆ¨ b = false := by
  cases b
  Â· left; rfl
  Â· right; rfl
```

### è®¡ç®—ç­–ç•¥ (Computation Tactics)

#### `calc` - è®¡ç®—é“¾

```lean
theorem example21 (a b c : Nat) : (a + b) + c = a + (b + c) := by
  calc
    (a + b) + c = a + b + c := by simp
    _ = a + (b + c) := by simp

-- å¤æ‚è®¡ç®—
theorem example22 (n : Nat) : n + n = 2 * n := by
  calc
    n + n = n * 1 + n * 1 := by simp
    _ = n * (1 + 1) := by rw [Nat.mul_add]
    _ = n * 2 := by simp
    _ = 2 * n := by rw [Nat.mul_comm]
```

#### `ring` - ç¯è¿ç®—

```lean
theorem example23 (a b c : Nat) : (a + b) * c = a * c + b * c := by
  ring

theorem example24 (a b : Nat) : (a + b)Â² = aÂ² + 2 * a * b + bÂ² := by
  ring
```

---

## ğŸ”— ç­–ç•¥ç»„åˆ | Tactic Combination

### ç­–ç•¥ç®¡é“ (Tactic Pipes)

#### `;` - é¡ºåºæ‰§è¡Œ

```lean
theorem example25 (P Q : Prop) (h : P âˆ§ Q) : P := by
  cases h; exact h.1

-- å¤šä¸ªç­–ç•¥ç»„åˆ
theorem example26 (n : Nat) : n + 0 = n := by
  induction n; simp; simp
```

#### `Â·` - å­ç›®æ ‡æ ‡è®°

```lean
theorem example27 (P Q R : Prop) (h1 : P â†’ Q) (h2 : Q â†’ R) (hP : P) : R := by
  apply h2
  Â· apply h1
    exact hP
```

### ç­–ç•¥é€‰æ‹©å™¨ (Tactic Selectors)

#### `all_goals` - æ‰€æœ‰ç›®æ ‡

```lean
theorem example28 (a b c : Nat) : a + b + c = c + b + a := by
  all_goals simp
```

#### `any_goals` - ä»»æ„ç›®æ ‡

```lean
theorem example29 (P Q : Prop) : P âˆ¨ Q â†’ Q âˆ¨ P := by
  intro h
  cases h
  Â· any_goals right; assumption
  Â· any_goals left; assumption
```

### æ¡ä»¶ç­–ç•¥ (Conditional Tactics)

#### `try` - å°è¯•ç­–ç•¥

```lean
theorem example30 (n : Nat) : n + 0 = n := by
  try simp
  try rw [Nat.add_zero]
  try assumption
```

#### `repeat` - é‡å¤ç­–ç•¥

```lean
theorem example31 (n : Nat) : n + 0 + 0 + 0 = n := by
  repeat simp
```

---

## ğŸ¤– è‡ªåŠ¨åŒ–ç­–ç•¥ | Automation Tactics

### æ™ºèƒ½ç­–ç•¥

#### `linarith` - çº¿æ€§ç®—æœ¯

```lean
theorem example32 (a b c : Nat) (h1 : a â‰¤ b) (h2 : b â‰¤ c) : a â‰¤ c := by
  linarith

theorem example33 (a b : Nat) (h : a > 0) : a + b > b := by
  linarith
```

#### `omega` - æ•´æ•°ç®—æœ¯

```lean
theorem example34 (a b : Int) (h1 : a > 0) (h2 : b > 0) : a + b > 0 := by
  omega
```

#### `decide` - å¯åˆ¤å®šå‘½é¢˜

```lean
theorem example35 : 2 + 2 = 4 := by
  decide

theorem example36 : 10 > 5 := by
  decide
```

### æœç´¢ç­–ç•¥

#### `assumption` - å‡è®¾æœç´¢

```lean
theorem example37 (P Q : Prop) (hP : P) (hQ : Q) : P âˆ§ Q := by
  constructor
  Â· assumption  -- è‡ªåŠ¨æ‰¾åˆ° hP
  Â· assumption  -- è‡ªåŠ¨æ‰¾åˆ° hQ
```

#### `contradiction` - çŸ›ç›¾æœç´¢

```lean
theorem example38 (P : Prop) (h1 : P) (h2 : Â¬P) : False := by
  contradiction  -- è‡ªåŠ¨æ‰¾åˆ°çŸ›ç›¾
```

---

## ğŸ› ï¸ è‡ªå®šä¹‰ç­–ç•¥ | Custom Tactics

### å®å®šä¹‰ (Macro Definitions)

#### ç®€å•å®

```lean
macro "trivial" : tactic => `(tactic| simp)

theorem example39 (n : Nat) : n + 0 = n := by
  trivial
```

#### å‚æ•°åŒ–å®

```lean
macro "solve_with" t:term : tactic => `(tactic| $t; simp)

theorem example40 (n : Nat) : n + 0 = n := by
  solve_with rw [Nat.add_zero]
```

### ç­–ç•¥ç»„åˆå™¨ (Tactic Combinators)

#### è‡ªå®šä¹‰ç»„åˆå™¨

```lean
def my_tactic : TacticM Unit := do
  evalTactic (â† `(tactic| simp))
  evalTactic (â† `(tactic| try assumption))

macro "my_tactic" : tactic => `(tactic| $(Lean.quote (â† my_tactic)))

theorem example41 (P Q : Prop) (h : P âˆ§ Q) : P := by
  my_tactic
```

---

## ğŸ“š æœ€ä½³å®è·µ | Best Practices

### ç­–ç•¥é€‰æ‹©åŸåˆ™

1. **ä»ç®€å•åˆ°å¤æ‚**ï¼šå…ˆå°è¯•ç®€å•ç­–ç•¥ï¼Œå†ä½¿ç”¨å¤æ‚ç­–ç•¥
2. **ä¼˜å…ˆè‡ªåŠ¨åŒ–**ï¼šä¼˜å…ˆä½¿ç”¨ `simp`ã€`linarith` ç­‰è‡ªåŠ¨åŒ–ç­–ç•¥
3. **æ˜ç¡®ç›®æ ‡**ï¼šä½¿ç”¨ `Â·` æ˜ç¡®æ ‡è®°å­ç›®æ ‡
4. **é¿å…è¿‡åº¦**ï¼šä¸è¦è¿‡åº¦ä½¿ç”¨å¤æ‚ç­–ç•¥ç»„åˆ

### å¸¸è§æ¨¡å¼

#### åˆå–è¯æ˜æ¨¡å¼

```lean
theorem conjunction_pattern (P Q : Prop) (hP : P) (hQ : Q) : P âˆ§ Q := by
  constructor
  Â· exact hP
  Â· exact hQ
```

#### æå–è¯æ˜æ¨¡å¼

```lean
theorem disjunction_pattern (P Q : Prop) (hP : P) : P âˆ¨ Q := by
  left
  exact hP
```

#### å­˜åœ¨è¯æ˜æ¨¡å¼

```lean
theorem existence_pattern : âˆƒ n : Nat, n > 0 := by
  exists 1
  simp
```

### è°ƒè¯•æŠ€å·§

#### ä½¿ç”¨ `#print` æŸ¥çœ‹å®šä¹‰

```lean
#print Nat.add
#print List.map
```

#### ä½¿ç”¨ `#check` æ£€æŸ¥ç±»å‹

```lean
#check Nat.add
#check List.map
```

#### ä½¿ç”¨ `#eval` è®¡ç®—å€¼

```lean
#eval 2 + 3
#eval List.map (fun x => x * 2) [1, 2, 3]
```

---

## ğŸ”— ç›¸å…³èµ„æº | Related Resources

- [Lean 4è¯æ˜ç­–ç•¥å‚è€ƒ](https://leanprover-community.github.io/lean4/doc/lean4/tactics.html)
- [æ•°å­¦åº“è¯æ˜ç­–ç•¥](https://leanprover-community.github.io/mathlib_docs/tactics.html)
- [ç­–ç•¥ç»„åˆå™¨](https://leanprover-community.github.io/lean4/doc/lean4/tactics.html#tactic-combinators)
- [è‡ªåŠ¨åŒ–ç­–ç•¥](https://leanprover-community.github.io/lean4/doc/lean4/tactics.html#automation)

---

*æŒæ¡è¿™äº›è¯æ˜ç­–ç•¥ï¼Œæ‚¨å°±èƒ½åœ¨Leanä¸­ä¼˜é›…åœ°æ„å»ºæ•°å­¦è¯æ˜äº†ï¼*
