# Lean证明策略详解 | Lean Proof Tactics Guide

## 📋 目录 | Table of Contents

- [Lean证明策略详解 | Lean Proof Tactics Guide](#lean证明策略详解--lean-proof-tactics-guide)
  - [📋 目录 | Table of Contents](#-目录--table-of-contents)
  - [🔧 基础证明策略 | Basic Proof Tactics](#-基础证明策略--basic-proof-tactics)
    - [引入策略 (Introduction Tactics)](#引入策略-introduction-tactics)
      - [`intro` - 引入假设](#intro---引入假设)
      - [`intros` - 批量引入](#intros---批量引入)
    - [应用策略 (Application Tactics)](#应用策略-application-tactics)
      - [`exact` - 精确应用](#exact---精确应用)
      - [`apply` - 应用定理](#apply---应用定理)
      - [`refine` - 精化应用](#refine---精化应用)
    - [构造策略 (Construction Tactics)](#构造策略-construction-tactics)
      - [`constructor` - 构造合取](#constructor---构造合取)
      - [`left` / `right` - 构造析取](#left--right---构造析取)
      - [`exists` - 构造存在量词](#exists---构造存在量词)
  - [🚀 高级证明策略 | Advanced Proof Tactics](#-高级证明策略--advanced-proof-tactics)
    - [重写策略 (Rewriting Tactics)](#重写策略-rewriting-tactics)
      - [`rw` - 重写表达式](#rw---重写表达式)
      - [`simp` - 简化表达式](#simp---简化表达式)
    - [归纳策略 (Induction Tactics)](#归纳策略-induction-tactics)
      - [`induction` - 归纳证明](#induction---归纳证明)
      - [`cases` - 情况分析](#cases---情况分析)
    - [计算策略 (Computation Tactics)](#计算策略-computation-tactics)
      - [`calc` - 计算链](#calc---计算链)
      - [`ring` - 环运算](#ring---环运算)
  - [🔗 策略组合 | Tactic Combination](#-策略组合--tactic-combination)
    - [策略管道 (Tactic Pipes)](#策略管道-tactic-pipes)
      - [`;` - 顺序执行](#---顺序执行)
      - [`·` - 子目标标记](#---子目标标记)
    - [策略选择器 (Tactic Selectors)](#策略选择器-tactic-selectors)
      - [`all_goals` - 所有目标](#all_goals---所有目标)
      - [`any_goals` - 任意目标](#any_goals---任意目标)
    - [条件策略 (Conditional Tactics)](#条件策略-conditional-tactics)
      - [`try` - 尝试策略](#try---尝试策略)
      - [`repeat` - 重复策略](#repeat---重复策略)
  - [🤖 自动化策略 | Automation Tactics](#-自动化策略--automation-tactics)
    - [智能策略](#智能策略)
      - [`linarith` - 线性算术](#linarith---线性算术)
      - [`omega` - 整数算术](#omega---整数算术)
      - [`decide` - 可判定命题](#decide---可判定命题)
    - [搜索策略](#搜索策略)
      - [`assumption` - 假设搜索](#assumption---假设搜索)
      - [`contradiction` - 矛盾搜索](#contradiction---矛盾搜索)
  - [🛠️ 自定义策略 | Custom Tactics](#️-自定义策略--custom-tactics)
    - [宏定义 (Macro Definitions)](#宏定义-macro-definitions)
      - [简单宏](#简单宏)
      - [参数化宏](#参数化宏)
    - [策略组合器 (Tactic Combinators)](#策略组合器-tactic-combinators)
      - [自定义组合器](#自定义组合器)
  - [📚 最佳实践 | Best Practices](#-最佳实践--best-practices)
    - [策略选择原则](#策略选择原则)
    - [常见模式](#常见模式)
      - [合取证明模式](#合取证明模式)
      - [析取证明模式](#析取证明模式)
      - [存在证明模式](#存在证明模式)
    - [调试技巧](#调试技巧)
      - [使用 `#print` 查看定义](#使用-print-查看定义)
      - [使用 `#check` 检查类型](#使用-check-检查类型)
      - [使用 `#eval` 计算值](#使用-eval-计算值)
  - [🔗 相关资源 | Related Resources](#-相关资源--related-resources)

---

## 🔧 基础证明策略 | Basic Proof Tactics

### 引入策略 (Introduction Tactics)

#### `intro` - 引入假设

```lean
-- 引入单个假设
theorem example1 (P Q : Prop) : P → Q → P := by
  intro hP  -- 引入 P 的证明
  intro hQ  -- 引入 Q 的证明
  exact hP  -- 使用 P 的证明

-- 引入多个假设
theorem example2 (P Q R : Prop) : P → Q → R → P ∧ Q := by
  intro hP hQ hR
  constructor
  · exact hP
  · exact hQ
```

#### `intros` - 批量引入

```lean
theorem example3 (P Q R S : Prop) : P → Q → R → S → P ∧ Q ∧ R := by
  intros hP hQ hR hS
  constructor
  · exact hP
  · constructor
    · exact hQ
    · exact hR
```

### 应用策略 (Application Tactics)

#### `exact` - 精确应用

```lean
theorem example4 (P : Prop) (h : P) : P := by
  exact h  -- 直接使用假设 h
```

#### `apply` - 应用定理

```lean
theorem example5 (P Q : Prop) (h1 : P → Q) (h2 : P) : Q := by
  apply h1  -- 应用 h1 : P → Q
  exact h2  -- 提供 P 的证明
```

#### `refine` - 精化应用

```lean
theorem example6 (P Q R : Prop) (h : P → Q → R) (hP : P) (hQ : Q) : R := by
  refine h ?_ ?_  -- 应用 h，留下两个子目标
  · exact hP       -- 解决第一个子目标
  · exact hQ       -- 解决第二个子目标
```

### 构造策略 (Construction Tactics)

#### `constructor` - 构造合取

```lean
theorem example7 (P Q : Prop) (hP : P) (hQ : Q) : P ∧ Q := by
  constructor
  · exact hP  -- 证明 P
  · exact hQ  -- 证明 Q
```

#### `left` / `right` - 构造析取

```lean
theorem example8 (P Q : Prop) (hP : P) : P ∨ Q := by
  left
  exact hP

theorem example9 (P Q : Prop) (hQ : Q) : P ∨ Q := by
  right
  exact hQ
```

#### `exists` - 构造存在量词

```lean
theorem example10 : ∃ n : Nat, n > 0 := by
  exists 1
  simp
```

---

## 🚀 高级证明策略 | Advanced Proof Tactics

### 重写策略 (Rewriting Tactics)

#### `rw` - 重写表达式

```lean
theorem example11 (a b : Nat) (h : a = b) : a + 1 = b + 1 := by
  rw [h]  -- 将 a 重写为 b

-- 重写多个表达式
theorem example12 (a b c : Nat) (h1 : a = b) (h2 : b = c) : a = c := by
  rw [h1, h2]  -- 先重写 h1，再重写 h2

-- 重写方向控制
theorem example13 (a b : Nat) (h : a = b) : b = a := by
  rw [←h]  -- 从右到左重写
```

#### `simp` - 简化表达式

```lean
theorem example14 (n : Nat) : n + 0 = n := by
  simp  -- 自动简化

-- 指定简化规则
theorem example15 (n : Nat) : double n = n + n := by
  simp[double]  -- 使用 double 的定义进行简化

-- 简化多个表达式
theorem example16 (n : Nat) : n + 0 + 0 = n := by
  simp
```

### 归纳策略 (Induction Tactics)

#### `induction` - 归纳证明

```lean
theorem example17 (n : Nat) : n + 0 = n := by
  induction n with
  | zero => simp
  | succ n ih => 
    simp
    rw [ih]

-- 强归纳
theorem example18 (n : Nat) : n ≤ n * n := by
  induction n with
  | zero => simp
  | succ n ih =>
    simp
    linarith
```

#### `cases` - 情况分析

```lean
theorem example19 (n : Nat) : n = 0 ∨ n > 0 := by
  cases n with
  | zero => left; rfl
  | succ n => right; simp

-- 分析布尔值
theorem example20 (b : Bool) : b = true ∨ b = false := by
  cases b
  · left; rfl
  · right; rfl
```

### 计算策略 (Computation Tactics)

#### `calc` - 计算链

```lean
theorem example21 (a b c : Nat) : (a + b) + c = a + (b + c) := by
  calc
    (a + b) + c = a + b + c := by simp
    _ = a + (b + c) := by simp

-- 复杂计算
theorem example22 (n : Nat) : n + n = 2 * n := by
  calc
    n + n = n * 1 + n * 1 := by simp
    _ = n * (1 + 1) := by rw [Nat.mul_add]
    _ = n * 2 := by simp
    _ = 2 * n := by rw [Nat.mul_comm]
```

#### `ring` - 环运算

```lean
theorem example23 (a b c : Nat) : (a + b) * c = a * c + b * c := by
  ring

theorem example24 (a b : Nat) : (a + b)² = a² + 2 * a * b + b² := by
  ring
```

---

## 🔗 策略组合 | Tactic Combination

### 策略管道 (Tactic Pipes)

#### `;` - 顺序执行

```lean
theorem example25 (P Q : Prop) (h : P ∧ Q) : P := by
  cases h; exact h.1

-- 多个策略组合
theorem example26 (n : Nat) : n + 0 = n := by
  induction n; simp; simp
```

#### `·` - 子目标标记

```lean
theorem example27 (P Q R : Prop) (h1 : P → Q) (h2 : Q → R) (hP : P) : R := by
  apply h2
  · apply h1
    exact hP
```

### 策略选择器 (Tactic Selectors)

#### `all_goals` - 所有目标

```lean
theorem example28 (a b c : Nat) : a + b + c = c + b + a := by
  all_goals simp
```

#### `any_goals` - 任意目标

```lean
theorem example29 (P Q : Prop) : P ∨ Q → Q ∨ P := by
  intro h
  cases h
  · any_goals right; assumption
  · any_goals left; assumption
```

### 条件策略 (Conditional Tactics)

#### `try` - 尝试策略

```lean
theorem example30 (n : Nat) : n + 0 = n := by
  try simp
  try rw [Nat.add_zero]
  try assumption
```

#### `repeat` - 重复策略

```lean
theorem example31 (n : Nat) : n + 0 + 0 + 0 = n := by
  repeat simp
```

---

## 🤖 自动化策略 | Automation Tactics

### 智能策略

#### `linarith` - 线性算术

```lean
theorem example32 (a b c : Nat) (h1 : a ≤ b) (h2 : b ≤ c) : a ≤ c := by
  linarith

theorem example33 (a b : Nat) (h : a > 0) : a + b > b := by
  linarith
```

#### `omega` - 整数算术

```lean
theorem example34 (a b : Int) (h1 : a > 0) (h2 : b > 0) : a + b > 0 := by
  omega
```

#### `decide` - 可判定命题

```lean
theorem example35 : 2 + 2 = 4 := by
  decide

theorem example36 : 10 > 5 := by
  decide
```

### 搜索策略

#### `assumption` - 假设搜索

```lean
theorem example37 (P Q : Prop) (hP : P) (hQ : Q) : P ∧ Q := by
  constructor
  · assumption  -- 自动找到 hP
  · assumption  -- 自动找到 hQ
```

#### `contradiction` - 矛盾搜索

```lean
theorem example38 (P : Prop) (h1 : P) (h2 : ¬P) : False := by
  contradiction  -- 自动找到矛盾
```

---

## 🛠️ 自定义策略 | Custom Tactics

### 宏定义 (Macro Definitions)

#### 简单宏

```lean
macro "trivial" : tactic => `(tactic| simp)

theorem example39 (n : Nat) : n + 0 = n := by
  trivial
```

#### 参数化宏

```lean
macro "solve_with" t:term : tactic => `(tactic| $t; simp)

theorem example40 (n : Nat) : n + 0 = n := by
  solve_with rw [Nat.add_zero]
```

### 策略组合器 (Tactic Combinators)

#### 自定义组合器

```lean
def my_tactic : TacticM Unit := do
  evalTactic (← `(tactic| simp))
  evalTactic (← `(tactic| try assumption))

macro "my_tactic" : tactic => `(tactic| $(Lean.quote (← my_tactic)))

theorem example41 (P Q : Prop) (h : P ∧ Q) : P := by
  my_tactic
```

---

## 📚 最佳实践 | Best Practices

### 策略选择原则

1. **从简单到复杂**：先尝试简单策略，再使用复杂策略
2. **优先自动化**：优先使用 `simp`、`linarith` 等自动化策略
3. **明确目标**：使用 `·` 明确标记子目标
4. **避免过度**：不要过度使用复杂策略组合

### 常见模式

#### 合取证明模式

```lean
theorem conjunction_pattern (P Q : Prop) (hP : P) (hQ : Q) : P ∧ Q := by
  constructor
  · exact hP
  · exact hQ
```

#### 析取证明模式

```lean
theorem disjunction_pattern (P Q : Prop) (hP : P) : P ∨ Q := by
  left
  exact hP
```

#### 存在证明模式

```lean
theorem existence_pattern : ∃ n : Nat, n > 0 := by
  exists 1
  simp
```

### 调试技巧

#### 使用 `#print` 查看定义

```lean
#print Nat.add
#print List.map
```

#### 使用 `#check` 检查类型

```lean
#check Nat.add
#check List.map
```

#### 使用 `#eval` 计算值

```lean
#eval 2 + 3
#eval List.map (fun x => x * 2) [1, 2, 3]
```

---

## 🔗 相关资源 | Related Resources

- [Lean 4证明策略参考](https://leanprover-community.github.io/lean4/doc/lean4/tactics.html)
- [数学库证明策略](https://leanprover-community.github.io/mathlib_docs/tactics.html)
- [策略组合器](https://leanprover-community.github.io/lean4/doc/lean4/tactics.html#tactic-combinators)
- [自动化策略](https://leanprover-community.github.io/lean4/doc/lean4/tactics.html#automation)

---

*掌握这些证明策略，您就能在Lean中优雅地构建数学证明了！*
