# 证明状态概述 | Proof State Overview

## 概述 | Overview

证明状态是Lean交互式证明环境的核心概念。它表示当前证明过程中的状态，包括待证明的目标、可用的假设、以及证明的上下文。

Proof state is a core concept in Lean's interactive proof environment. It represents the current state of the proof process, including goals to be proven, available hypotheses, and the proof context.

## 证明状态的基本组成 | Basic Components of Proof State

### 1. 证明目标 | Proof Goals

```lean
-- 简单的证明目标 | Simple proof goal
theorem simple_goal : 1 + 1 = 2 := by
  -- 当前目标: ⊢ 1 + 1 = 2
  rfl

-- 多个证明目标 | Multiple proof goals
theorem multiple_goals (a b : Nat) : a + b = b + a ∧ a * b = b * a := by
  -- 当前目标: ⊢ a + b = b + a ∧ a * b = b * a
  constructor
  -- 目标1: ⊢ a + b = b + a
  -- 目标2: ⊢ a * b = b * a
  · exact add_comm a b
  · exact mul_comm a b
```

### 2. 假设环境 | Hypothesis Environment

```lean
-- 带假设的证明 | Proof with hypotheses
theorem with_hypotheses (a b : Nat) (h : a = b) : a + 1 = b + 1 := by
  -- 假设: h : a = b
  -- 目标: ⊢ a + 1 = b + 1
  rw [h]

-- 多个假设 | Multiple hypotheses
theorem multiple_hypotheses (a b c : Nat) (h1 : a = b) (h2 : b = c) : a = c := by
  -- 假设: h1 : a = b, h2 : b = c
  -- 目标: ⊢ a = c
  rw [h1, h2]
```

### 3. 上下文信息 | Context Information

```lean
-- 带上下文的证明 | Proof with context
section MySection
  variable (α : Type)
  variable (f : α → α)
  
  theorem context_proof (x : α) : f (f x) = f (f x) := by
    -- 上下文: α : Type, f : α → α
    -- 目标: ⊢ f (f x) = f (f x)
    rfl
end MySection
```

## 证明状态的操作 | Proof State Operations

### 1. 查看证明状态 | Viewing Proof State

```lean
-- 使用#check查看类型 | Use #check to view types
#check 1 + 1 = 2  -- 类型: Prop

-- 使用#eval查看值 | Use #eval to view values
#eval 1 + 1  -- 值: 2

-- 在证明中查看状态 | View state in proof
theorem view_state (a b : Nat) : a + b = b + a := by
  -- 可以在这里查看当前证明状态
  exact add_comm a b
```

### 2. 修改证明状态 | Modifying Proof State

```lean
-- 使用have添加中间结果 | Use have to add intermediate results
theorem have_example (a b : Nat) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2 := by
  have h : (a + b) ^ 2 = (a + b) * (a + b) := by rfl
  rw [h]
  ring

-- 使用let定义局部变量 | Use let to define local variables
theorem let_example (a b : Nat) : (a + b) * (a - b) = a ^ 2 - b ^ 2 := by
  let c := a + b
  let d := a - b
  rw [mul_comm c d]
  ring
```

## 证明状态的转换 | Proof State Transitions

### 1. 目标分解 | Goal Decomposition

```lean
-- 使用constructor分解合取 | Use constructor to decompose conjunction
theorem and_decomposition (a b : Nat) : a = b ∧ b = a := by
  constructor
  -- 目标1: ⊢ a = b
  -- 目标2: ⊢ b = a
  · rfl
  · rfl

-- 使用cases分解析取 | Use cases to decompose disjunction
theorem or_decomposition (a b : Nat) (h : a = b ∨ a ≠ b) : True := by
  cases h with
  | inl h1 => trivial
  | inr h2 => trivial
```

### 2. 假设应用 | Hypothesis Application

```lean
-- 使用exact应用假设 | Use exact to apply hypothesis
theorem exact_example (a b : Nat) (h : a = b) : a = b := by
  exact h

-- 使用apply应用函数 | Use apply to apply function
theorem apply_example (a b : Nat) : a + b = b + a := by
  apply add_comm

-- 使用assumption应用假设 | Use assumption to apply hypothesis
theorem assumption_example (a b : Nat) (h1 : a = b) (h2 : b = a) : a = a := by
  assumption
```

## 证明状态的调试 | Proof State Debugging

### 1. 状态检查 | State Checking

```lean
-- 使用sorry暂停证明 | Use sorry to pause proof
theorem debug_example (a b : Nat) : a + b = b + a := by
  -- 在这里可以检查证明状态
  sorry

-- 使用admit承认目标 | Use admit to admit goal
theorem admit_example (a b : Nat) : a + b = b + a := by
  admit
```

### 2. 错误处理 | Error Handling

```lean
-- 处理类型错误 | Handle type errors
theorem type_error_example (a b : Nat) : a + b = b + a := by
  -- 如果类型不匹配，Lean会报告错误
  exact add_comm a b

-- 处理目标不匹配 | Handle goal mismatch
theorem goal_mismatch_example (a b : Nat) : a + b = b + a := by
  -- 如果目标不匹配，需要调整策略
  rw [add_comm]
```

## 高级证明状态管理 | Advanced Proof State Management

### 1. 状态保存与恢复 | State Save and Restore

```lean
-- 使用save保存状态 | Use save to save state
theorem save_example (a b : Nat) : a + b = b + a := by
  save
  exact add_comm a b

-- 使用restore恢复状态 | Use restore to restore state
theorem restore_example (a b : Nat) : a + b = b + a := by
  save
  -- 尝试不同的证明策略
  try rw [add_comm]
  -- 如果失败，恢复状态
  restore
  exact add_comm a b
```

### 2. 状态转换 | State Transitions

```lean
-- 使用focus聚焦目标 | Use focus to focus on goal
theorem focus_example (a b : Nat) : a + b = b + a ∧ a * b = b * a := by
  constructor
  focus
    -- 聚焦第一个目标
    exact add_comm a b
  focus
    -- 聚焦第二个目标
    exact mul_comm a b

-- 使用all_goals处理所有目标 | Use all_goals to handle all goals
theorem all_goals_example (a b : Nat) : a + b = b + a ∧ a * b = b * a := by
  constructor
  all_goals
    -- 对所有目标应用相同策略
    ring
```

## 实际应用示例 | Practical Application Examples

### 1. 复杂证明状态管理 | Complex Proof State Management

```lean
-- 复杂的证明状态管理 | Complex proof state management
theorem complex_proof (a b c : Nat) (h1 : a = b) (h2 : b = c) (h3 : c = a) : a = b := by
  -- 初始状态: 目标 ⊢ a = b，假设 h1, h2, h3
  have h4 : a = c := by
    rw [h1, h2]
  -- 状态更新: 新增假设 h4 : a = c
  have h5 : b = c := h2
  -- 状态更新: 新增假设 h5 : b = c
  exact h1

-- 使用状态管理进行证明 | Use state management for proof
theorem state_management_proof (a b : Nat) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2 := by
  -- 保存初始状态
  save
  -- 尝试直接证明
  try ring
  -- 如果失败，恢复状态并分步证明
  restore
  have h1 : (a + b) ^ 2 = (a + b) * (a + b) := by rfl
  rw [h1]
  ring
```

### 2. 证明状态优化 | Proof State Optimization

```lean
-- 优化证明状态 | Optimize proof state
theorem optimized_proof (a b c : Nat) : a + b + c = c + b + a := by
  -- 使用ring策略自动处理
  ring

-- 手动优化证明状态 | Manual proof state optimization
theorem manual_optimized_proof (a b c : Nat) : a + b + c = c + b + a := by
  -- 手动重排
  rw [add_assoc, add_comm a, add_assoc, add_comm b]
  rfl
```

## 最佳实践 | Best Practices

### 1. 证明状态管理 | Proof State Management

```lean
-- 保持证明状态清晰 | Keep proof state clear
theorem clear_state (a b : Nat) : a + b = b + a := by
  -- 使用明确的策略
  exact add_comm a b

-- 避免复杂的证明状态 | Avoid complex proof states
theorem simple_state (a b : Nat) : a + b = b + a := by
  -- 直接使用已知定理
  exact add_comm a b
```

### 2. 错误处理策略 | Error Handling Strategies

```lean
-- 使用try处理可能的错误 | Use try to handle possible errors
theorem robust_proof (a b : Nat) : a + b = b + a := by
  try exact add_comm a b
  -- 如果失败，使用备用策略
  rw [add_comm]

-- 使用sorry进行渐进式开发 | Use sorry for incremental development
theorem incremental_proof (a b : Nat) : a + b = b + a := by
  -- 先完成主要逻辑
  exact add_comm a b
  -- 后续可以替换sorry
  sorry
```

## 相关链接 | Related Links

- [02-证明目标](./02-证明目标/README.md)
- [基本证明策略](../../02-基本证明策略/README.md)
- [高级证明策略](../../03-高级证明策略/README.md)

## 练习 | Exercises

1. 练习基本的证明状态操作
2. 实现复杂的证明状态管理
3. 优化证明状态的转换过程

---

*最后更新：2025年1月*
*版本：1.0*
