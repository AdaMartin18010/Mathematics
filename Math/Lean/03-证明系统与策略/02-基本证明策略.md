# 基本证明策略 | Basic Proof Tactics

> 提示：建议在可构建的 `lake` 项目中运行本页示例；需安装 `Mathlib` 且使用最新稳定 Lean4 工具链。若策略或 API 报错，请参阅 `Lean/版本同步索引.md` 与本页“版本与兼容性注记”。
> 最小前置导入（建议放在可运行的 `lake` 项目中）：

```lean
import Std
import Mathlib
open scoped BigOperators

-- Lean4最新版本特性：智能类型推断、简化语法、生态系统集成
-- 2025年更新：LeanExplore语义搜索、Lean-auto自动证明、大学课程对齐
```

## 1. 引入策略 | Introduction Tactics

### intro策略 | Intro Tactic

```lean
-- 基本intro
theorem intro_basic (p q : Prop) : p → q → p := by
  intro hp hq
  exact hp

-- 单个intro
theorem intro_single (p : Prop) : p → p := by
  intro hp
  exact hp

-- intro与模式匹配
theorem intro_pattern (p q r : Prop) : p ∨ q → (p → r) → (q → r) → r := by
  intro hpq hpr hqr
  cases hpq with
  | inl hp => exact hpr hp
  | inr hq => exact hqr hq
```

### intros策略 | Intros Tactic

```lean
-- 多个假设引入
theorem intros_example (p q r s : Prop) : p → q → r → s → p ∧ q ∧ r ∧ s := by
  intros hp hq hr hs
  exact ⟨hp, hq, hr, hs⟩

-- 自动引入
theorem intros_auto (p q r : Prop) : p → q → r → p := by
  intros
  assumption
```

## 2. 精确策略 | Exact Tactics

### exact策略 | Exact Tactic

```lean
-- 精确匹配
theorem exact_basic (p : Prop) : p → p := by
  intro hp
  exact hp

-- 使用假设
theorem exact_hypothesis (p q : Prop) (hp : p) : p ∨ q := by
  exact Or.inl hp

-- 使用定理
theorem exact_theorem (a b : Nat) : a = b → a + 1 = b + 1 := by
  intro h
  exact congrArg (· + 1) h
```

### apply策略 | Apply Tactic

```lean
-- 应用定理
theorem apply_basic (p q r : Prop) : p → (p → q) → (q → r) → r := by
  intro hp hpq hqr
  apply hqr
  apply hpq
  exact hp

-- 应用构造子
theorem apply_constructor (a b : Nat) : a = b → a + 1 = b + 1 := by
  intro h
  apply congrArg (· + 1)
  exact h
```

## 3. 重写策略 | Rewriting Tactics

### rw策略 | Rewrite Tactic

```lean
-- 基本重写
theorem rw_basic (a b : Nat) : a = b → a + 1 = b + 1 := by
  intro h
  rw [h]

-- 方向性重写
theorem rw_directional (a b : Nat) : a = b → b + 1 = a + 1 := by
  intro h
  rw [←h]  -- 反向重写

-- 在特定位置重写
theorem rw_at (a b c : Nat) (h1 : a = b) (h2 : a + c = 0) : b + c = 0 := by
  rw [h1] at h2
  exact h2
```

### rfl策略 | Reflexivity Tactic

```lean
-- 自反性
theorem rfl_basic (a : Nat) : a = a := by
  rfl

-- 计算相等
theorem rfl_computation : 2 + 3 = 5 := by
  rfl

-- 结构相等
theorem rfl_structure (a b : Nat) : (a, b) = (a, b) := by
  rfl
```

## 4. 简化策略 | Simplification Tactics

### simp策略 | Simplification Tactic

```lean
-- 基本简化
theorem simp_basic (a b : Nat) : a + 0 + b = a + b := by
  simp

-- 使用假设简化
theorem simp_with_hyp (a b : Nat) (h : a = b) : a + 1 = b + 1 := by
  simp [h]

-- 使用多个假设
theorem simp_multiple (a b c : Nat) (h1 : a = b) (h2 : b = c) : a = c := by
  simp [h1, h2]
```

### norm_num策略 | Normalize Numbers Tactic

```lean
-- 数值计算
theorem norm_num_basic : 2 + 3 * 4 = 14 := by
  norm_num

-- 复杂计算
theorem norm_num_complex (a b : Nat) : (a + b) * (a + b) = a * a + 2 * a * b + b * b := by
  ring
```

## 5. 案例分析策略 | Case Analysis Tactics

### cases策略 | Cases Tactic

```lean
-- 基本案例分析
theorem cases_basic (n : Nat) : n = 0 ∨ n > 0 := by
  cases n with
  | zero => left; rfl
  | succ n => right; exact Nat.succ_pos n

-- 列表案例分析
theorem cases_list (xs : List Nat) : xs = [] ∨ ∃ x xs', xs = x :: xs' := by
  cases xs with
  | nil => left; rfl
  | cons x xs => right; exact ⟨x, xs, rfl⟩
```

### 归纳策略 | Induction Tactic

```lean
-- 基本归纳
theorem induction_basic (n : Nat) : n + 0 = n := by
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.add_succ, ih]

-- 强归纳
theorem induction_strong (n : Nat) : n ≤ 2^n := by
  induction n with
  | zero => simp
  | succ n ih => 
    simp [Nat.pow_succ]
    exact Nat.le_trans ih (Nat.le_mul_of_pos_left (Nat.pow_pos Nat.zero_lt_two n))
```

## 6. 存在性策略 | Existence Tactics

### exists策略 | Exists Tactic

```lean
-- 构造存在性证明
theorem exists_basic : ∃ n : Nat, n > 0 := by
  exists 1
  exact Nat.one_pos

-- 使用变量
theorem exists_variable (a : Nat) : ∃ b : Nat, a + b = a + 1 := by
  exists 1
  rfl
```

### use策略 | Use Tactic

```lean
-- 使用特定值
theorem use_basic : ∃ n : Nat, n + 1 = 2 := by
  use 1
  rfl

-- 使用表达式
theorem use_expression (a : Nat) : ∃ b : Nat, a + b = a * 2 := by
  use a
  ring
```

## 7. 矛盾策略 | Contradiction Tactics

### contradiction策略 | Contradiction Tactic

```lean
-- 寻找矛盾
theorem contradiction_basic (p : Prop) : p → ¬p → False := by
  intro hp hnp
  contradiction

-- 使用假设矛盾
theorem contradiction_hyp (p q : Prop) (hp : p) (hnp : ¬p) : q := by
  contradiction
```

### exfalso策略 | Ex Falso Tactic

```lean
-- 转换为False
theorem exfalso_basic (p : Prop) : p → ¬p → q := by
  intro hp hnp
  exfalso
  exact hnp hp

-- 使用矛盾
theorem exfalso_contradiction (p q : Prop) (hp : p) (hnp : ¬p) : q := by
  exfalso
  exact hnp hp
```

## 8. 策略组合 | Tactic Combination

### 策略链 | Tactic Chains

```lean
-- 顺序策略
theorem tactic_chain (a b c : Nat) : a = b → b = c → a = c := by
  intro hab hbc
  rw [hab, hbc]

-- 条件策略
theorem conditional_tactic (p q : Prop) : p ∨ q → (p → r) → (q → r) → r := by
  intro hpq hpr hqr
  cases hpq with
  | inl hp => exact hpr hp
  | inr hq => exact hqr hq
```

### 策略宏 | Tactic Macros

```lean
-- 自定义策略宏
macro "trivial" : tactic => `(tactic| simp; assumption)

theorem macro_example (p : Prop) (hp : p) : p := by
  trivial

-- 复杂策略宏
macro "auto" : tactic => `(tactic| simp; try assumption; try contradiction)

theorem auto_example (p q : Prop) (hp : p) (hq : q) : p ∧ q := by
  auto
```

## 9. 最新特性集成 | Latest Features Integration

### 9.1 LeanExplore语义搜索 | LeanExplore Semantic Search

```lean
-- 使用LeanExplore进行语义搜索
-- 搜索相关定理和定义

-- 搜索交换律定理
-- 在LeanExplore中搜索："commutative addition"
-- 结果：add_comm, mul_comm, add_assoc等

theorem search_example (a b : Nat) : a + b = b + a := by
  -- 使用LeanExplore找到的定理
  exact add_comm a b

-- 搜索归纳策略
-- 在LeanExplore中搜索："induction tactic"
-- 结果：induction, cases, induction'等

theorem induction_example (n : Nat) : n + 0 = n := by
  -- 使用LeanExplore找到的策略
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.add_succ, ih]
```

### 9.2 Lean-auto自动证明 | Lean-auto Automatic Proof

```lean
-- 使用Lean-auto连接外部自动定理证明器
-- 增强自动证明能力

-- 基础自动证明
theorem auto_basic (p q : Prop) : p → q → p ∧ q := by
  -- Lean-auto会自动尝试外部证明器
  auto

-- 复杂自动证明
theorem auto_complex (a b c : Nat) : 
  a + b + c = c + b + a := by
  -- 使用Lean-auto的自动证明能力
  auto

-- 条件自动证明
theorem auto_conditional (x y : Nat) (h : x > 0) :
  x + y > y := by
  -- Lean-auto会处理条件证明
  auto
```

### 9.3 大学课程对齐策略 | University Course Alignment Strategies

```lean
-- 帝国理工学院Xena项目对齐
-- 形式化本科数学课程

-- 基础代数证明
theorem algebra_xena (a b c : Nat) :
  a + (b + c) = (a + b) + c := by
  exact add_assoc a b c

-- 几何证明
structure Point where
  x : Float
  y : Float
  deriving Repr

theorem geometry_xena (p1 p2 : Point) :
  distance p1 p2 = distance p2 p1 := by
  simp [distance]
  ring

-- 北京大学AI4Math项目对齐
-- AI辅助数学定理形式化

theorem ai_math_example (p q r : Prop) : 
  p → q → r → p ∧ q ∧ r := by
  intro hp hq hr
  exact ⟨hp, hq, hr⟩

-- 普林斯顿大学形式化方法对齐
-- 软件验证和定理证明

theorem formal_methods (f : Nat → Nat) :
  ∀ x, f x ≥ 0 ∧ f x ≤ x * 2 := by
  intro x
  constructor
  · -- 证明非负性
    sorry
  · -- 证明上界
    sorry
```

### 9.4 智能证明策略 | Intelligent Proof Strategies

```lean
-- 智能证明策略组合
-- 结合多种策略进行智能证明

-- 智能简化策略
macro "smart_simp" : tactic => do
  `(simp [*, -not_not] <;> try linarith <;> try ring)

-- 智能归纳策略
macro "smart_induction" : tactic => do
  `(induction <;> simp <;> try linarith)

-- 智能案例分析策略
macro "smart_cases" : tactic => do
  `(cases <;> simp <;> try assumption)

-- 使用智能策略
theorem smart_proof_example (n : Nat) : n + 0 = n := by
  smart_simp

theorem smart_induction_example (n : Nat) : n ≤ 2^n := by
  smart_induction

theorem smart_cases_example (n : Nat) : n = 0 ∨ n > 0 := by
  smart_cases
```

---

*相关链接：*

- [交互式证明环境](./01-交互式证明环境.md)
- [高级证明策略](./03-高级证明策略.md)
- [自动化证明技术](./04-自动化证明技术.md)
- [Lean4最新语言特性](../02-基础语法与类型系统/05-Lean4最新语言特性.md)
- [Lean4最新特性实践指南](../02-基础语法与类型系统/06-Lean4最新特性实践指南.md)

### 参考资源 | References

- Lean 4 手册：`https://leanprover.github.io/lean4/doc/`
- 社区主页与入门：`https://leanprover-community.github.io/` / `https://leanprover-community.github.io/get_started.html`
- tactics 速览：`https://leanprover-community.github.io/tactics.html`
- mathlib4 文档：`https://leanprover-community.github.io/mathlib4_docs/`

---

## 附：版本与兼容性注记 | Version & Compatibility Notes

- 版本基线：参见 `Lean/版本同步索引.md`；本页策略示例基于最新稳定版 + 近期 `mathlib4` 提交。
- 策略来源：`simp/linarith/ring/decide` 等来自 `Mathlib`；若不可用，请检查导入与 `lake` 配置。
- 非标准策略：避免使用 Lean 4 非标准的 `omega`；整数算术优先 `linarith` 或改写为等价命题。
