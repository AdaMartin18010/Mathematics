# 基本证明策略 | Basic Proof Tactics

> 最小前置导入（建议放在可运行的 `lake` 项目中）：

```lean
import Std
import Mathlib
open scoped BigOperators
```

## 1. 引入策略 | Introduction Tactics

### intro策略 | Intro Tactic

```lean
-- 基本intro
theorem intro_basic (p q : Prop) : p → q → p := by
  intro hp hq
  exact hp

-- 单个intro
theorem intro_single (p : Prop) : p → p := by
  intro hp
  exact hp

-- intro与模式匹配
theorem intro_pattern (p q r : Prop) : p ∨ q → (p → r) → (q → r) → r := by
  intro hpq hpr hqr
  cases hpq with
  | inl hp => exact hpr hp
  | inr hq => exact hqr hq
```

### intros策略 | Intros Tactic

```lean
-- 多个假设引入
theorem intros_example (p q r s : Prop) : p → q → r → s → p ∧ q ∧ r ∧ s := by
  intros hp hq hr hs
  exact ⟨hp, hq, hr, hs⟩

-- 自动引入
theorem intros_auto (p q r : Prop) : p → q → r → p := by
  intros
  assumption
```

## 2. 精确策略 | Exact Tactics

### exact策略 | Exact Tactic

```lean
-- 精确匹配
theorem exact_basic (p : Prop) : p → p := by
  intro hp
  exact hp

-- 使用假设
theorem exact_hypothesis (p q : Prop) (hp : p) : p ∨ q := by
  exact Or.inl hp

-- 使用定理
theorem exact_theorem (a b : Nat) : a = b → a + 1 = b + 1 := by
  intro h
  exact congrArg (· + 1) h
```

### apply策略 | Apply Tactic

```lean
-- 应用定理
theorem apply_basic (p q r : Prop) : p → (p → q) → (q → r) → r := by
  intro hp hpq hqr
  apply hqr
  apply hpq
  exact hp

-- 应用构造子
theorem apply_constructor (a b : Nat) : a = b → a + 1 = b + 1 := by
  intro h
  apply congrArg (· + 1)
  exact h
```

## 3. 重写策略 | Rewriting Tactics

### rw策略 | Rewrite Tactic

```lean
-- 基本重写
theorem rw_basic (a b : Nat) : a = b → a + 1 = b + 1 := by
  intro h
  rw [h]

-- 方向性重写
theorem rw_directional (a b : Nat) : a = b → b + 1 = a + 1 := by
  intro h
  rw [←h]  -- 反向重写

-- 在特定位置重写
theorem rw_at (a b c : Nat) (h1 : a = b) (h2 : a + c = 0) : b + c = 0 := by
  rw [h1] at h2
  exact h2
```

### rfl策略 | Reflexivity Tactic

```lean
-- 自反性
theorem rfl_basic (a : Nat) : a = a := by
  rfl

-- 计算相等
theorem rfl_computation : 2 + 3 = 5 := by
  rfl

-- 结构相等
theorem rfl_structure (a b : Nat) : (a, b) = (a, b) := by
  rfl
```

## 4. 简化策略 | Simplification Tactics

### simp策略 | Simplification Tactic

```lean
-- 基本简化
theorem simp_basic (a b : Nat) : a + 0 + b = a + b := by
  simp

-- 使用假设简化
theorem simp_with_hyp (a b : Nat) (h : a = b) : a + 1 = b + 1 := by
  simp [h]

-- 使用多个假设
theorem simp_multiple (a b c : Nat) (h1 : a = b) (h2 : b = c) : a = c := by
  simp [h1, h2]
```

### norm_num策略 | Normalize Numbers Tactic

```lean
-- 数值计算
theorem norm_num_basic : 2 + 3 * 4 = 14 := by
  norm_num

-- 复杂计算
theorem norm_num_complex (a b : Nat) : (a + b) * (a + b) = a * a + 2 * a * b + b * b := by
  ring
```

## 5. 案例分析策略 | Case Analysis Tactics

### cases策略 | Cases Tactic

```lean
-- 基本案例分析
theorem cases_basic (n : Nat) : n = 0 ∨ n > 0 := by
  cases n with
  | zero => left; rfl
  | succ n => right; exact Nat.succ_pos n

-- 列表案例分析
theorem cases_list (xs : List Nat) : xs = [] ∨ ∃ x xs', xs = x :: xs' := by
  cases xs with
  | nil => left; rfl
  | cons x xs => right; exact ⟨x, xs, rfl⟩
```

### 归纳策略 | Induction Tactic

```lean
-- 基本归纳
theorem induction_basic (n : Nat) : n + 0 = n := by
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.add_succ, ih]

-- 强归纳
theorem induction_strong (n : Nat) : n ≤ 2^n := by
  induction n with
  | zero => simp
  | succ n ih => 
    simp [Nat.pow_succ]
    exact Nat.le_trans ih (Nat.le_mul_of_pos_left (Nat.pow_pos Nat.zero_lt_two n))
```

## 6. 存在性策略 | Existence Tactics

### exists策略 | Exists Tactic

```lean
-- 构造存在性证明
theorem exists_basic : ∃ n : Nat, n > 0 := by
  exists 1
  exact Nat.one_pos

-- 使用变量
theorem exists_variable (a : Nat) : ∃ b : Nat, a + b = a + 1 := by
  exists 1
  rfl
```

### use策略 | Use Tactic

```lean
-- 使用特定值
theorem use_basic : ∃ n : Nat, n + 1 = 2 := by
  use 1
  rfl

-- 使用表达式
theorem use_expression (a : Nat) : ∃ b : Nat, a + b = a * 2 := by
  use a
  ring
```

## 7. 矛盾策略 | Contradiction Tactics

### contradiction策略 | Contradiction Tactic

```lean
-- 寻找矛盾
theorem contradiction_basic (p : Prop) : p → ¬p → False := by
  intro hp hnp
  contradiction

-- 使用假设矛盾
theorem contradiction_hyp (p q : Prop) (hp : p) (hnp : ¬p) : q := by
  contradiction
```

### exfalso策略 | Ex Falso Tactic

```lean
-- 转换为False
theorem exfalso_basic (p : Prop) : p → ¬p → q := by
  intro hp hnp
  exfalso
  exact hnp hp

-- 使用矛盾
theorem exfalso_contradiction (p q : Prop) (hp : p) (hnp : ¬p) : q := by
  exfalso
  exact hnp hp
```

## 8. 策略组合 | Tactic Combination

### 策略链 | Tactic Chains

```lean
-- 顺序策略
theorem tactic_chain (a b c : Nat) : a = b → b = c → a = c := by
  intro hab hbc
  rw [hab, hbc]

-- 条件策略
theorem conditional_tactic (p q : Prop) : p ∨ q → (p → r) → (q → r) → r := by
  intro hpq hpr hqr
  cases hpq with
  | inl hp => exact hpr hp
  | inr hq => exact hqr hq
```

### 策略宏 | Tactic Macros

```lean
-- 自定义策略宏
macro "trivial" : tactic => `(tactic| simp; assumption)

theorem macro_example (p : Prop) (hp : p) : p := by
  trivial

-- 复杂策略宏
macro "auto" : tactic => `(tactic| simp; try assumption; try contradiction)

theorem auto_example (p q : Prop) (hp : p) (hq : q) : p ∧ q := by
  auto
```

---

*相关链接：*

- [交互式证明环境](./01-交互式证明环境.md)
- [高级证明策略](./03-高级证明策略.md)
- [自动化证明技术](./04-自动化证明技术.md)
