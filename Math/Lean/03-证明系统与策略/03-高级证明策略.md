# 高级证明策略 | Advanced Proof Tactics

> 提示：建议在可构建的 `lake` 项目中运行本页示例；需安装 `Mathlib` 且使用最新稳定 Lean4 工具链。若策略或 API 报错，请参阅 `Lean/版本同步索引.md` 与本页“版本与兼容性注记”。
> 最小前置导入（建议放在可运行的 `lake` 项目中）：

```lean
import Std
import Mathlib
open scoped BigOperators
```

## 1. 复合策略 | Compound Tactics

### 策略组合器 | Tactic Combinators

```lean
-- 策略序列
theorem tactic_sequence (a b c : Nat) : a = b → b = c → a = c := by
  intro hab hbc
  rw [hab, hbc]

-- 条件策略
theorem conditional_tactic (p q : Prop) : p ∨ q → (p → r) → (q → r) → r := by
  intro hpq hpr hqr
  cases hpq with
  | inl hp => exact hpr hp
  | inr hq => exact hqr hq

-- 尝试策略
theorem try_tactic (p q : Prop) : p → p ∨ q := by
  intro hp
  try left; exact hp
  right; assumption
```

### 策略管道 | Tactic Pipes

```lean
-- 管道操作
theorem tactic_pipe (a b : Nat) : a = b → a + 1 = b + 1 := by
  intro h
  rw [h] <;> rfl

-- 多目标处理
theorem multi_goal (a b : Nat) : a = b → a + 1 = b + 1 ∧ a * 2 = b * 2 := by
  intro h
  constructor <;> rw [h]
```

## 2. 自动化策略 | Automation Tactics

### linarith策略 | Linear Arithmetic

```lean
-- 线性算术
theorem linarith_basic (a b c : Nat) : a ≤ b → b ≤ c → a ≤ c := by
  intros hab hbc
  linarith

-- 复杂线性关系
theorem linarith_complex (a b c d : Nat) : 
  a + b ≤ c → c + d ≤ a + b + 1 → d ≤ 1 := by
  intros h1 h2
  linarith
```

### 整数线性算术 | Integer Linear Arithmetic

```lean
-- 加法保序
theorem int_add_le_add_right (a b : Int) (h : a ≤ b) : a + 1 ≤ b + 1 := by
  simpa using add_le_add_right h 1

-- 传递性示例
theorem int_le_trans (a b c : Int) (h1 : a ≤ b) (h2 : b ≤ c) : a ≤ c := by
  exact le_trans h1 h2
```

### decide策略 | Decision Procedure

```lean
-- 可判定命题
theorem decide_basic : 2 + 3 = 5 := by
  decide

-- 布尔表达式
theorem decide_boolean (a b : Bool) : a && b → a := by
  intro h
  decide
```

## 3. 自定义策略 | Custom Tactics

### 策略宏 | Tactic Macros

```lean
-- 基本策略宏
macro "trivial" : tactic => `(tactic| simp; assumption)

theorem macro_basic (p : Prop) (hp : p) : p := by
  trivial

-- 复杂策略宏
macro "auto" : tactic => `(tactic| simp; try assumption; try contradiction)

theorem macro_complex (p q : Prop) (hp : p) (hq : q) : p ∧ q := by
  auto
```

### 策略组合器1 | Tactic Combinators

```lean
-- 选择策略
theorem choice_tactic (p q : Prop) : p ∨ q → (p → r) → (q → r) → r := by
  intro hpq hpr hqr
  cases hpq with
  | inl hp => exact hpr hp
  | inr hq => exact hqr hq

-- 重复策略
theorem repeat_tactic (n : Nat) : n + 0 = n := by
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.add_succ, ih]
```

## 4. 证明模式 | Proof Patterns

### 直接证明 | Direct Proof

```lean
-- 构造性证明
theorem direct_constructive (p q : Prop) : p → q → p ∧ q := by
  intro hp hq
  exact ⟨hp, hq⟩

-- 计算证明
theorem direct_computational (n : Nat) : n + 0 = n := by
  exact Nat.add_zero n
```

### 反证法 | Proof by Contradiction

```lean
-- 经典反证法
theorem contradiction_classical (p : Prop) : ¬¬p → p := by
  intro hnnp
  by_contra hnp
  exact hnnp hnp

-- 构造性反证法
theorem contradiction_constructive (p q : Prop) : p → ¬p → q := by
  intro hp hnp
  exfalso
  exact hnp hp
```

### 分情况证明 | Proof by Cases

```lean
-- 析取情况
theorem cases_disjunction (p q r : Prop) : p ∨ q → (p → r) → (q → r) → r := by
  intro hpq hpr hqr
  cases hpq with
  | inl hp => exact hpr hp
  | inr hq => exact hqr hq

-- 数值情况
theorem cases_numeric (n : Nat) : n = 0 ∨ n > 0 := by
  cases n with
  | zero => left; rfl
  | succ n => right; exact Nat.succ_pos n
```

## 5. 归纳证明 | Inductive Proofs

### 结构归纳 | Structural Induction

```lean
-- 列表归纳
theorem list_induction (xs : List Nat) : xs.length ≥ 0 := by
  induction xs with
  | nil => simp
  | cons x xs ih => simp [List.length_cons, ih]

-- 树归纳
theorem tree_induction {α : Type} (t : Tree α) : Tree.size t ≥ 1 := by
  induction t with
  | leaf x => simp [Tree.size]
  | node l r ih_l ih_r => 
    simp [Tree.size]
    linarith
```

### 强归纳 | Strong Induction

```lean
-- 强归纳原理
theorem strong_induction (P : Nat → Prop) 
  (h : ∀ n, (∀ m < n, P m) → P n) : ∀ n, P n := by
  intro n
  induction n using Nat.strongInductionOn with
  | ind n ih => exact h n ih
```

## 6. 存在性证明 | Existence Proofs

### 构造性存在 | Constructive Existence

```lean
-- 直接构造
theorem exists_constructive : ∃ n : Nat, n > 0 := by
  exists 1
  exact Nat.one_pos

-- 条件构造
theorem exists_conditional (a : Nat) : ∃ b : Nat, a + b = a + 1 := by
  exists 1
  rfl
```

### 非构造性存在 | Non-Constructive Existence

```lean
-- 使用选择公理
theorem exists_choice (P : Nat → Prop) (h : ∃ n, P n) : ∃ n, P n := by
  exact h

-- 使用排中律
theorem exists_lem (P : Nat → Prop) : ∃ n, P n ∨ ¬P n := by
  exists 0
  exact Classical.em (P 0)
```

## 7. 唯一性证明 | Uniqueness Proofs

### 存在唯一性 | Existence and Uniqueness

```lean
-- 存在唯一性
theorem exists_unique (a : Nat) : ∃! b : Nat, a + b = a + 1 := by
  constructor
  · exists 1
    constructor
    · rfl
    · intro b hb
      linarith
  · intro b1 b2 h1 h2
    linarith
```

### 唯一性条件 | Uniqueness Conditions

```lean
-- 唯一性条件
theorem uniqueness_condition (f : Nat → Nat) (h : ∀ x, f x = x + 1) : 
  ∀ x, f x = x + 1 := by
  exact h
```

## 8. 高级技术 | Advanced Techniques

### 证明状态管理 | Proof State Management

```lean
-- 保存证明状态
theorem state_management (a b c : Nat) : a = b → b = c → a = c := by
  intro hab hbc
  revert a  -- 撤销假设
  intro a
  rw [hab, hbc]
```

### 元编程 | Metaprogramming

```lean
-- 动态策略
theorem metaprogramming (p q : Prop) : p → q → p ∧ q := by
  intro hp hq
  -- 动态构造证明
  exact ⟨hp, hq⟩
```

---

*相关链接：*

- [交互式证明环境](./01-交互式证明环境.md)
- [基本证明策略](./02-基本证明策略.md)
- [自动化证明技术](./04-自动化证明技术.md)

### 参考资源 | References

- Lean 4 手册：`https://leanprover.github.io/lean4/doc/`
- 社区主页与入门：`https://leanprover-community.github.io/` / `https://leanprover-community.github.io/get_started.html`
- tactics 速览：`https://leanprover-community.github.io/tactics.html`
- mathlib4 文档：`https://leanprover-community.github.io/mathlib4_docs/`

---

## 附：版本与兼容性注记 | Version & Compatibility Notes

- 版本基线：参见 `Lean/版本同步索引.md`；本页示例以最新稳定版 + 近期 `mathlib4` 提交为准。
- 策略来源：`linarith/ring/decide` 均来自 `Mathlib`；若不可用，请检查导入与 `lakefile.lean` 的 `mathlib4` 版本。
- 避免 `omega`：Lean 4 环境下不作为标准策略，整数线性算术请改用 `linarith` 或适配命题。
