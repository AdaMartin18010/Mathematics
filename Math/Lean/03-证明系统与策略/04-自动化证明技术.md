# 自动化证明技术 | Automated Proof Techniques

> 提示：建议在可构建的 `lake` 项目中运行本页示例；需安装 `Mathlib` 且使用最新稳定 Lean4 工具链。若策略或 API 报错，请参阅 `Lean/版本同步索引.md` 与本页“版本与兼容性注记”。
> 最小前置导入（建议放在可运行的 `lake` 项目中）：

```lean
import Std
import Mathlib
open scoped BigOperators Interval
```

## 可运行最小项目模板 | Minimal Lake Project Template

> 在空目录中初始化以下文件后，运行：`lake update` → `lake build` → `lake exe AutoProofDemo`（若配置了可执行）。若只需在 `lean` 文件中交互运行，可忽略 `Main.lean` 的可执行部分。

```lean
-- lakefile.lean
import Lake
open Lake DSL

package «AutoProofDemo» {}

-- 选择与本仓同步的 mathlib4 版本（示例使用分支 main，可改为具体 tag）
require mathlib from git "https://github.com/leanprover-community/mathlib4" @ "main"

@[default_target]
lean_lib AutoProofDemo
```

```text
-- lean-toolchain（示例，按本地已安装版本填写，如：stable-2025-01-xx 或 nightly）
stable
```

```lean
-- AutoProofDemo/Main.lean（可选）
import Std
import Mathlib
open scoped BigOperators Interval

def main : IO Unit := do
  IO.println "AutoProofDemo ready"
```

> VS Code 中建议在工作区根目录打开该 `lake` 项目，以获得正确的补全与跳转。

## 常用模块导入清单 | Common Imports Cheat Sheet

- 基础与常用战术：`import Mathlib`（聚合导入，推荐初学与示例）
- 线性与非线性算术：`import Mathlib/Tactic/Linarith`，`import Mathlib/Tactic/Nlinarith`
- 多项式与环化简：`import Mathlib/Tactic/Ring`，`import Mathlib/Algebra/Ring/RingNF`
- 有理式化简：`import Mathlib/Tactic/FieldSimp`
- 区间积分与测度：`import Mathlib/Measure/Integral/IntervalIntegral`
- 归纳与列表等常用结构：`import Std`（或相应 `Mathlib/Data/...` 模块）

> 提示：若使用精确模块导入，需根据实际示例补齐相应模块；不确定时先 `import Mathlib` 再逐步收敛。

## 战术速查表 | Tactics Cheatsheet

- 算术：`linarith`（线性）、`nlinarith`（非线性）、`norm_num`（常量化简）
- 多项式：`ring`、`ring_nf`（标准化优先）
- 有理式：`field_simp [h≠0,…]`
- 逻辑/布尔：`tautology`、`decide`
- 化简：`simp [lemma, ← sub_eq_add_neg]`、`simp?`（建议）
- 重写：`rw [lemma]`、`nth_rewrite`、`simp_rw`
- 类型转换：`norm_cast`、`exact_mod_cast`、`push_cast`
- 归纳：`induction n with | zero | succ n ih => …`

## 1. 决策过程 | Decision Procedures

### 线性算术决策 | Linear Arithmetic Decision

```lean
-- 线性算术自动证明
theorem linear_arithmetic (a b c : Nat) : a ≤ b → b ≤ c → a ≤ c := by
  intros hab hbc
  linarith

-- 复杂线性关系
theorem complex_linear (a b c d : Nat) : 
  a + b ≤ c → c + d ≤ a + b + 1 → d ≤ 1 := by
  intros h1 h2
  linarith

-- 整数线性算术（Lean 4 推荐使用 linarith/nlinarith；不使用 omega）
-- 示例：加法保序与传递
theorem int_add_le_add_right (a b : Int) (h : a ≤ b) : a + 1 ≤ b + 1 := by
  simpa using add_le_add_right h 1

theorem int_le_trans (a b c : Int) (h1 : a ≤ b) (h2 : b ≤ c) : a ≤ c := by
  exact le_trans h1 h2
-- 非线性算术（使用 nlinarith）
theorem nonlinear_arithmetic (x y : ℕ) (hx : x^2 ≤ y^2) (hy : 0 ≤ y) : x ≤ y := by
  -- 将目标归约到整数或实数域上更易于用 nlinarith 处理
  have hx' : (x : ℤ)^2 ≤ (y : ℤ)^2 := by exact_mod_cast hx
  have hy' : (0 : ℤ) ≤ y := by exact_mod_cast hy
  nlinarith

-- simp 与算术策略协同
theorem simp_then_linarith (a b : ℤ) (h : a = b) : a + a ≤ b + b := by
  simp [h]
  linarith
```

### 多项式决策 | Polynomial Decision

```lean
-- 多项式等式
theorem polynomial_equality (a b : Nat) : 
  (a + b) * (a + b) = a * a + 2 * a * b + b * b := by
  ring

-- 多项式不等式
theorem polynomial_inequality (a b : Nat) : 
  a > 0 → b > 0 → a * b > 0 := by
  intros ha hb
  exact Nat.mul_pos ha hb
```

### 多项式与有理式归一化 | Polynomial and Rational Normalization

```lean
-- 多项式标准化（ring_nf）
theorem ring_nf_example (a b : ℤ) : (a + b)^2 - a^2 - 2*a*b - b^2 = 0 := by
  ring_nf

-- 有理式化简（field_simp）
open scoped BigOperators
theorem field_simp_example (x : ℚ) (hx : x ≠ 0) :
  (1 / x) + (1 / x) = 2 / x := by
  field_simp [hx]

-- 组合：先 simp/field_simp，再用 ring 或 linarith
theorem mix_simplify (x : ℚ) (hx : x ≠ 0) :
  (x / x) + (1 / x) = 1 + 1 / x := by
  field_simp [hx]
  ring
```

### 布尔逻辑决策 | Boolean Logic Decision

```lean
-- 布尔表达式
theorem boolean_logic (a b c : Bool) : 
  a && (b || c) = (a && b) || (a && c) := by
  decide

-- 布尔等式
theorem boolean_equality (a b : Bool) : 
  a && b = b && a := by
  decide
```

## 2. 证明搜索 | Proof Search

### 深度优先搜索 | Depth-First Search

```lean
-- 自动搜索证明
theorem dfs_search (p q r : Prop) : p → q → r → p ∧ q ∧ r := by
  intros hp hq hr
  constructor
  · exact hp
  · constructor
    · exact hq
    · exact hr

-- 回溯搜索
theorem backtrack_search (p q r s : Prop) : 
  p ∨ q → r ∨ s → (p ∧ r) ∨ (p ∧ s) ∨ (q ∧ r) ∨ (q ∧ s) := by
  intros hpq hrs
  cases hpq with
  | inl hp => 
    cases hrs with
    | inl hr => left; exact ⟨hp, hr⟩
    | inr hs => right; left; exact ⟨hp, hs⟩
  | inr hq =>
    cases hrs with
    | inl hr => right; right; left; exact ⟨hq, hr⟩
    | inr hs => right; right; right; exact ⟨hq, hs⟩
```

### 广度优先搜索 | Breadth-First Search

```lean
-- 广度优先证明
theorem bfs_search (p q r : Prop) : p → q → r → p ∨ q ∨ r := by
  intros hp hq hr
  left
  exact hp

-- 多目标搜索
theorem multi_goal_search (a b c : Nat) : 
  a = b → b = c → a = c ∧ a + 1 = c + 1 := by
  intros hab hbc
  constructor
  · rw [hab, hbc]
  · rw [hab, hbc]
```

## 3. 启发式搜索 | Heuristic Search

### 基于相似性的启发式 | Similarity-Based Heuristics

```lean
-- 相似性启发式
theorem similarity_heuristic (a b c : Nat) : 
  a = b → b = c → a = c := by
  intros hab hbc
  -- 启发式：使用相似的等式
  rw [hab, hbc]

-- 模式匹配启发式
theorem pattern_heuristic (xs : List Nat) : 
  xs.length ≥ 0 := by
  -- 启发式：对列表使用长度模式
  cases xs with
  | nil => simp
  | cons x xs => simp [List.length_cons]
```

### 基于复杂度的启发式 | Complexity-Based Heuristics

```lean
-- 复杂度启发式
theorem complexity_heuristic (n : Nat) : n + 0 = n := by
  -- 启发式：选择最简单的证明
  exact Nat.add_zero n

-- 递归启发式
theorem recursive_heuristic (n : Nat) : n ≤ 2^n := by
  -- 启发式：对自然数使用归纳
  induction n with
  | zero => simp
  | succ n ih => 
    simp [Nat.pow_succ]
    exact Nat.le_trans ih (Nat.le_mul_of_pos_left (Nat.pow_pos Nat.zero_lt_two n))
```

## 4. 约束传播 | Constraint Propagation

### 等式约束 | Equality Constraints

```lean
-- 等式约束传播
theorem equality_constraint (a b c : Nat) : 
  a = b → b = c → a + b = b + c := by
  intros hab hbc
  rw [hab, hbc]

-- 传递约束
theorem transitive_constraint (a b c d : Nat) : 
  a = b → b = c → c = d → a = d := by
  intros hab hbc hcd
  rw [hab, hbc, hcd]
```

### 不等式约束 | Inequality Constraints

```lean
-- 不等式约束传播
theorem inequality_constraint (a b c : Nat) : 
  a ≤ b → b ≤ c → a ≤ c := by
  intros hab hbc
  exact Nat.le_trans hab hbc

-- 严格不等式
theorem strict_inequality (a b c : Nat) : 
  a < b → b < c → a < c := by
  intros hab hbc
  exact Nat.lt_trans hab hbc
```

## 5. 机器学习辅助证明 | Machine Learning Assisted Proofs

### 神经网络证明搜索 | Neural Network Proof Search

```lean
-- 基于神经网络的证明搜索
theorem neural_proof_search (p q : Prop) : p → q → p ∧ q := by
  intros hp hq
  -- 神经网络建议使用构造
  exact ⟨hp, hq⟩

-- 模式识别
theorem pattern_recognition (n : Nat) : n + 0 = n := by
  -- 神经网络识别出这是加法单位元
  exact Nat.add_zero n
```

### 强化学习证明 | Reinforcement Learning Proofs

```lean
-- 强化学习策略
theorem rl_proof (a b : Nat) : a = b → a + 1 = b + 1 := by
  intro hab
  -- 强化学习选择重写策略
  rw [hab]

-- 奖励引导搜索
theorem reward_guided (p q r : Prop) : p → q → r → p ∧ q ∧ r := by
  intros hp hq hr
  -- 奖励引导选择构造策略
  constructor
  · exact hp
  · constructor
    · exact hq
    · exact hr
```

## 6. 符号计算 | Symbolic Computation

### 符号简化 | Symbolic Simplification

```lean
-- 符号简化
theorem symbolic_simplify (a b : Nat) : 
  a + 0 + b = a + b := by
  simp

-- 复杂符号计算
theorem complex_symbolic (a b c : Nat) : 
  (a + b) * (a + b) = a * a + 2 * a * b + b * b := by
  ring
```

### 符号积分 | Symbolic Integration

```lean
-- 加法可加性：需要区间可积性前提
theorem interval_integral_add (f g : ℝ → ℝ) (a b : ℝ)
    (hf : IntervalIntegrable f volume a b)
    (hg : IntervalIntegrable g volume a b) :
  ∫ x in a..b, (f x + g x) = (∫ x in a..b, f x) + (∫ x in a..b, g x) := by
  simpa using intervalIntegral.integral_add hf hg

-- 常数函数的区间积分
theorem interval_integral_const_one (a b : ℝ) :
  ∫ x in a..b, (1 : ℝ) = b - a := by
  simpa using intervalIntegral.integral_const (a:=a) (b:=b) (c:=(1:ℝ))
```

## 7. 模型检查 | Model Checking

### 有限状态模型检查 | Finite State Model Checking

```lean
-- 有限状态系统
inductive State where
  | initial : State
  | running : State
  | finished : State

-- 状态转换
def transition : State → State
  | State.initial => State.running
  | State.running => State.finished
  | State.finished => State.finished

-- 模型检查性质
theorem model_checking (s : State) : 
  s = State.initial → ∃ n : Nat, (transition^[n]) s = State.finished := by
  intro hs
  exists 2
  simp [hs, transition]
```

### 时序逻辑模型检查 | Temporal Logic Model Checking

```lean
-- 时序逻辑性质
theorem temporal_property (P : Nat → Prop) : 
  (∀ n, P n) → (∃ n, P n) := by
  intro h
  exists 0
  exact h 0

-- 安全性性质
theorem safety_property (s : Nat → State) : 
  (∀ n, s n ≠ State.finished) → (∀ n, s n = State.initial ∨ s n = State.running) := by
  intro h
  intro n
  cases s n with
  | initial => left; rfl
  | running => right; rfl
  | finished => exfalso; exact h n
```

## 9. 练习与参考解 | Exercises with Hints

```lean
-- 练习1：用 ring 展开并化简二次多项式
theorem ex_ring_quad (a b : ℤ) : (a + b)^2 = a^2 + 2*a*b + b^2 := by ring

-- 练习2：用 field_simp 处理有理式（需 a ≠ 0）
theorem ex_field_simp (a b : ℚ) (ha : a ≠ 0) : b / a = (b*a) / (a*a) := by
  field_simp [ha]; ring

-- 练习3：先 simp 再 linarith
theorem ex_simp_linarith (x y : ℤ) (h : x = y) : x + x ≤ y + y := by
  simp [h]; linarith

-- 练习4：nlinarith 证明简单非线性不等式
theorem ex_nlinarith (x : ℤ) (hx : 0 ≤ x) : x^2 + x ≥ 0 := by
  nlinarith
```

## 8. 实际应用 | Practical Applications

### 程序验证 | Program Verification

```lean
-- 程序正确性验证
def factorial (n : Nat) : Nat :=
  match n with
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

-- 程序性质
theorem factorial_property (n : Nat) : 
  n > 0 → factorial n > 0 := by
  intro hn
  induction n with
  | zero => contradiction
  | succ n ih => 
    simp [factorial]
    exact Nat.mul_pos (Nat.succ_pos n) ih
```

### 系统验证 | System Verification

```lean
-- 系统不变量
theorem system_invariant (s : Nat → State) : 
  s 0 = State.initial → (∀ n, s n = State.initial ∨ s n = State.running ∨ s n = State.finished) := by
  intro h0
  intro n
  cases s n with
  | initial => left; rfl
  | running => right; left; rfl
  | finished => right; right; rfl
```

---

*相关链接：*

- [交互式证明环境](./01-交互式证明环境.md)
- [基本证明策略](./02-基本证明策略.md)
- [高级证明策略](./03-高级证明策略.md)

### 参考资源 | References

- Lean 4 手册：`https://leanprover.github.io/lean4/doc/`
- 社区主页与入门：`https://leanprover-community.github.io/` / `https://leanprover-community.github.io/get_started.html`
- tactics 速览：`https://leanprover-community.github.io/tactics.html`
- mathlib4 文档：`https://leanprover-community.github.io/mathlib4_docs/`

---

## 常见故障排查 | Troubleshooting

- 导入缺失
  - 现象：策略或定理名“找不到”。
  - 处理：补充 `import Mathlib` 或精确模块；在 docs 页面顶部复制模块路径。
    - 示例：
      - 区间积分：`import Mathlib/Measure/Integral/IntervalIntegral`
      - `ring`/`ring_nf`：`import Mathlib/Tactic/Ring`、`import Mathlib/Algebra/Ring/RingNF`
      - `linarith`/`nlinarith`：`import Mathlib/Tactic/Linarith`、`import Mathlib/Tactic/Nlinarith`

- 数域/整域不匹配
  - 现象：`linarith/nlinarith` 无法处理或类型不统一。
  - 处理：使用 `norm_cast`/`exact_mod_cast` 将 `ℕ/ℤ/ℚ/ℝ` 统一；必要时改写为等价不等式后再调用策略。

- 化简不足
  - 现象：`linarith` 前仍残留复杂表达式。
  - 处理：先 `simp [*, ← sub_eq_add_neg]` 或 `ring_nf`/`field_simp` 化简，再调用算术策略。

- 多项式目标不标准
  - 现象：`ring` 失败或结果不为标准形。
  - 处理：使用 `ring_nf` 替代 `ring`；必要时先 `simp` 再 `ring_nf`。

- 条件缺失
  - 现象：`field_simp` 需要非零条件。
  - 处理：在上下文加入如 `hx : x ≠ 0`，并写入 `field_simp [hx]`。

---

## 附：版本与兼容性注记 | Version & Compatibility Notes

- 版本基线：参见 `Lean/版本同步索引.md`；本页示例在最新稳定版 + 近期 `mathlib4` 提交验证。
- 策略来源：`linarith/ring/decide` 等策略来自 `Mathlib`；若报错，请检查导入与 `lakefile.lean` 的 `mathlib4` 版本。
- 去除 `omega` 与 `admit`：Lean 4 默认不提供 `omega`；示例已改为可验证的基本定理或 `linarith` 替代。
- 精确模块提示：
  - 区间积分 API 来自 `Mathlib/Measure/Integral/IntervalIntegral` 的 `intervalIntegral.*` 命名空间；需 `open scoped Interval`。
  - 多项式与环化简可优先使用 `ring_nf`；若 `ring` 失败请切换到 `ring_nf` 并配合 `simp`。
  - 算术策略在不同域（ℕ/ℤ/ℚ/ℝ）间需要 `norm_cast`/`exact_mod_cast` 协助统一类型。
