# 02-归纳证明 | Inductive Proofs

## 目录

- [02-归纳证明 | Inductive Proofs](#02-归纳证明--inductive-proofs)
  - [目录](#目录)
  - [1. 主题简介 | Topic Introduction](#1-主题简介--topic-introduction)
  - [2. 数学归纳法 | Mathematical Induction](#2-数学归纳法--mathematical-induction)
  - [3. 结构归纳法 | Structural Induction](#3-结构归纳法--structural-induction)
  - [4. 强归纳法 | Strong Induction](#4-强归纳法--strong-induction)
  - [5. 代码示例 | Code Examples](#5-代码示例--code-examples)
  - [6. 相关性与本地跳转 | Relevance \& Local Navigation](#6-相关性与本地跳转--relevance--local-navigation)

---

## 1. 主题简介 | Topic Introduction

本主题介绍Lean中的归纳证明技术，包括数学归纳法、结构归纳法和强归纳法，这些是证明递归性质的重要方法。

This topic introduces inductive proof techniques in Lean, including mathematical induction, structural induction, and strong induction, which are important methods for proving recursive properties.

---

## 2. 数学归纳法 | Mathematical Induction

- 数学归纳法用于证明自然数上的性质。
- 包括基础情况和归纳步骤。

```lean
-- 基本数学归纳法
theorem add_zero_right (n : Nat) : n + 0 = n := by
  induction n with
  | zero => rw [Nat.add_zero]
  | succ n ih => 
    rw [Nat.add_succ, ih]

-- 复杂归纳法
theorem sum_formula (n : Nat) : 
  (List.range n).foldl (λ acc x => acc + x) 0 = n * (n - 1) / 2 := by
  induction n with
  | zero => rfl
  | succ n ih =>
    rw [List.range_succ, List.foldl_append]
    simp [ih]
```

---

## 3. 结构归纳法 | Structural Induction

- 结构归纳法用于证明递归数据结构上的性质。
- 基于数据结构的构造子进行归纳。

```lean
-- 列表结构归纳法
theorem list_length_non_negative {α : Type} (xs : List α) : 
  xs.length ≥ 0 := by
  induction xs with
  | nil => exact Nat.zero_le 0
  | cons x xs ih => 
    rw [List.length_cons]
    exact Nat.le_add_of_nonneg_right ih

-- 树结构归纳法
inductive Tree (α : Type)
  | leaf : Tree α
  | node : α → Tree α → Tree α → Tree α

theorem tree_size_positive {α : Type} (t : Tree α) : 
  tree_size t ≥ 0 := by
  induction t with
  | leaf => exact Nat.zero_le 0
  | node _ left right ih_left ih_right =>
    rw [tree_size]
    exact Nat.le_add_of_nonneg_right (Nat.le_add_of_nonneg_left ih_left)
```

---

## 4. 强归纳法 | Strong Induction

- 强归纳法假设所有小于n的情况都成立。
- 适用于复杂的递归关系。

```lean
-- 强归纳法示例
theorem strong_induction_example (n : Nat) : 
  n > 0 → ∃ k, n = 2^k ∨ n = 2^k + 1 := by
  induction n using Nat.strongInduction with
  | ind n ih =>
    intro h
    cases n with
    | zero => contradiction
    | succ n =>
      cases Nat.even_or_odd n with
      | inl even_n =>
        let ⟨k, hk⟩ := even_n
        exists k + 1
        left
        rw [hk, Nat.pow_succ]
      | inr odd_n =>
        let ⟨k, hk⟩ := odd_n
        exists k
        right
        rw [hk]
```

---

## 5. 代码示例 | Code Examples

```lean
-- 归纳证明完整示例
namespace InductiveProofs

-- 斐波那契数列归纳证明
def fibonacci : Nat → Nat
  | 0 => 0
  | 1 => 1
  | n + 2 => fibonacci n + fibonacci (n + 1)

theorem fibonacci_positive (n : Nat) : fibonacci n ≥ 0 := by
  induction n with
  | zero => exact Nat.zero_le 0
  | succ n ih =>
    cases n with
    | zero => exact Nat.zero_le 1
    | succ n =>
      rw [fibonacci]
      exact Nat.le_add_of_nonneg_right ih

-- 列表操作归纳证明
theorem map_length {α β : Type} (f : α → β) (xs : List α) : 
  (xs.map f).length = xs.length := by
  induction xs with
  | nil => rfl
  | cons x xs ih =>
    rw [List.map_cons, List.length_cons, List.length_cons, ih]

-- 复杂归纳证明
theorem complex_induction (n : Nat) : 
  n > 0 → ∃ m, n = 2^m ∨ n = 2^m + 1 := by
  induction n using Nat.strongInduction with
  | ind n ih =>
    intro h
    match n with
    | 1 => exists 0; right; rfl
    | n + 2 =>
      have h_n : n > 0 := Nat.succ_lt_succ.mp h
      let ⟨m, hm⟩ := ih n h_n
      cases hm with
      | inl h1 => 
        exists m + 1
        left
        rw [h1, Nat.pow_succ]
      | inr h1 =>
        exists m
        right
        rw [h1, Nat.add_assoc]

end InductiveProofs
```

---

## 6. 相关性与本地跳转 | Relevance & Local Navigation

- [返回上级目录](../01-总览.md)
- [定理证明技术总览](01-总览.md)
- [数学库架构设计](../02-数学库架构设计/01-总览.md)
- [数学概念形式化](../04-数学概念形式化/01-总览.md)

---

*最后更新时间：2025年1月*
*版本：1.0*
*状态：已完成*
