# äº’å½’çº³ | Mutual Induction

## æ¦‚å¿µå®šä¹‰ | Concept Definition

### æ ¸å¿ƒæ¦‚å¿µ | Core Concepts

- **äº’å½’çº³ (Mutual Induction)**: å¤šä¸ªç›¸äº’ä¾èµ–çš„å½’çº³ç±»åž‹æˆ–å‘½é¢˜çš„è¯æ˜Žæ–¹æ³•
- **äº’å½’çº³ç±»åž‹ (Mutual Inductive Types)**: ç›¸äº’ä¾èµ–çš„å½’çº³æ•°æ®ç±»åž‹
- **äº’å½’çº³åŽŸç† (Mutual Induction Principle)**: äº’å½’çº³ç±»åž‹çš„å½’çº³åŽŸç†
- **äº’é€’å½’å‡½æ•° (Mutual Recursive Functions)**: ç›¸äº’è°ƒç”¨çš„é€’å½’å‡½æ•°
- **äº’ä¾èµ–è¯æ˜Ž (Mutual Dependent Proofs)**: ç›¸äº’ä¾èµ–çš„è¯æ˜Žè¿‡ç¨‹

### æƒå¨æ¥æº | Authoritative Sources

- **Coquand, T. (1991)**: "An Algorithm for Type-Checking Dependent Types"
- **GimÃ©nez, E. (1995)**: "Codifying Guarded Definitions with Recursive Schemes"
- **Leanå®˜æ–¹æ–‡æ¡£**: äº’å½’çº³å®žçŽ°

## ç†è®ºåŽ†å²ä¸Žä»£è¡¨äººç‰© | Theoretical History and Key Figures

### åŽ†å²å‘å±• | Historical Development

1. **1980å¹´ä»£**: äº’å½’çº³æ¦‚å¿µæå‡º
2. **1990å¹´ä»£**: äº’å½’çº³ç±»åž‹ç†è®ºå‘å±•
3. **2000å¹´ä»£**: å½¢å¼åŒ–äº’å½’çº³ç³»ç»Ÿ
4. **2010å¹´ä»£**: è‡ªåŠ¨åŒ–äº’å½’çº³å·¥å…·

### ä»£è¡¨äººç‰© | Key Figures

- **Thierry Coquand**: æž„é€ æ¼”ç®—å’Œäº’å½’çº³
- **Eduardo GimÃ©nez**: å®ˆå«é€’å½’å’Œäº’å½’çº³
- **Leanå¼€å‘å›¢é˜Ÿ**: äº’å½’çº³å®žçŽ°

## çŽ°ä»£å‘å±•ä¸Žå‰æ²¿æŒ‘æˆ˜ | Modern Development and Frontier Challenges

### å½“å‰å‘å±• | Current Development

1. **è‡ªåŠ¨åŒ–äº’å½’çº³**: è‡ªåŠ¨ç”Ÿæˆäº’å½’çº³åŽŸç†
2. **é«˜é˜¶äº’å½’çº³**: é«˜é˜¶äº’å½’çº³ç±»åž‹
3. **åµŒå¥—äº’å½’çº³**: åµŒå¥—çš„äº’å½’çº³ç»“æž„

### å‰æ²¿æŒ‘æˆ˜ | Frontier Challenges

1. **æ— é™äº’å½’çº³**: æ— é™äº’å½’çº³ç»“æž„
2. **é‡å­äº’å½’çº³**: é‡å­è®¡ç®—ä¸­çš„äº’å½’çº³
3. **AIäº’å½’çº³**: äººå·¥æ™ºèƒ½ä¸­çš„äº’å½’çº³

## è·¨å­¦ç§‘å½±å“ä¸Žæœªæ¥å±•æœ› | Cross-disciplinary Impact and Future Prospects

### è·¨å­¦ç§‘å½±å“ | Cross-disciplinary Impact

- **è®¡ç®—æœºç§‘å­¦**: å‡½æ•°å¼ç¼–ç¨‹ç†è®º
- **æ•°å­¦**: é€’å½’å‡½æ•°ç†è®º
- **é€»è¾‘å­¦**: æž„é€ é€»è¾‘ç†è®º

### æœªæ¥å±•æœ› | Future Prospects

1. **æ™ºèƒ½åŒ–äº’å½’çº³**: AIè¾…åŠ©çš„äº’å½’çº³
2. **è‡ªé€‚åº”äº’å½’çº³**: è‡ªé€‚åº”äº’å½’çº³ç­–ç•¥
3. **é‡å­äº’å½’çº³**: é‡å­è®¡ç®—ä¸­çš„äº’å½’çº³

## ç›¸å…³æ€§ä¸Žæœ¬åœ°è·³è½¬ | Relevance and Local Navigation

### ç›¸å…³ä¸»é¢˜ | Related Topics

- [å½’çº³è¯æ˜Ž](../01-æ€»è§ˆ.md)
- [å®šç†è¯æ˜ŽæŠ€æœ¯](../../01-æ€»è§ˆ.md)
- [Leanæ•°å­¦åº“ä¸Žå®šç†è¯æ˜Ž](../../../01-æ€»è§ˆ.md)

### æœ¬åœ°è·³è½¬ | Local Navigation

- [ä¸Šä¸€çº§ï¼šå½’çº³è¯æ˜Ž](../01-æ€»è§ˆ.md)
- [ä¸‹ä¸€çº§ï¼šäº’å½’çº³ç±»åž‹](02-äº’å½’çº³ç±»åž‹/01-æ€»è§ˆ.md)

## è¿›åº¦æ—¥å¿—ä¸Žæ–­ç‚¹æ ‡è®° | Progress Log and Checkpoint Markers

### å½“å‰è¿›åº¦ | Current Progress

- âœ… åˆ›å»ºäº’å½’çº³æ€»è§ˆ
- ðŸ”„ åˆ›å»ºäº’å½’çº³ç±»åž‹å­ç›®å½•
- ðŸ”„ åˆ›å»ºäº’é€’å½’å‡½æ•°å­ç›®å½•
- ðŸ”„ åˆ›å»ºäº’ä¾èµ–è¯æ˜Žå­ç›®å½•

### æ–­ç‚¹æ ‡è®° | Checkpoint Markers

- **æ£€æŸ¥ç‚¹1**: äº’å½’çº³åŸºç¡€æ¦‚å¿µå®Œæˆ
- **æ£€æŸ¥ç‚¹2**: äº’å½’çº³ç±»åž‹å®Œæˆ
- **æ£€æŸ¥ç‚¹3**: äº’é€’å½’å‡½æ•°å®Œæˆ

## ä»£ç ç¤ºä¾‹ | Code Examples

### äº’å½’çº³ç¤ºä¾‹ | Mutual Induction Examples

```lean
-- äº’å½’çº³ç±»åž‹ï¼šè¡¨è¾¾å¼å’Œè¯­å¥
mutual
  inductive Expression where
    | const : Nat â†’ Expression
    | var : String â†’ Expression
    | add : Expression â†’ Expression â†’ Expression
    | app : Statement â†’ Expression â†’ Expression

  inductive Statement where
    | skip : Statement
    | assign : String â†’ Expression â†’ Statement
    | seq : Statement â†’ Statement â†’ Statement
    | if : Expression â†’ Statement â†’ Statement â†’ Statement
end

-- äº’é€’å½’å‡½æ•°ï¼šæ±‚å€¼å‡½æ•°
mutual
  def evalExpr (env : Map String Nat) : Expression â†’ Nat
    | Expression.const n => n
    | Expression.var x => env.find? x |>.getD 0
    | Expression.add e1 e2 => evalExpr env e1 + evalExpr env e2
    | Expression.app s e => evalStmt env s; evalExpr env e

  def evalStmt (env : Map String Nat) : Statement â†’ Map String Nat
    | Statement.skip => env
    | Statement.assign x e => env.insert x (evalExpr env e)
    | Statement.seq s1 s2 => evalStmt (evalStmt env s1) s2
    | Statement.if e s1 s2 => 
      if evalExpr env e â‰  0 then evalStmt env s1 else evalStmt env s2
end
```

### äº’å½’çº³è¯æ˜Žç¤ºä¾‹ | Mutual Induction Proof Examples

```lean
-- äº’å½’çº³è¯æ˜Žï¼šè¡¨è¾¾å¼å’Œè¯­å¥çš„æ€§è´¨
mutual
  theorem expr_well_formed (e : Expression) : Prop :=
    match e with
    | Expression.const _ => True
    | Expression.var _ => True
    | Expression.add e1 e2 => expr_well_formed e1 âˆ§ expr_well_formed e2
    | Expression.app s e => stmt_well_formed s âˆ§ expr_well_formed e

  theorem stmt_well_formed (s : Statement) : Prop :=
    match s with
    | Statement.skip => True
    | Statement.assign _ e => expr_well_formed e
    | Statement.seq s1 s2 => stmt_well_formed s1 âˆ§ stmt_well_formed s2
    | Statement.if e s1 s2 => 
      expr_well_formed e âˆ§ stmt_well_formed s1 âˆ§ stmt_well_formed s2
end
```
