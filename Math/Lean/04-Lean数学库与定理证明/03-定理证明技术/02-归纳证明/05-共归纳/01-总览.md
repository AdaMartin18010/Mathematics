# å…±å½’çº³ | Coinduction

## æ¦‚å¿µå®šä¹‰ | Concept Definition

### æ ¸å¿ƒæ¦‚å¿µ | Core Concepts

- **å…±å½’çº³ (Coinduction)**: å¤„ç†æ— é™æ•°æ®ç»“æ„çš„å½’çº³æ–¹æ³•
- **å…±å½’çº³ç±»å‹ (Coinductive Types)**: å¯ä»¥è¡¨ç¤ºæ— é™æ•°æ®çš„ç±»å‹
- **å…±é€’å½’å‡½æ•° (Corecursive Functions)**: ç”Ÿæˆæ— é™æ•°æ®çš„å‡½æ•°
- **åŒæ¨¡æ‹Ÿ (Bisimulation)**: å…±å½’çº³è¯æ˜ä¸­çš„ç­‰ä»·å…³ç³»
- **å®ˆå«é€’å½’ (Guarded Recursion)**: ç¡®ä¿å…±é€’å½’ç»ˆæ­¢çš„æ¡ä»¶

### æƒå¨æ¥æº | Authoritative Sources

- **Aczel, P. (1988)**: "Non-Well-Founded Sets"
- **GimÃ©nez, E. (1995)**: "Codifying Guarded Definitions with Recursive Schemes"
- **Leanå®˜æ–¹æ–‡æ¡£**: å…±å½’çº³å®ç°

## ç†è®ºå†å²ä¸ä»£è¡¨äººç‰© | Theoretical History and Key Figures

### å†å²å‘å±• | Historical Development

1. **1980å¹´ä»£**: å…±å½’çº³æ¦‚å¿µæå‡º
2. **1990å¹´ä»£**: å…±å½’çº³ç±»å‹ç†è®ºå‘å±•
3. **2000å¹´ä»£**: å½¢å¼åŒ–å…±å½’çº³ç³»ç»Ÿ
4. **2010å¹´ä»£**: è‡ªåŠ¨åŒ–å…±å½’çº³å·¥å…·

### ä»£è¡¨äººç‰© | Key Figures

- **Peter Aczel**: éè‰¯åŸºé›†åˆè®º
- **Eduardo GimÃ©nez**: å®ˆå«é€’å½’ç†è®º
- **Leanå¼€å‘å›¢é˜Ÿ**: å…±å½’çº³å®ç°

## ç°ä»£å‘å±•ä¸å‰æ²¿æŒ‘æˆ˜ | Modern Development and Frontier Challenges

### å½“å‰å‘å±• | Current Development

1. **è‡ªåŠ¨åŒ–å…±å½’çº³**: è‡ªåŠ¨ç”Ÿæˆå…±å½’çº³åŸç†
2. **é«˜é˜¶å…±å½’çº³**: é«˜é˜¶å…±å½’çº³ç±»å‹
3. **åµŒå¥—å…±å½’çº³**: åµŒå¥—çš„å…±å½’çº³ç»“æ„

### å‰æ²¿æŒ‘æˆ˜ | Frontier Challenges

1. **æ— é™å…±å½’çº³**: æ— é™å…±å½’çº³ç»“æ„
2. **é‡å­å…±å½’çº³**: é‡å­è®¡ç®—ä¸­çš„å…±å½’çº³
3. **AIå…±å½’çº³**: äººå·¥æ™ºèƒ½ä¸­çš„å…±å½’çº³

## è·¨å­¦ç§‘å½±å“ä¸æœªæ¥å±•æœ› | Cross-disciplinary Impact and Future Prospects

### è·¨å­¦ç§‘å½±å“ | Cross-disciplinary Impact

- **è®¡ç®—æœºç§‘å­¦**: å‡½æ•°å¼ç¼–ç¨‹ç†è®º
- **æ•°å­¦**: æ— é™ç»“æ„ç†è®º
- **é€»è¾‘å­¦**: æ„é€ é€»è¾‘ç†è®º

### æœªæ¥å±•æœ› | Future Prospects

1. **æ™ºèƒ½åŒ–å…±å½’çº³**: AIè¾…åŠ©çš„å…±å½’çº³
2. **è‡ªé€‚åº”å…±å½’çº³**: è‡ªé€‚åº”å…±å½’çº³ç­–ç•¥
3. **é‡å­å…±å½’çº³**: é‡å­è®¡ç®—ä¸­çš„å…±å½’çº³

## ç›¸å…³æ€§ä¸æœ¬åœ°è·³è½¬ | Relevance and Local Navigation

### ç›¸å…³ä¸»é¢˜ | Related Topics

- [å½’çº³è¯æ˜](../01-æ€»è§ˆ.md)
- [å®šç†è¯æ˜æŠ€æœ¯](../../01-æ€»è§ˆ.md)
- [Leanæ•°å­¦åº“ä¸å®šç†è¯æ˜](../../../01-æ€»è§ˆ.md)

### æœ¬åœ°è·³è½¬ | Local Navigation

- [ä¸Šä¸€çº§ï¼šå½’çº³è¯æ˜](../01-æ€»è§ˆ.md)
- [ä¸‹ä¸€çº§ï¼šå…±å½’çº³ç±»å‹](02-å…±å½’çº³ç±»å‹/01-æ€»è§ˆ.md)

## è¿›åº¦æ—¥å¿—ä¸æ–­ç‚¹æ ‡è®° | Progress Log and Checkpoint Markers

### å½“å‰è¿›åº¦ | Current Progress

- âœ… åˆ›å»ºå…±å½’çº³æ€»è§ˆ
- ğŸ”„ åˆ›å»ºå…±å½’çº³ç±»å‹å­ç›®å½•
- ğŸ”„ åˆ›å»ºå…±é€’å½’å‡½æ•°å­ç›®å½•
- ğŸ”„ åˆ›å»ºåŒæ¨¡æ‹Ÿè¯æ˜å­ç›®å½•

### æ–­ç‚¹æ ‡è®° | Checkpoint Markers

- **æ£€æŸ¥ç‚¹1**: å…±å½’çº³åŸºç¡€æ¦‚å¿µå®Œæˆ
- **æ£€æŸ¥ç‚¹2**: å…±å½’çº³ç±»å‹å®Œæˆ
- **æ£€æŸ¥ç‚¹3**: å…±é€’å½’å‡½æ•°å®Œæˆ

## ä»£ç ç¤ºä¾‹ | Code Examples

### å…±å½’çº³ç¤ºä¾‹ | Coinduction Examples

```lean
-- å…±å½’çº³ç±»å‹ï¼šæ— é™æµ
codata Stream (Î± : Type) where
  head : Stream Î± â†’ Î±
  tail : Stream Î± â†’ Stream Î±

-- å…±é€’å½’å‡½æ•°ï¼šç”Ÿæˆæ— é™æµ
def constantStream (x : Î±) : Stream Î± :=
  Stream.mk x (constantStream x)

-- åŒæ¨¡æ‹Ÿå…³ç³»
def bisimilar {Î± : Type} (s1 s2 : Stream Î±) : Prop :=
  head s1 = head s2 âˆ§ bisimilar (tail s1) (tail s2)

-- å…±å½’çº³è¯æ˜ï¼šåŒæ¨¡æ‹Ÿçš„ç­‰ä»·æ€§
theorem bisimilar_equivalence {Î± : Type} : 
  Equivalence (@bisimilar Î±) := by
  constructor
  Â· intro s -- è‡ªåæ€§
    constructor
    Â· simp [bisimilar]
    Â· exact bisimilar_equivalence.1 (tail s)
  Â· intro s1 s2 h -- å¯¹ç§°æ€§
    constructor
    Â· simp [bisimilar, h.1]
    Â· exact bisimilar_equivalence.2 (tail s1) (tail s2) h.2
  Â· intro s1 s2 s3 h12 h23 -- ä¼ é€’æ€§
    constructor
    Â· simp [bisimilar, h12.1, h23.1]
    Â· exact bisimilar_equivalence.3 (tail s1) (tail s2) (tail s3) h12.2 h23.2
```

### å¤æ‚å…±å½’çº³ç¤ºä¾‹ | Complex Coinduction Examples

```lean
-- æ— é™äºŒå‰æ ‘
codata InfiniteTree (Î± : Type) where
  value : InfiniteTree Î± â†’ Î±
  left : InfiniteTree Î± â†’ InfiniteTree Î±
  right : InfiniteTree Î± â†’ InfiniteTree Î±

-- ç”Ÿæˆæ— é™äºŒå‰æ ‘
def infiniteTree (x : Î±) : InfiniteTree Î± :=
  InfiniteTree.mk x (infiniteTree x) (infiniteTree x)

-- æ ‘çš„éå†
def treeToList {Î± : Type} : InfiniteTree Î± â†’ Stream Î± :=
  Stream.mk (value t) (treeToList (left t))
```
