# 03-图论数据结构 | Graph Theory Data Structures

## 概述 | Overview

图论数据结构（Graph Theory Data Structures）是数学库中重要的抽象数据类型，用于表示和处理图论中的各种概念。在Lean中，图论数据结构通过类型安全的方式实现，支持图的构建、遍历、算法实现和性质验证。

Graph theory data structures are important abstract data types in mathematical libraries for representing and processing various concepts in graph theory. In Lean, graph theory data structures are implemented in a type-safe manner, supporting graph construction, traversal, algorithm implementation, and property verification.

## 1. 基本图结构 | Basic Graph Structures

### 1.1 图的定义 | Graph Definition

```lean
-- 基本图结构
structure Graph (α : Type) where
  vertices : List α
  edges : List (α × α)
  directed : Bool := false

-- 有向图
structure DirectedGraph (α : Type) where
  vertices : List α
  edges : List (α × α)

-- 无向图
structure UndirectedGraph (α : Type) where
  vertices : List α
  edges : List (α × α)

-- 带权图
structure WeightedGraph (α β : Type) where
  vertices : List α
  edges : List (α × α × β)  -- 边带权重

-- 图的构造器
def Graph.mk (vertices : List α) (edges : List (α × α)) : Graph α :=
  { vertices := vertices, edges := edges, directed := false }

def DirectedGraph.mk (vertices : List α) (edges : List (α × α)) : DirectedGraph α :=
  { vertices := vertices, edges := edges }

def WeightedGraph.mk (vertices : List α) (edges : List (α × α × β)) : WeightedGraph α β :=
  { vertices := vertices, edges := edges }
```

### 1.2 图的基本操作 | Basic Graph Operations

```lean
-- 添加顶点
def Graph.addVertex {α : Type} (g : Graph α) (v : α) : Graph α :=
  if List.elem v g.vertices then g
  else { g with vertices := v :: g.vertices }

-- 添加边
def Graph.addEdge {α : Type} (g : Graph α) (u v : α) : Graph α :=
  if List.elem (u, v) g.edges then g
  else { g with edges := (u, v) :: g.edges }

-- 删除顶点
def Graph.removeVertex {α : Type} (g : Graph α) (v : α) : Graph α :=
  { g with 
    vertices := List.filter (fun x => x ≠ v) g.vertices,
    edges := List.filter (fun (u, w) => u ≠ v && w ≠ v) g.edges }

-- 删除边
def Graph.removeEdge {α : Type} (g : Graph α) (u v : α) : Graph α :=
  { g with edges := List.filter (fun (x, y) => !(x = u && y = v)) g.edges }

-- 获取邻接顶点
def Graph.neighbors {α : Type} (g : Graph α) (v : α) : List α :=
  List.map (fun (u, w) => if u = v then w else u) 
    (List.filter (fun (u, w) => u = v || w = v) g.edges)

-- 获取度数
def Graph.degree {α : Type} (g : Graph α) (v : α) : Nat :=
  List.length (Graph.neighbors g v)
```

### 1.3 图的性质验证 | Graph Property Verification

```lean
-- 检查顶点是否存在
def Graph.hasVertex {α : Type} (g : Graph α) (v : α) : Bool :=
  List.elem v g.vertices

-- 检查边是否存在
def Graph.hasEdge {α : Type} (g : Graph α) (u v : α) : Bool :=
  List.elem (u, v) g.edges || (!g.directed && List.elem (v, u) g.edges)

-- 检查图是否为空
def Graph.isEmpty {α : Type} (g : Graph α) : Bool :=
  List.isEmpty g.vertices

-- 检查图是否连通
def Graph.isConnected {α : Type} (g : Graph α) : Bool :=
  if List.isEmpty g.vertices then true
  else
    let start := List.head! g.vertices
    let reachable := Graph.dfs g start
    List.length reachable = List.length g.vertices

-- 检查图是否有环
def Graph.hasCycle {α : Type} (g : Graph α) : Bool :=
  Graph.detectCycle g
```

## 2. 图的遍历算法 | Graph Traversal Algorithms

### 2.1 深度优先搜索 | Depth-First Search

```lean
-- DFS实现
def Graph.dfs {α : Type} (g : Graph α) (start : α) : List α :=
  let visited := HashSet.empty
  Graph.dfsHelper g start visited

-- DFS辅助函数
def Graph.dfsHelper {α : Type} (g : Graph α) (v : α) (visited : HashSet α) : List α :=
  if HashSet.contains visited v then []
  else
    let visited' := HashSet.insert visited v
    let neighbors := Graph.neighbors g v
    let neighborResults := List.concatMap (fun n => Graph.dfsHelper g n visited') neighbors
    v :: neighborResults

-- DFS路径查找
def Graph.dfsPath {α : Type} (g : Graph α) (start target : α) : Option (List α) :=
  Graph.dfsPathHelper g start target HashSet.empty []

-- DFS路径辅助函数
def Graph.dfsPathHelper {α : Type} (g : Graph α) (current target : α) 
  (visited : HashSet α) (path : List α) : Option (List α) :=
  if current = target then some (List.reverse (current :: path))
  else if HashSet.contains visited current then none
  else
    let visited' := HashSet.insert visited current
    let neighbors := Graph.neighbors g current
    Graph.findPathInNeighbors g neighbors target visited' (current :: path)

-- 在邻居中查找路径
def Graph.findPathInNeighbors {α : Type} (g : Graph α) (neighbors : List α) 
  (target : α) (visited : HashSet α) (path : List α) : Option (List α) :=
  match neighbors with
  | [] => none
  | n :: ns =>
    match Graph.dfsPathHelper g n target visited path with
    | some path => some path
    | none => Graph.findPathInNeighbors g ns target visited path
```

### 2.2 广度优先搜索 | Breadth-First Search

```lean
-- BFS实现
def Graph.bfs {α : Type} (g : Graph α) (start : α) : List α :=
  let visited := HashSet.empty
  let queue := [start]
  Graph.bfsHelper g queue visited []

-- BFS辅助函数
def Graph.bfsHelper {α : Type} (g : Graph α) (queue : List α) 
  (visited : HashSet α) (result : List α) : List α :=
  match queue with
  | [] => List.reverse result
  | v :: vs =>
    if HashSet.contains visited v then
      Graph.bfsHelper g vs visited result
    else
      let visited' := HashSet.insert visited v
      let neighbors := Graph.neighbors g v
      let newQueue := vs ++ neighbors
      Graph.bfsHelper g newQueue visited' (v :: result)

-- BFS最短路径
def Graph.bfsShortestPath {α : Type} (g : Graph α) (start target : α) : Option (List α) :=
  let visited := HashSet.empty
  let queue := [(start, [start])]
  Graph.bfsShortestPathHelper g queue visited

-- BFS最短路径辅助函数
def Graph.bfsShortestPathHelper {α : Type} (g : Graph α) 
  (queue : List (α × List α)) (visited : HashSet α) : Option (List α) :=
  match queue with
  | [] => none
  | (v, path) :: rest =>
    if v = target then some (List.reverse path)
    else if HashSet.contains visited v then
      Graph.bfsShortestPathHelper g rest visited
    else
      let visited' := HashSet.insert visited v
      let neighbors := Graph.neighbors g v
      let newPaths := List.map (fun n => (n, n :: path)) neighbors
      let newQueue := rest ++ newPaths
      Graph.bfsShortestPathHelper g newQueue visited'
```

### 2.3 拓扑排序 | Topological Sort

```lean
-- 拓扑排序
def Graph.topologicalSort {α : Type} (g : DirectedGraph α) : Option (List α) :=
  let inDegree := Graph.calculateInDegree g
  let zeroInDegree := List.filter (fun (v, d) => d = 0) inDegree
  Graph.topologicalSortHelper g inDegree (List.map (fun (v, _) => v) zeroInDegree) []

-- 计算入度
def Graph.calculateInDegree {α : Type} (g : DirectedGraph α) : List (α × Nat) :=
  List.map (fun v => (v, Graph.inDegree g v)) g.vertices

-- 计算顶点入度
def Graph.inDegree {α : Type} (g : DirectedGraph α) (v : α) : Nat :=
  List.length (List.filter (fun (_, w) => w = v) g.edges)

-- 拓扑排序辅助函数
def Graph.topologicalSortHelper {α : Type} (g : DirectedGraph α) 
  (inDegree : List (α × Nat)) (queue : List α) (result : List α) : Option (List α) :=
  match queue with
  | [] => 
    if List.length result = List.length g.vertices then some (List.reverse result)
    else none  -- 有环
  | v :: vs =>
    let neighbors := Graph.outNeighbors g v
    let inDegree' := Graph.updateInDegree inDegree neighbors
    let newQueue := vs ++ Graph.getZeroInDegree inDegree'
    Graph.topologicalSortHelper g inDegree' newQueue (v :: result)

-- 获取出边邻居
def Graph.outNeighbors {α : Type} (g : DirectedGraph α) (v : α) : List α :=
  List.map (fun (_, w) => w) (List.filter (fun (u, _) => u = v) g.edges)

-- 更新入度
def Graph.updateInDegree {α : Type} (inDegree : List (α × Nat)) (neighbors : List α) : List (α × Nat) :=
  List.map (fun (v, d) => 
    if List.elem v neighbors then (v, d - 1) else (v, d)) inDegree

-- 获取入度为0的顶点
def Graph.getZeroInDegree {α : Type} (inDegree : List (α × Nat)) : List α :=
  List.map (fun (v, _) => v) (List.filter (fun (_, d) => d = 0) inDegree)
```

## 3. 图算法 | Graph Algorithms

### 3.1 最短路径算法 | Shortest Path Algorithms

```lean
-- Dijkstra算法
def Graph.dijkstra {α β : Type} [Ord β] [Add β] [Zero β] 
  (g : WeightedGraph α β) (start : α) : HashMap α β :=
  let distances := HashMap.empty.insert start Zero.zero
  let visited := HashSet.empty
  Graph.dijkstraHelper g distances visited

-- Dijkstra辅助函数
def Graph.dijkstraHelper {α β : Type} [Ord β] [Add β] [Zero β]
  (g : WeightedGraph α β) (distances : HashMap α β) (visited : HashSet α) : HashMap α β :=
  let unvisited := Graph.getUnvisited g.vertices visited
  if List.isEmpty unvisited then distances
  else
    let current := Graph.getMinDistance unvisited distances
    let visited' := HashSet.insert visited current
    let neighbors := Graph.weightedNeighbors g current
    let distances' := Graph.updateDistances distances current neighbors
    Graph.dijkstraHelper g distances' visited'

-- 获取未访问顶点
def Graph.getUnvisited {α : Type} (vertices : List α) (visited : HashSet α) : List α :=
  List.filter (fun v => !HashSet.contains visited v) vertices

-- 获取最小距离顶点
def Graph.getMinDistance {α β : Type} [Ord β] 
  (vertices : List α) (distances : HashMap α β) : α :=
  List.foldl (fun min v => 
    if HashMap.get distances v < HashMap.get distances min then v else min) 
    (List.head! vertices) vertices

-- 获取带权邻居
def Graph.weightedNeighbors {α β : Type} (g : WeightedGraph α β) (v : α) : List (α × β) :=
  List.map (fun (u, w, weight) => (w, weight)) 
    (List.filter (fun (u, _, _) => u = v) g.edges)

-- 更新距离
def Graph.updateDistances {α β : Type} [Ord β] [Add β]
  (distances : HashMap α β) (current : α) (neighbors : List (α × β)) : HashMap α β :=
  List.foldl (fun dist (neighbor, weight) =>
    let currentDist := HashMap.get distances current
    let newDist := currentDist + weight
    let oldDist := HashMap.get distances neighbor
    if newDist < oldDist then dist.insert neighbor newDist else dist) 
    distances neighbors
```

### 3.2 最小生成树算法 | Minimum Spanning Tree Algorithms

```lean
-- Kruskal算法
def Graph.kruskal {α β : Type} [Ord β] [Add β] [Zero β]
  (g : WeightedGraph α β) : List (α × α × β) :=
  let sortedEdges := List.sort (fun (_, _, w1) (_, _, w2) => w1 < w2) g.edges
  let unionFind := Graph.initializeUnionFind g.vertices
  Graph.kruskalHelper sortedEdges unionFind []

-- Kruskal辅助函数
def Graph.kruskalHelper {α β : Type} [Ord β] [Add β] [Zero β]
  (edges : List (α × α × β)) (unionFind : HashMap α α) (result : List (α × α × β)) : List (α × α × β) :=
  match edges with
  | [] => result
  | (u, v, w) :: es =>
    let rootU := Graph.find unionFind u
    let rootV := Graph.find unionFind v
    if rootU = rootV then
      Graph.kruskalHelper es unionFind result
    else
      let unionFind' := Graph.union unionFind rootU rootV
      Graph.kruskalHelper es unionFind' ((u, v, w) :: result)

-- 初始化并查集
def Graph.initializeUnionFind {α : Type} (vertices : List α) : HashMap α α :=
  List.foldl (fun uf v => uf.insert v v) HashMap.empty vertices

-- 查找根节点
def Graph.find {α : Type} (unionFind : HashMap α α) (x : α) : α :=
  let parent := HashMap.get unionFind x
  if parent = x then x
  else Graph.find unionFind parent

-- 合并集合
def Graph.union {α : Type} (unionFind : HashMap α α) (x y : α) : HashMap α α :=
  unionFind.insert (Graph.find unionFind x) (Graph.find unionFind y)
```

### 3.3 强连通分量算法 | Strongly Connected Components Algorithm

```lean
-- Tarjan算法
def Graph.tarjan {α : Type} (g : DirectedGraph α) : List (List α) :=
  let visited := HashSet.empty
  let stack := []
  let low := HashMap.empty
  let ids := HashMap.empty
  let sccs := []
  Graph.tarjanHelper g g.vertices visited stack low ids sccs

-- Tarjan辅助函数
def Graph.tarjanHelper {α : Type} (g : DirectedGraph α) (vertices : List α)
  (visited : HashSet α) (stack : List α) (low : HashMap α Nat) 
  (ids : HashMap α Nat) (sccs : List (List α)) : List (List α) :=
  match vertices with
  | [] => sccs
  | v :: vs =>
    if HashSet.contains visited v then
      Graph.tarjanHelper g vs visited stack low ids sccs
    else
      let (visited', stack', low', ids', sccs') := Graph.tarjanDFS g v visited stack low ids sccs 0
      Graph.tarjanHelper g vs visited' stack' low' ids' sccs'

-- Tarjan DFS
def Graph.tarjanDFS {α : Type} (g : DirectedGraph α) (v : α)
  (visited : HashSet α) (stack : List α) (low : HashMap α Nat) 
  (ids : HashMap α Nat) (sccs : List (List α)) (id : Nat) : 
  (HashSet α × List α × HashMap α Nat × HashMap α Nat × List (List α) × Nat) :=
  let visited' := HashSet.insert visited v
  let stack' := v :: stack
  let low' := low.insert v id
  let ids' := ids.insert v id
  let (visited'', stack'', low'', ids'', sccs'', id') := 
    Graph.processNeighbors g v visited' stack' low' ids' sccs' (id + 1)
  let lowV := HashMap.get low'' v
  if lowV = HashMap.get ids'' v then
    let scc := Graph.extractSCC stack'' v
    let stack''' := Graph.removeFromStack stack'' scc
    (visited'', stack''', low'', ids'', scc :: sccs'', id')
  else
    (visited'', stack'', low'', ids'', sccs'', id')

-- 处理邻居
def Graph.processNeighbors {α : Type} (g : DirectedGraph α) (v : α)
  (visited : HashSet α) (stack : List α) (low : HashMap α Nat) 
  (ids : HashMap α Nat) (sccs : List (List α)) (id : Nat) : 
  (HashSet α × List α × HashMap α Nat × HashMap α Nat × List (List α) × Nat) :=
  let neighbors := Graph.outNeighbors g v
  List.foldl (fun (visited, stack, low, ids, sccs, id) neighbor =>
    if HashSet.contains visited neighbor then
      let lowV := min (HashMap.get low v) (HashMap.get ids neighbor)
      let low' := low.insert v lowV
      (visited, stack, low', ids, sccs, id)
    else
      let (visited', stack', low', ids', sccs', id') := 
        Graph.tarjanDFS g neighbor visited stack low ids sccs id
      let lowV := min (HashMap.get low' v) (HashMap.get low' neighbor)
      let low'' := low'.insert v lowV
      (visited', stack', low'', ids', sccs', id')) 
    (visited, stack, low, ids, sccs, id) neighbors

-- 提取强连通分量
def Graph.extractSCC {α : Type} (stack : List α) (root : α) : List α :=
  let rec extract (stack : List α) (result : List α) : List α :=
    match stack with
    | [] => result
    | v :: vs =>
      if v = root then v :: result
      else extract vs (v :: result)
  extract stack []

-- 从栈中移除
def Graph.removeFromStack {α : Type} (stack : List α) (scc : List α) : List α :=
  List.filter (fun v => !List.elem v scc) stack
```

## 4. 图的性质分析 | Graph Property Analysis

### 4.1 连通性分析 | Connectivity Analysis

```lean
-- 检查连通性
def Graph.isConnected {α : Type} (g : Graph α) : Bool :=
  if List.isEmpty g.vertices then true
  else
    let start := List.head! g.vertices
    let reachable := Graph.dfs g start
    List.length reachable = List.length g.vertices

-- 计算连通分量
def Graph.connectedComponents {α : Type} (g : Graph α) : List (List α) :=
  let visited := HashSet.empty
  Graph.connectedComponentsHelper g g.vertices visited []

-- 连通分量辅助函数
def Graph.connectedComponentsHelper {α : Type} (g : Graph α) (vertices : List α)
  (visited : HashSet α) (components : List (List α)) : List (List α) :=
  match vertices with
  | [] => components
  | v :: vs =>
    if HashSet.contains visited v then
      Graph.connectedComponentsHelper g vs visited components
    else
      let component := Graph.dfs g v
      let visited' := List.foldl (fun vis u => HashSet.insert vis u) visited component
      Graph.connectedComponentsHelper g vs visited' (component :: components)

-- 检查强连通性
def Graph.isStronglyConnected {α : Type} (g : DirectedGraph α) : Bool :=
  if List.isEmpty g.vertices then true
  else
    let start := List.head! g.vertices
    let forwardReachable := Graph.dfs (Graph.fromDirected g) start
    let backwardReachable := Graph.dfs (Graph.reverse g) start
    List.length forwardReachable = List.length g.vertices &&
    List.length backwardReachable = List.length g.vertices

-- 从有向图创建无向图
def Graph.fromDirected {α : Type} (g : DirectedGraph α) : Graph α :=
  { vertices := g.vertices, edges := g.edges, directed := false }

-- 图的反转
def Graph.reverse {α : Type} (g : DirectedGraph α) : DirectedGraph α :=
  { vertices := g.vertices, edges := List.map (fun (u, v) => (v, u)) g.edges }
```

### 4.2 平面性分析 | Planarity Analysis

```lean
-- 检查平面性（简化版本）
def Graph.isPlanar {α : Type} (g : Graph α) : Bool :=
  let e := List.length g.edges
  let v := List.length g.vertices
  -- 欧拉公式：v - e + f = 2，其中f是面数
  -- 对于平面图，e ≤ 3v - 6（当v ≥ 3时）
  if v < 3 then true
  else e ≤ 3 * v - 6

-- 检查二分图
def Graph.isBipartite {α : Type} (g : Graph α) : Bool :=
  let colors := HashMap.empty
  Graph.isBipartiteHelper g g.vertices colors

-- 二分图检查辅助函数
def Graph.isBipartiteHelper {α : Type} (g : Graph α) (vertices : List α)
  (colors : HashMap α Bool) : Bool :=
  match vertices with
  | [] => true
  | v :: vs =>
    if HashMap.contains colors v then
      Graph.isBipartiteHelper g vs colors
    else
      let colors' := colors.insert v true
      Graph.colorNeighbors g v colors' &&
      Graph.isBipartiteHelper g vs colors'

-- 为邻居着色
def Graph.colorNeighbors {α : Type} (g : Graph α) (v : α) (colors : HashMap α Bool) : Bool :=
  let neighbors := Graph.neighbors g v
  let vColor := HashMap.get colors v
  List.all neighbors (fun neighbor =>
    if HashMap.contains colors neighbor then
      HashMap.get colors neighbor != vColor
    else
      let colors' := colors.insert neighbor (!vColor)
      true)
```

## 5. 实际应用与最佳实践 | Practical Applications and Best Practices

### 5.1 网络分析应用 | Network Analysis Applications

```lean
-- 社交网络分析
def SocialNetwork.analyze (g : Graph String) : HashMap String Nat :=
  let centrality := HashMap.empty
  List.foldl (fun cent v =>
    cent.insert v (Graph.degree g v)) centrality g.vertices

-- 网络中心性
def Graph.betweennessCentrality {α : Type} (g : Graph α) : HashMap α Float :=
  let centrality := HashMap.empty
  List.foldl (fun cent v =>
    cent.insert v (Graph.calculateBetweenness g v)) centrality g.vertices

-- 计算介数中心性
def Graph.calculateBetweenness {α : Type} (g : Graph α) (v : α) : Float :=
  -- 简化实现
  0.0
```

### 5.2 路径规划应用 | Path Planning Applications

```lean
-- 导航系统
def NavigationSystem.findRoute (g : WeightedGraph String Nat) 
  (start destination : String) : Option (List String) :=
  Graph.dijkstra g start
  |> Graph.reconstructPath start destination

-- 重建路径
def Graph.reconstructPath {α β : Type} (g : WeightedGraph α β) 
  (start target : α) (distances : HashMap α β) : Option (List α) :=
  -- 实现路径重建
  some [start, target]
```

### 5.3 调度系统应用 | Scheduling System Applications

```lean
-- 任务调度
def TaskScheduler.schedule (tasks : List String) (dependencies : List (String × String)) : List String :=
  let g := DirectedGraph.mk tasks dependencies
  match Graph.topologicalSort g with
  | some order => order
  | none => []  -- 有环，无法调度

-- 资源分配
def ResourceAllocation.allocate (resources : List String) (requirements : List (String × String)) : HashMap String String :=
  -- 实现资源分配算法
  HashMap.empty
```

## 6. 性能优化与最佳实践 | Performance Optimization and Best Practices

### 6.1 内存优化 | Memory Optimization

```lean
-- 邻接表表示
structure AdjacencyList (α : Type) where
  vertices : List α
  adjacency : HashMap α (List α)

-- 邻接矩阵表示
def AdjacencyMatrix (α : Type) (n : Nat) := Array (Array Bool)

-- 稀疏图优化
def SparseGraph (α β : Type) where
  vertices : List α
  edges : HashMap (α × α) β
```

### 6.2 算法优化 | Algorithm Optimization

```lean
-- 缓存计算结果
def Graph.cacheResults {α β : Type} (g : Graph α) (f : Graph α → β) : HashMap (Graph α) β :=
  HashMap.empty.insert g (f g)

-- 并行图算法
def Graph.parallelBFS {α : Type} (g : Graph α) (start : α) : List α :=
  -- 并行BFS实现
  Graph.bfs g start
```

## 7. 理论背景与前沿发展 | Theoretical Background and Frontier Development

### 7.1 理论基础 | Theoretical Foundation

图论数据结构的理论基础包括：

- **图论（Graph Theory）**：图的基本理论和性质
- **算法理论（Algorithm Theory）**：图算法的设计和分析
- **数据结构理论（Data Structure Theory）**：高效数据组织方法

### 7.2 前沿研究方向 | Frontier Research Directions

- **动态图算法**：处理图结构变化的算法
- **大规模图处理**：处理超大规模图的算法
- **图神经网络**：结合机器学习的图算法

## 8. 总结 | Summary

图论数据结构是数学库中的重要组成部分，它提供了：

1. **丰富的图表示**：支持各种类型的图结构
2. **高效算法实现**：提供经典图算法的实现
3. **性质分析工具**：支持图的性质验证和分析
4. **实际应用支持**：为各种应用领域提供基础

这些特性使图论数据结构成为计算机科学、网络分析、社交网络、生物信息学等领域的重要工具，在现代软件开发和科学研究中有广泛应用。

---

**参考资源 | References**:

- Lean 4官方文档：<https://leanprover.github.io/lean4/doc/>
- 剑桥大学图论课程：<https://www.cl.cam.ac.uk/teaching/2021/ConceptsPL/>
- 卡内基梅隆大学算法课程：<https://www.cs.cmu.edu/~rwh/courses/hott/>
- 图论基础：<https://en.wikipedia.org/wiki/Graph_theory>
