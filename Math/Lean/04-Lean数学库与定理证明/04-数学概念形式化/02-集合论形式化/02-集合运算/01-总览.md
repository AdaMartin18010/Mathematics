# é›†åˆè¿ç®— | Set Operations

## æ¦‚å¿µå®šä¹‰ | Concept Definition

### æ ¸å¿ƒæ¦‚å¿µ | Core Concepts

- **é›†åˆè¿ç®— (Set Operations)**: å¯¹é›†åˆè¿›è¡Œçš„åŸºæœ¬æ•°å­¦è¿ç®—
- **å¹¶é›† (Union)**: ä¸¤ä¸ªé›†åˆä¸­æ‰€æœ‰å…ƒç´ çš„é›†åˆ
- **äº¤é›† (Intersection)**: ä¸¤ä¸ªé›†åˆä¸­å…±åŒå…ƒç´ çš„é›†åˆ
- **å·®é›† (Difference)**: ä¸€ä¸ªé›†åˆä¸­ä¸å±äºå¦ä¸€ä¸ªé›†åˆçš„å…ƒç´ 
- **è¡¥é›† (Complement)**: å…¨é›†ä¸­ä¸å±äºç»™å®šé›†åˆçš„å…ƒç´ 

### æƒå¨æ¥æº | Authoritative Sources

- **Cantor, G. (1874)**: "Ãœber eine Eigenschaft des Inbegriffes aller reellen algebraischen Zahlen"
- **Zermelo, E. (1908)**: "Untersuchungen Ã¼ber die Grundlagen der Mengenlehre"
- **Leanå®˜æ–¹æ–‡æ¡£**: é›†åˆè®ºå½¢å¼åŒ–

## ç†è®ºå†å²ä¸ä»£è¡¨äººç‰© | Theoretical History and Key Figures

### å†å²å‘å±• | Historical Development

1. **19ä¸–çºª**: åº·æ‰˜å°”åˆ›ç«‹é›†åˆè®º
2. **20ä¸–çºªåˆ**: ç­–æ¢…æ´›å…¬ç†åŒ–é›†åˆè®º
3. **20ä¸–çºªä¸­æœŸ**: å½¢å¼åŒ–é›†åˆè®ºå‘å±•
4. **21ä¸–çºª**: è®¡ç®—æœºè¾…åŠ©é›†åˆè®º

### ä»£è¡¨äººç‰© | Key Figures

- **Georg Cantor**: é›†åˆè®ºåˆ›å§‹äºº
- **Ernst Zermelo**: ç­–æ¢…æ´›å…¬ç†ç³»ç»Ÿ
- **Leanå¼€å‘å›¢é˜Ÿ**: é›†åˆè®ºå½¢å¼åŒ–

## ç°ä»£å‘å±•ä¸å‰æ²¿æŒ‘æˆ˜ | Modern Development and Frontier Challenges

### å½“å‰å‘å±• | Current Development

1. **å½¢å¼åŒ–é›†åˆè®º**: è®¡ç®—æœºè¾…åŠ©çš„é›†åˆè®ºè¯æ˜
2. **æ„é€ æ€§é›†åˆè®º**: åŸºäºæ„é€ é€»è¾‘çš„é›†åˆè®º
3. **é«˜é˜¶é›†åˆè®º**: é«˜é˜¶é€»è¾‘ä¸­çš„é›†åˆè®º

### å‰æ²¿æŒ‘æˆ˜ | Frontier Challenges

1. **æ— é™é›†åˆè¿ç®—**: æ— é™é›†åˆçš„è¿ç®—æ€§è´¨
2. **é‡å­é›†åˆè®º**: é‡å­è®¡ç®—ä¸­çš„é›†åˆè®º
3. **AIé›†åˆè®º**: äººå·¥æ™ºèƒ½ä¸­çš„é›†åˆè®º

## è·¨å­¦ç§‘å½±å“ä¸æœªæ¥å±•æœ› | Cross-disciplinary Impact and Future Prospects

### è·¨å­¦ç§‘å½±å“ | Cross-disciplinary Impact

- **æ•°å­¦**: åŸºç¡€æ•°å­¦ç†è®º
- **è®¡ç®—æœºç§‘å­¦**: æ•°æ®ç»“æ„ç†è®º
- **é€»è¾‘å­¦**: å½¢å¼åŒ–é€»è¾‘ç†è®º

### æœªæ¥å±•æœ› | Future Prospects

1. **æ™ºèƒ½åŒ–é›†åˆè¿ç®—**: AIè¾…åŠ©çš„é›†åˆè¿ç®—
2. **è‡ªé€‚åº”é›†åˆè®º**: è‡ªé€‚åº”é›†åˆè®ºç³»ç»Ÿ
3. **é‡å­é›†åˆè®º**: é‡å­è®¡ç®—ä¸­çš„é›†åˆè®º

## ç›¸å…³æ€§ä¸æœ¬åœ°è·³è½¬ | Relevance and Local Navigation

### ç›¸å…³ä¸»é¢˜ | Related Topics

- [é›†åˆè®ºå½¢å¼åŒ–](../01-æ€»è§ˆ.md)
- [æ•°å­¦æ¦‚å¿µå½¢å¼åŒ–](../../01-æ€»è§ˆ.md)
- [Leanæ•°å­¦åº“ä¸å®šç†è¯æ˜](../../../01-æ€»è§ˆ.md)

### æœ¬åœ°è·³è½¬ | Local Navigation

- [ä¸Šä¸€çº§ï¼šé›†åˆè®ºå½¢å¼åŒ–](../01-æ€»è§ˆ.md)
- [ä¸‹ä¸€çº§ï¼šå¹¶é›†è¿ç®—](02-å¹¶é›†è¿ç®—/01-æ€»è§ˆ.md)

## è¿›åº¦æ—¥å¿—ä¸æ–­ç‚¹æ ‡è®° | Progress Log and Checkpoint Markers

### å½“å‰è¿›åº¦ | Current Progress

- âœ… åˆ›å»ºé›†åˆè¿ç®—æ€»è§ˆ
- ğŸ”„ åˆ›å»ºå¹¶é›†è¿ç®—å­ç›®å½•
- ğŸ”„ åˆ›å»ºäº¤é›†è¿ç®—å­ç›®å½•
- ğŸ”„ åˆ›å»ºå·®é›†è¿ç®—å­ç›®å½•

### æ–­ç‚¹æ ‡è®° | Checkpoint Markers

- **æ£€æŸ¥ç‚¹1**: é›†åˆè¿ç®—åŸºç¡€æ¦‚å¿µå®Œæˆ
- **æ£€æŸ¥ç‚¹2**: å¹¶é›†è¿ç®—å®Œæˆ
- **æ£€æŸ¥ç‚¹3**: äº¤é›†è¿ç®—å®Œæˆ

## ä»£ç ç¤ºä¾‹ | Code Examples

### é›†åˆè¿ç®—ç¤ºä¾‹ | Set Operations Examples

```lean
-- é›†åˆç±»å‹å®šä¹‰
def Set (Î± : Type) := Î± â†’ Prop

-- é›†åˆæˆå‘˜å…³ç³»
def mem {Î± : Type} (x : Î±) (s : Set Î±) : Prop := s x

-- å¹¶é›†è¿ç®—
def union {Î± : Type} (s1 s2 : Set Î±) : Set Î± :=
  Î» x => mem x s1 âˆ¨ mem x s2

-- äº¤é›†è¿ç®—
def intersection {Î± : Type} (s1 s2 : Set Î±) : Set Î± :=
  Î» x => mem x s1 âˆ§ mem x s2

-- å·®é›†è¿ç®—
def difference {Î± : Type} (s1 s2 : Set Î±) : Set Î± :=
  Î» x => mem x s1 âˆ§ Â¬mem x s2

-- é›†åˆè¿ç®—æ€§è´¨è¯æ˜
theorem union_commutative {Î± : Type} (s1 s2 : Set Î±) :
  union s1 s2 = union s2 s1 := by
  funext x
  simp [union, mem]
  exact or_comm

theorem intersection_commutative {Î± : Type} (s1 s2 : Set Î±) :
  intersection s1 s2 = intersection s2 s1 := by
  funext x
  simp [intersection, mem]
  exact and_comm
```

### å¤æ‚é›†åˆè¿ç®—ç¤ºä¾‹ | Complex Set Operations Examples

```lean
-- å¹‚é›†è¿ç®—
def powerset {Î± : Type} (s : Set Î±) : Set (Set Î±) :=
  Î» t => âˆ€ x, mem x t â†’ mem x s

-- ç¬›å¡å°”ç§¯
def cartesian_product {Î± Î² : Type} (s1 : Set Î±) (s2 : Set Î²) : Set (Î± Ã— Î²) :=
  Î» p => mem p.1 s1 âˆ§ mem p.2 s2

-- é›†åˆè¿ç®—çš„åˆ†é…å¾‹
theorem union_distributes_over_intersection {Î± : Type} (s1 s2 s3 : Set Î±) :
  union s1 (intersection s2 s3) = intersection (union s1 s2) (union s1 s3) := by
  funext x
  simp [union, intersection, mem]
  exact or_and_distrib_left
```
