# 基础数学概念 | Basic Mathematical Concepts

> 最小前置导入（建议放在可运行的 `lake` 项目中）：
```lean
import Std
import Mathlib
open scoped BigOperators
```

## 最小可运行证明样例 | Minimal Runnable Proof Samples

```lean
-- 自然数：加法单位元
theorem nat_add_zero (n : Nat) : n + 0 = n := by
  exact Nat.add_zero n

-- 整数：加法交换
theorem int_add_comm (a b : Int) : a + b = b + a := by
  exact Int.add_comm a b

-- 实数：加法结合
theorem real_add_assoc (a b c : Real) : (a + b) + c = a + (b + c) := by
  simpa using add_assoc a b c
```

## 1. 自然数理论 | Natural Number Theory

### 自然数定义 | Natural Number Definition

```lean
-- 自然数归纳定义
inductive Nat where
  | zero : Nat
  | succ (n : Nat) : Nat

-- 自然数基本运算
def Nat.add : Nat → Nat → Nat
  | a, Nat.zero => a
  | a, Nat.succ b => Nat.succ (Nat.add a b)

def Nat.mul : Nat → Nat → Nat
  | a, Nat.zero => Nat.zero
  | a, Nat.succ b => Nat.add a (Nat.mul a b)
```

### 自然数性质 | Natural Number Properties

```lean
-- 加法性质
theorem Nat.add_zero (n : Nat) : n + 0 = n := rfl
theorem Nat.add_succ (n m : Nat) : n + Nat.succ m = Nat.succ (n + m) := rfl
theorem Nat.add_comm (a b : Nat) : a + b = b + a := by
  induction a with
  | zero => simp [Nat.add_zero]
  | succ a ih => simp [Nat.add_succ, ih]

-- 乘法性质
theorem Nat.mul_zero (n : Nat) : n * 0 = 0 := rfl
theorem Nat.mul_succ (n m : Nat) : n * Nat.succ m = n * m + n := rfl
theorem Nat.mul_comm (a b : Nat) : a * b = b * a := by
  induction a with
  | zero => simp [Nat.mul_zero]
  | succ a ih => simp [Nat.mul_succ, ih, Nat.add_comm]
```

## 2. 整数理论 | Integer Theory

### 整数定义 | Integer Definition

```lean
-- 整数定义
inductive Int where
  | ofNat (n : Nat) : Int
  | negSucc (n : Nat) : Int

-- 整数运算
def Int.add : Int → Int → Int
  | Int.ofNat a, Int.ofNat b => Int.ofNat (a + b)
  | Int.ofNat a, Int.negSucc b => Int.subNatNat a (b + 1)
  | Int.negSucc a, Int.ofNat b => Int.subNatNat b (a + 1)
  | Int.negSucc a, Int.negSucc b => Int.negSucc (a + b + 1)
```

### 整数性质 | Integer Properties

```lean
-- 整数加法性质
theorem Int.add_comm (a b : Int) : a + b = b + a := by
  cases a with
  | ofNat a => cases b with
    | ofNat b => simp [Int.add, Nat.add_comm]
    | negSucc b => simp [Int.add]
  | negSucc a => cases b with
    | ofNat b => simp [Int.add]
    | negSucc b => simp [Int.add, Nat.add_comm]

-- 整数乘法性质
theorem Int.mul_comm (a b : Int) : a * b = b * a := by
  cases a with
  | ofNat a => cases b with
    | ofNat b => simp [Int.mul, Nat.mul_comm]
    | negSucc b => simp [Int.mul]
  | negSucc a => cases b with
    | ofNat b => simp [Int.mul]
    | negSucc b => simp [Int.mul, Nat.mul_comm]
```

## 3. 有理数理论 | Rational Number Theory

### 有理数定义 | Rational Number Definition

```lean
-- 有理数定义
structure Rat where
  num : Int
  den : Nat
  den_pos : den > 0
  reduced : Int.natAbs num.coprime den

-- 有理数运算
def Rat.add (a b : Rat) : Rat :=
  let common_den := a.den * b.den
  let new_num := a.num * b.den + b.num * a.den
  ⟨new_num, common_den, Nat.mul_pos a.den_pos b.den_pos, sorry⟩
```

### 有理数性质 | Rational Number Properties

```lean
-- 有理数加法性质
theorem Rat.add_comm (a b : Rat) : a + b = b + a := by
  simp [Rat.add, Int.add_comm, Nat.mul_comm]

-- 有理数乘法性质
theorem Rat.mul_comm (a b : Rat) : a * b = b * a := by
  simp [Rat.mul, Int.mul_comm, Nat.mul_comm]
```

## 4. 实数理论 | Real Number Theory

### 实数定义 | Real Number Definition

```lean
-- 实数作为柯西序列
structure Real where
  seq : ℕ → ℚ
  cauchy : ∀ ε > 0, ∃ N, ∀ m n ≥ N, |seq m - seq n| < ε

-- 实数运算
def Real.add (a b : Real) : Real :=
  ⟨fun n => a.seq n + b.seq n, sorry⟩
```

### 实数性质 | Real Number Properties

```lean
-- 实数加法性质
theorem Real.add_comm (a b : Real) : a + b = b + a := by
  ext n
  simp [Real.add, Rat.add_comm]

-- 实数乘法性质
theorem Real.mul_comm (a b : Real) : a * b = b * a := by
  ext n
  simp [Real.mul, Rat.mul_comm]
```

## 5. 集合论基础 | Set Theory Fundamentals

### 集合定义 | Set Definition

```lean
-- 集合作为谓词
def Set (α : Type) := α → Prop

-- 集合运算
def Set.union {α : Type} (s t : Set α) : Set α :=
  fun x => s x ∨ t x

def Set.inter {α : Type} (s t : Set α) : Set α :=
  fun x => s x ∧ t x

def Set.compl {α : Type} (s : Set α) : Set α :=
  fun x => ¬s x
```

### 集合性质 | Set Properties

```lean
-- 集合运算性质
theorem Set.union_comm {α : Type} (s t : Set α) : s ∪ t = t ∪ s := by
  ext x
  simp [Set.union, Or.comm]

theorem Set.inter_comm {α : Type} (s t : Set α) : s ∩ t = t ∩ s := by
  ext x
  simp [Set.inter, And.comm]

-- 德摩根定律
theorem Set.de_morgan {α : Type} (s t : Set α) : 
  (s ∪ t)ᶜ = sᶜ ∩ tᶜ := by
  ext x
  simp [Set.compl, Set.union, Set.inter, not_or]
```

## 6. 函数理论 | Function Theory

### 函数定义 | Function Definition

```lean
-- 函数作为关系
structure Function (α β : Type) where
  graph : α → β
  total : ∀ x : α, ∃ y : β, graph x = y
  functional : ∀ x : α, ∀ y₁ y₂ : β, graph x = y₁ → graph x = y₂ → y₁ = y₂

-- 函数复合
def Function.comp {α β γ : Type} (f : α → β) (g : β → γ) : α → γ :=
  fun x => g (f x)
```

### 函数性质 | Function Properties

```lean
-- 函数复合结合律
theorem Function.comp_assoc {α β γ δ : Type} (f : α → β) (g : β → γ) (h : γ → δ) :
  h ∘ (g ∘ f) = (h ∘ g) ∘ f := by
  ext x
  rfl

-- 恒等函数
def Function.id {α : Type} : α → α := fun x => x

theorem Function.comp_id {α β : Type} (f : α → β) : f ∘ Function.id = f := by
  ext x
  rfl
```

## 7. 关系理论 | Relation Theory

### 关系定义 | Relation Definition

```lean
-- 二元关系
def Relation (α : Type) := α → α → Prop

-- 关系性质
def Relation.reflexive {α : Type} (R : Relation α) : Prop :=
  ∀ x : α, R x x

def Relation.symmetric {α : Type} (R : Relation α) : Prop :=
  ∀ x y : α, R x y → R y x

def Relation.transitive {α : Type} (R : Relation α) : Prop :=
  ∀ x y z : α, R x y → R y z → R x z
```

### 等价关系 | Equivalence Relations

```lean
-- 等价关系
structure Equivalence {α : Type} (R : Relation α) where
  refl : Relation.reflexive R
  symm : Relation.symmetric R
  trans : Relation.transitive R

-- 等价类
def EquivalenceClass {α : Type} (R : Relation α) (x : α) : Set α :=
  fun y => R x y
```

## 8. 序理论 | Order Theory

### 偏序关系 | Partial Order Relations

```lean
-- 偏序关系
structure PartialOrder {α : Type} (R : Relation α) where
  refl : Relation.reflexive R
  antisymm : ∀ x y : α, R x y → R y x → x = y
  trans : Relation.transitive R

-- 全序关系
structure TotalOrder {α : Type} (R : Relation α) extends PartialOrder R where
  total : ∀ x y : α, R x y ∨ R y x
```

### 序性质 | Order Properties

```lean
-- 最小元和最大元
def min_element {α : Type} (R : Relation α) (s : Set α) (m : α) : Prop :=
  s m ∧ ∀ x : α, s x → R m x

def max_element {α : Type} (R : Relation α) (s : Set α) (M : α) : Prop :=
  s M ∧ ∀ x : α, s x → R x M

-- 上确界和下确界
def supremum {α : Type} (R : Relation α) (s : Set α) (u : α) : Prop :=
  (∀ x : α, s x → R x u) ∧ (∀ v : α, (∀ x : α, s x → R x v) → R u v)
```

---

*相关链接：*

- [数学库架构](./01-数学库架构.md)
- [代数结构](./03-代数结构.md)
- [分析学与拓扑](./04-分析学与拓扑.md)
