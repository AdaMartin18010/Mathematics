# 代数结构 | Algebraic Structures

> 提示：建议在可构建的 `lake` 项目中运行本页示例；需安装 `Mathlib` 且使用最新稳定 Lean4 工具链。若模块或 API 报错，请参阅 `Lean/版本同步索引.md` 与本页“版本与兼容性注记”。
> 最小前置导入（建议放在可运行的 `lake` 项目中）：

```lean
import Std
import Mathlib
open scoped BigOperators
```

## 常用模块导入清单 | Common Imports Cheat Sheet

- 多项式/环化简战术：`import Mathlib/Tactic/Ring`，`import Mathlib/Algebra/Ring/RingNF`
- 幂与幂等性质：`import Mathlib/Algebra/GroupPower`
- 线性代数与模块：`import Mathlib/LinearAlgebra/Basic`
- 半群/群/环/域等结构与实例：统一由 `import Mathlib` 覆盖，按需精化模块
- 域上代数化简：`import Mathlib/Tactic/FieldSimp`

## 结构层级与别名对照 | Hierarchy & Name Mapping

- 乘法系：`Semigroup → Monoid → Group → CommGroup`
- 加法系：`AddSemigroup → AddMonoid → AddGroup → AddCommGroup`
- 环系：`Semiring → Ring → CommRing`
- 带除结构：`DivisionRing → Field → IsROrC (实/复特化)`
- 模/向量空间：`SMul / Module R M`；在域 `K` 上的向量空间即 `Module K V`
- 代数：`Algebra R A`（`A` 为 `R`-代数）

提示：教学中的自定义结构仅用于直观展示；实际项目请优先使用 `Mathlib` 内置结构与实例，避免命名冲突。

## 最小可运行证明样例 | Minimal Runnable Proof Samples

```lean
-- 半群/幺半群/群在 mathlib 中已有实例与定理；这里给出可直接复用的性质

-- Nat 加法是交换幺半群的一部分性质
theorem nat_add_comm (a b : Nat) : a + b = b + a := by
  exact Nat.add_comm a b

-- Int 加法可交换
theorem int_add_comm (a b : Int) : a + b = b + a := by
  exact Int.add_comm a b

-- 乘法结合（Nat）
theorem nat_mul_assoc (a b c : Nat) : (a * b) * c = a * (b * c) := by
  exact Nat.mul_assoc a b c

-- 环化简示例（ℤ 上的等式）
theorem int_ring_nf (a b : ℤ) : (a + b) - a = b := by
  ring_nf

-- 平方展开（ℤ）
theorem int_sq_expansion (a b : ℤ) : (a + b)^2 = a^2 + 2*a*b + b^2 := by
  ring
```

## 1. 群论 | Group Theory

### 群的定义 | Group Definition

```lean
-- 群的定义
class Group (G : Type) extends Mul G, One G, Inv G where
  mul_assoc : ∀ a b c : G, (a * b) * c = a * (b * c)
  one_mul : ∀ a : G, 1 * a = a
  mul_one : ∀ a : G, a * 1 = a
  mul_left_inv : ∀ a : G, a⁻¹ * a = 1

-- 阿贝尔群
class AbelianGroup (G : Type) extends Group G where
  mul_comm : ∀ a b : G, a * b = b * a
```

### 群的性质 | Group Properties

```lean
-- 群的基本性质
theorem Group.mul_right_inv (G : Type) [Group G] (a : G) : a * a⁻¹ = 1 := by
  have h := Group.mul_left_inv a⁻¹
  rw [inv_inv] at h
  exact h

theorem Group.one_unique (G : Type) [Group G] : ∀ e : G, (∀ a : G, e * a = a) → e = 1 := by
  intro e he
  have h := he 1
  rw [Group.one_mul] at h
  exact h.symm

-- 逆元唯一性
theorem Group.inv_unique (G : Type) [Group G] (a : G) : 
  ∀ b : G, b * a = 1 → b = a⁻¹ := by
  intro b hb
  have h := congr_arg (· * a⁻¹) hb
  simp [Group.mul_assoc, Group.mul_left_inv, Group.mul_one] at h
  exact h
```

### 群论可运行样例 | Group Runnable Samples

```lean
-- 任意群中：逆的逆等于自身
theorem inv_inv_group {G : Type} [Group G] (a : G) : (a⁻¹)⁻¹ = a := by
  simpa using inv_inv a
```

## 2. 环论 | Ring Theory

### 环的定义 | Ring Definition

```lean
-- 环的定义
class Ring (R : Type) extends Add R, Mul R, Neg R, Zero R, One R where
  add_assoc : ∀ a b c : R, (a + b) + c = a + (b + c)
  add_comm : ∀ a b : R, a + b = b + a
  add_zero : ∀ a : R, a + 0 = a
  add_left_neg : ∀ a : R, -a + a = 0
  mul_assoc : ∀ a b c : R, (a * b) * c = a * (b * c)
  mul_one : ∀ a : R, a * 1 = a
  one_mul : ∀ a : R, 1 * a = a
  left_distrib : ∀ a b c : R, a * (b + c) = a * b + a * c
  right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c

-- 交换环
class CommRing (R : Type) extends Ring R where
  mul_comm : ∀ a b : R, a * b = b * a
```

### 环的性质 | Ring Properties

```lean
-- 环的基本性质
theorem Ring.zero_mul (R : Type) [Ring R] (a : R) : 0 * a = 0 := by
  have h := Ring.left_distrib 0 a 0
  simp [Ring.add_zero] at h
  exact h

theorem Ring.mul_zero (R : Type) [Ring R] (a : R) : a * 0 = 0 := by
  have h := Ring.right_distrib a 0 0
  simp [Ring.add_zero] at h
  exact h

-- 负元性质
theorem Ring.neg_mul (R : Type) [Ring R] (a b : R) : (-a) * b = -(a * b) := by
  have h := Ring.left_distrib (-a) a b
  simp [Ring.add_left_neg, Ring.zero_mul] at h
  exact h.symm
```

## 3. 域论 | Field Theory

### 域的定义 | Field Definition

```lean
-- 域的定义
class Field (F : Type) extends Ring F, Inv F where
  mul_comm : ∀ a b : F, a * b = b * a
  mul_inv_cancel : ∀ a : F, a ≠ 0 → a * a⁻¹ = 1
  inv_zero : (0 : F)⁻¹ = 0

-- 特征零域
class CharZeroField (F : Type) extends Field F where
  char_zero : ∀ n : ℕ, n ≠ 0 → (n : F) ≠ 0
```

### 域的性质 | Field Properties

```lean
-- 域的基本性质
theorem Field.mul_right_inv (F : Type) [Field F] (a : F) (ha : a ≠ 0) : a * a⁻¹ = 1 :=
  Field.mul_inv_cancel a ha

theorem Field.inv_inv (F : Type) [Field F] (a : F) (ha : a ≠ 0) : (a⁻¹)⁻¹ = a := by
  have h := Field.mul_inv_cancel a⁻¹ (Field.inv_ne_zero ha)
  rw [Field.mul_comm] at h
  exact h.symm

-- 域上的线性方程组
-- 教学占位：线性方程组求解的通用证明较长，建议在实际项目中直接使用 Mathlib 已证结论
-- 或在具体域（如 ℝ/ℚ）上给出实例化证明。
```

### 域论可运行样例 | Field Runnable Samples

```lean
-- 在实数域上：一元线性方程存在解
theorem exists_solution_real (a b : ℝ) (ha : a ≠ 0) : ∃ x : ℝ, a * x = b := by
  refine ⟨b / a, ?_⟩
  field_simp [ha]
```

## 4. 模论 | Module Theory

### 模的定义 | Module Definition

```lean
-- 左模定义
class LeftModule (M : Type) (R : Type) [Ring R] extends AddCommGroup M, SMul R M where
  smul_assoc : ∀ (a b : R) (v : M), (a * b) • v = a • (b • v)
  one_smul : ∀ v : M, (1 : R) • v = v
  smul_add : ∀ (a : R) (v w : M), a • (v + w) = a • v + a • w
  add_smul : ∀ (a b : R) (v : M), (a + b) • v = a • v + b • v

-- 右模定义
class RightModule (M : Type) (R : Type) [Ring R] extends AddCommGroup M, SMul M R where
  smul_assoc : ∀ (v : M) (a b : R), v • (a * b) = (v • a) • b
  smul_one : ∀ v : M, v • (1 : R) = v
  smul_add : ∀ (v : M) (a b : R), v • (a + b) = v • a + v • b
  add_smul : ∀ (v w : M) (a : R), (v + w) • a = v • a + w • a
```

### 模的性质 | Module Properties

```lean
-- 模的基本性质
theorem LeftModule.zero_smul (M : Type) (R : Type) [Ring R] [LeftModule M R] (v : M) :
  (0 : R) • v = 0 := by
  have h := LeftModule.add_smul 0 0 v
  simp [Ring.add_zero] at h
  exact h

theorem LeftModule.smul_zero (M : Type) (R : Type) [Ring R] [LeftModule M R] (a : R) :
  a • (0 : M) = 0 := by
  have h := LeftModule.smul_add a 0 0
  simp [AddCommGroup.add_zero] at h
  exact h
```

## 5. 向量空间 | Vector Spaces

### 向量空间定义 | Vector Space Definition

```lean
-- 向量空间定义
class VectorSpace (V : Type) (K : Type) [Field K] extends LeftModule V K

-- 有限维向量空间
class FiniteDimensional (V : Type) (K : Type) [Field K] [VectorSpace V K] where
  dim : ℕ
  basis : Fin dim → V
  linear_independent : LinearIndependent K basis
  spanning : span K (Set.range basis) = ⊤
```

### 向量空间性质 | Vector Space Properties

```lean
-- 向量空间的基本性质
theorem VectorSpace.linear_combination (V : Type) (K : Type) [Field K] [VectorSpace V K]
  (v₁ v₂ : V) (a b : K) : a • v₁ + b • v₂ = (a + b) • v₁ + b • (v₂ - v₁) := by
  simp [LeftModule.smul_add, LeftModule.add_smul]
  ring

-- 教学占位：一般性的线性无关性证明较为繁琐，建议在具体向量空间上给出实例。
```

### 向量空间可运行样例 | Vector Space Runnable Samples

```lean
-- 单元素集线性无关（在 ℝ-向量空间 ℝ 上）
theorem li_singleton_real (v : ℝ) (hv : v ≠ 0) : LinearIndependent ℝ ![v] := by
  classical
  simpa using linearIndependent_singleton (x:=v) hv
```

## 6. 代数 | Algebras

### 代数定义 | Algebra Definition

```lean
-- 代数定义
class Algebra (A : Type) (R : Type) [CommRing R] extends Ring A, LeftModule A R where
  commutes : ∀ (r : R) (a : A), r • a = a • r
  smul_assoc' : ∀ (r : R) (a b : A), r • (a * b) = (r • a) * b

-- 交换代数
class CommAlgebra (A : Type) (R : Type) [CommRing R] extends Algebra A R, CommRing A
```

### 代数性质 | Algebra Properties

```lean
-- 代数的基本性质
theorem Algebra.smul_mul (A : Type) (R : Type) [CommRing R] [Algebra A R] (r : R) (a b : A) :
  r • (a * b) = (r • a) * b := Algebra.smul_assoc' r a b

theorem Algebra.mul_smul (A : Type) (R : Type) [CommRing R] [Algebra A R] (r : R) (a b : A) :
  (a * b) • r = a • (b • r) := by
  rw [Algebra.commutes, Algebra.smul_assoc']
```

## 附加样例：DivisionRing 与 IsROrC | Extra Samples

```lean
-- 任意除环上的“约去”性质（使用 field_simp）
theorem divring_cancel {K : Type} [DivisionRing K]
    (a b : K) (ha : a ≠ 0) : a * (b / a) = b := by
  field_simp [ha]

-- 在复数域上（IsROrC 实例存在），相同技巧适用
theorem complex_cancel (a b : ℂ) (ha : a ≠ 0) : a * (b / a) = b := by
  field_simp [ha]
```

## 7. 李代数 | Lie Algebras

### 李代数定义 | Lie Algebra Definition

```lean
-- 李代数定义
class LieAlgebra (L : Type) extends AddCommGroup L, Bracket L L where
  lie_antisymm : ∀ x y : L, ⁅x, y⁆ = -⁅y, x⁆
  lie_jacobi : ∀ x y z : L, ⁅x, ⁅y, z⁆⁆ + ⁅y, ⁅z, x⁆⁆ + ⁅z, ⁅x, y⁆⁆ = 0

-- 李代数同态
structure LieAlgebraHom (L₁ L₂ : Type) [LieAlgebra L₁] [LieAlgebra L₂] where
  toFun : L₁ → L₂
  map_add : ∀ x y : L₁, toFun (x + y) = toFun x + toFun y
  map_bracket : ∀ x y : L₁, toFun ⁅x, y⁆ = ⁅toFun x, toFun y⁆
```

### 李代数性质 | Lie Algebra Properties

```lean
-- 李代数的基本性质
theorem LieAlgebra.lie_self_zero (L : Type) [LieAlgebra L] (x : L) : ⁅x, x⁆ = 0 := by
  have h := LieAlgebra.lie_antisymm x x
  simp [h]

theorem LieAlgebra.lie_derivation (L : Type) [LieAlgebra L] (x y z : L) :
  ⁅x, ⁅y, z⁆⁆ = ⁅⁅x, y⁆, z⁆ + ⁅y, ⁅x, z⁆⁆ := by
  have h := LieAlgebra.lie_jacobi x y z
  rw [LieAlgebra.lie_antisymm] at h
  linarith
```

## 8. 范畴论 | Category Theory

### 范畴定义 | Category Definition

```lean
-- 范畴定义
class Category (C : Type) where
  Hom : C → C → Type
  id : ∀ X : C, Hom X X
  comp : ∀ {X Y Z : C}, Hom Y Z → Hom X Y → Hom X Z
  id_comp : ∀ {X Y : C} (f : Hom X Y), comp (id Y) f = f
  comp_id : ∀ {X Y : C} (f : Hom X Y), comp f (id X) = f
  assoc : ∀ {W X Y Z : C} (f : Hom W X) (g : Hom X Y) (h : Hom Y Z),
    comp h (comp g f) = comp (comp h g) f

-- 函子定义
structure Functor (C D : Type) [Category C] [Category D] where
  obj : C → D
  map : ∀ {X Y : C}, C.Hom X Y → D.Hom (obj X) (obj Y)
  map_id : ∀ X : C, map (C.id X) = D.id (obj X)
  map_comp : ∀ {X Y Z : C} (f : C.Hom X Y) (g : C.Hom Y Z),
    map (C.comp g f) = D.comp (map g) (map f)
```

## 9. 练习与参考解 | Exercises with Hints

```lean
-- 练习1（群）：在任意群中，单位元唯一
theorem ex_group_one_unique {G : Type} [Group G] :
  ∀ e : G, (∀ a : G, e * a = a) → e = (1 : G) := by
  intro e he
  have h := he (1 : G)
  simpa using h.symm

-- 练习2（环）：任意环中 0 * a = 0（提示：right_distrib，add_right_neg）
theorem ex_ring_zero_mul {R : Type} [Semiring R] (a : R) : 0 * a = 0 := by
  simpa using zero_mul a

-- 练习3（域）：若 a ≠ 0，则 a * (b / a) = b（提示：field_simp）
theorem ex_field_cancel {K : Type} [Field K] (a b : K) (ha : a ≠ 0) : a * (b / a) = b := by
  field_simp [ha]
```

### 范畴性质 | Category Properties

```lean
-- 范畴的基本性质
theorem Category.id_unique (C : Type) [Category C] (X : C) (f : C.Hom X X) :
  (∀ g : C.Hom X X, C.comp f g = g) → f = C.id X := by
  intro h
  have h1 := h (C.id X)
  rw [C.id_comp] at h1
  exact h1.symm

-- 教学占位：函子保持同构的证明依赖较多公理，建议引用 Mathlib 对应结论。
```

---

*相关链接：*

- [数学库架构](./01-数学库架构.md)
- [基础数学概念](./02-基础数学概念.md)
- [分析学与拓扑](./04-分析学与拓扑.md)
- [自动化证明技术](../03-证明系统与策略/04-自动化证明技术.md)
- 练习（可运行）：`Lean/Exercises/Algebra/Group.lean`、`Lean/Exercises/Algebra/Ring.lean`、`Lean/Exercises/Algebra/Field.lean`
- 跨章节练习索引：`Lean/Exercises/跨章节练习索引.md`

---

## 附：版本与兼容性注记 | Version & Compatibility Notes

- 版本基线：参见 `Lean/版本同步索引.md`；本页定义以教学为主，实作优先复用 `Mathlib` 结构与定理。
- 命名冲突：自定义结构如 `Group/Ring/Field` 容易与 `Mathlib` 名称重叠，教学中可使用前缀或命名空间隔离。
- 运行建议：实际项目中直接使用 `Mathlib` 的现成结构与公理，避免重复造轮子。
