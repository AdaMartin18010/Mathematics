# 代数结构 | Algebraic Structures

> 最小前置导入（建议放在可运行的 `lake` 项目中）：
```lean
import Std
import Mathlib
open scoped BigOperators
```

## 最小可运行证明样例 | Minimal Runnable Proof Samples

```lean
-- 半群/幺半群/群在 mathlib 中已有实例与定理；这里给出可直接复用的性质

-- Nat 加法是交换幺半群的一部分性质
theorem nat_add_comm (a b : Nat) : a + b = b + a := by
  exact Nat.add_comm a b

-- Int 加法可交换
theorem int_add_comm (a b : Int) : a + b = b + a := by
  exact Int.add_comm a b

-- 乘法结合（Nat）
theorem nat_mul_assoc (a b c : Nat) : (a * b) * c = a * (b * c) := by
  exact Nat.mul_assoc a b c
```

## 1. 群论 | Group Theory

### 群的定义 | Group Definition

```lean
-- 群的定义
class Group (G : Type) extends Mul G, One G, Inv G where
  mul_assoc : ∀ a b c : G, (a * b) * c = a * (b * c)
  one_mul : ∀ a : G, 1 * a = a
  mul_one : ∀ a : G, a * 1 = a
  mul_left_inv : ∀ a : G, a⁻¹ * a = 1

-- 阿贝尔群
class AbelianGroup (G : Type) extends Group G where
  mul_comm : ∀ a b : G, a * b = b * a
```

### 群的性质 | Group Properties

```lean
-- 群的基本性质
theorem Group.mul_right_inv (G : Type) [Group G] (a : G) : a * a⁻¹ = 1 := by
  have h := Group.mul_left_inv a⁻¹
  rw [inv_inv] at h
  exact h

theorem Group.one_unique (G : Type) [Group G] : ∀ e : G, (∀ a : G, e * a = a) → e = 1 := by
  intro e he
  have h := he 1
  rw [Group.one_mul] at h
  exact h.symm

-- 逆元唯一性
theorem Group.inv_unique (G : Type) [Group G] (a : G) : 
  ∀ b : G, b * a = 1 → b = a⁻¹ := by
  intro b hb
  have h := congr_arg (· * a⁻¹) hb
  simp [Group.mul_assoc, Group.mul_left_inv, Group.mul_one] at h
  exact h
```

## 2. 环论 | Ring Theory

### 环的定义 | Ring Definition

```lean
-- 环的定义
class Ring (R : Type) extends Add R, Mul R, Neg R, Zero R, One R where
  add_assoc : ∀ a b c : R, (a + b) + c = a + (b + c)
  add_comm : ∀ a b : R, a + b = b + a
  add_zero : ∀ a : R, a + 0 = a
  add_left_neg : ∀ a : R, -a + a = 0
  mul_assoc : ∀ a b c : R, (a * b) * c = a * (b * c)
  mul_one : ∀ a : R, a * 1 = a
  one_mul : ∀ a : R, 1 * a = a
  left_distrib : ∀ a b c : R, a * (b + c) = a * b + a * c
  right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c

-- 交换环
class CommRing (R : Type) extends Ring R where
  mul_comm : ∀ a b : R, a * b = b * a
```

### 环的性质 | Ring Properties

```lean
-- 环的基本性质
theorem Ring.zero_mul (R : Type) [Ring R] (a : R) : 0 * a = 0 := by
  have h := Ring.left_distrib 0 a 0
  simp [Ring.add_zero] at h
  exact h

theorem Ring.mul_zero (R : Type) [Ring R] (a : R) : a * 0 = 0 := by
  have h := Ring.right_distrib a 0 0
  simp [Ring.add_zero] at h
  exact h

-- 负元性质
theorem Ring.neg_mul (R : Type) [Ring R] (a b : R) : (-a) * b = -(a * b) := by
  have h := Ring.left_distrib (-a) a b
  simp [Ring.add_left_neg, Ring.zero_mul] at h
  exact h.symm
```

## 3. 域论 | Field Theory

### 域的定义 | Field Definition

```lean
-- 域的定义
class Field (F : Type) extends Ring F, Inv F where
  mul_comm : ∀ a b : F, a * b = b * a
  mul_inv_cancel : ∀ a : F, a ≠ 0 → a * a⁻¹ = 1
  inv_zero : (0 : F)⁻¹ = 0

-- 特征零域
class CharZeroField (F : Type) extends Field F where
  char_zero : ∀ n : ℕ, n ≠ 0 → (n : F) ≠ 0
```

### 域的性质 | Field Properties

```lean
-- 域的基本性质
theorem Field.mul_right_inv (F : Type) [Field F] (a : F) (ha : a ≠ 0) : a * a⁻¹ = 1 :=
  Field.mul_inv_cancel a ha

theorem Field.inv_inv (F : Type) [Field F] (a : F) (ha : a ≠ 0) : (a⁻¹)⁻¹ = a := by
  have h := Field.mul_inv_cancel a⁻¹ (Field.inv_ne_zero ha)
  rw [Field.mul_comm] at h
  exact h.symm

-- 域上的线性方程组
theorem Field.linear_system (F : Type) [Field F] (a b c d : F) (h : a ≠ 0) :
  ∃ x : F, a * x + b = c * x + d := by
  use (d - b) / (a - c)
  sorry -- 需要证明线性方程组的解
```

## 4. 模论 | Module Theory

### 模的定义 | Module Definition

```lean
-- 左模定义
class LeftModule (M : Type) (R : Type) [Ring R] extends AddCommGroup M, SMul R M where
  smul_assoc : ∀ (a b : R) (v : M), (a * b) • v = a • (b • v)
  one_smul : ∀ v : M, (1 : R) • v = v
  smul_add : ∀ (a : R) (v w : M), a • (v + w) = a • v + a • w
  add_smul : ∀ (a b : R) (v : M), (a + b) • v = a • v + b • v

-- 右模定义
class RightModule (M : Type) (R : Type) [Ring R] extends AddCommGroup M, SMul M R where
  smul_assoc : ∀ (v : M) (a b : R), v • (a * b) = (v • a) • b
  smul_one : ∀ v : M, v • (1 : R) = v
  smul_add : ∀ (v : M) (a b : R), v • (a + b) = v • a + v • b
  add_smul : ∀ (v w : M) (a : R), (v + w) • a = v • a + w • a
```

### 模的性质 | Module Properties

```lean
-- 模的基本性质
theorem LeftModule.zero_smul (M : Type) (R : Type) [Ring R] [LeftModule M R] (v : M) :
  (0 : R) • v = 0 := by
  have h := LeftModule.add_smul 0 0 v
  simp [Ring.add_zero] at h
  exact h

theorem LeftModule.smul_zero (M : Type) (R : Type) [Ring R] [LeftModule M R] (a : R) :
  a • (0 : M) = 0 := by
  have h := LeftModule.smul_add a 0 0
  simp [AddCommGroup.add_zero] at h
  exact h
```

## 5. 向量空间 | Vector Spaces

### 向量空间定义 | Vector Space Definition

```lean
-- 向量空间定义
class VectorSpace (V : Type) (K : Type) [Field K] extends LeftModule V K

-- 有限维向量空间
class FiniteDimensional (V : Type) (K : Type) [Field K] [VectorSpace V K] where
  dim : ℕ
  basis : Fin dim → V
  linear_independent : LinearIndependent K basis
  spanning : span K (Set.range basis) = ⊤
```

### 向量空间性质 | Vector Space Properties

```lean
-- 向量空间的基本性质
theorem VectorSpace.linear_combination (V : Type) (K : Type) [Field K] [VectorSpace V K]
  (v₁ v₂ : V) (a b : K) : a • v₁ + b • v₂ = (a + b) • v₁ + b • (v₂ - v₁) := by
  simp [LeftModule.smul_add, LeftModule.add_smul]
  ring

-- 线性无关性
theorem VectorSpace.linear_independent (V : Type) (K : Type) [Field K] [VectorSpace V K]
  (v₁ v₂ : V) (h : v₁ ≠ v₂) : LinearIndependent K ![v₁, v₂] := by
  sorry -- 需要证明线性无关性
```

## 6. 代数 | Algebras

### 代数定义 | Algebra Definition

```lean
-- 代数定义
class Algebra (A : Type) (R : Type) [CommRing R] extends Ring A, LeftModule A R where
  commutes : ∀ (r : R) (a : A), r • a = a • r
  smul_assoc' : ∀ (r : R) (a b : A), r • (a * b) = (r • a) * b

-- 交换代数
class CommAlgebra (A : Type) (R : Type) [CommRing R] extends Algebra A R, CommRing A
```

### 代数性质 | Algebra Properties

```lean
-- 代数的基本性质
theorem Algebra.smul_mul (A : Type) (R : Type) [CommRing R] [Algebra A R] (r : R) (a b : A) :
  r • (a * b) = (r • a) * b := Algebra.smul_assoc' r a b

theorem Algebra.mul_smul (A : Type) (R : Type) [CommRing R] [Algebra A R] (r : R) (a b : A) :
  (a * b) • r = a • (b • r) := by
  rw [Algebra.commutes, Algebra.smul_assoc']
```

## 7. 李代数 | Lie Algebras

### 李代数定义 | Lie Algebra Definition

```lean
-- 李代数定义
class LieAlgebra (L : Type) extends AddCommGroup L, Bracket L L where
  lie_antisymm : ∀ x y : L, ⁅x, y⁆ = -⁅y, x⁆
  lie_jacobi : ∀ x y z : L, ⁅x, ⁅y, z⁆⁆ + ⁅y, ⁅z, x⁆⁆ + ⁅z, ⁅x, y⁆⁆ = 0

-- 李代数同态
structure LieAlgebraHom (L₁ L₂ : Type) [LieAlgebra L₁] [LieAlgebra L₂] where
  toFun : L₁ → L₂
  map_add : ∀ x y : L₁, toFun (x + y) = toFun x + toFun y
  map_bracket : ∀ x y : L₁, toFun ⁅x, y⁆ = ⁅toFun x, toFun y⁆
```

### 李代数性质 | Lie Algebra Properties

```lean
-- 李代数的基本性质
theorem LieAlgebra.lie_self_zero (L : Type) [LieAlgebra L] (x : L) : ⁅x, x⁆ = 0 := by
  have h := LieAlgebra.lie_antisymm x x
  simp [h]

theorem LieAlgebra.lie_derivation (L : Type) [LieAlgebra L] (x y z : L) :
  ⁅x, ⁅y, z⁆⁆ = ⁅⁅x, y⁆, z⁆ + ⁅y, ⁅x, z⁆⁆ := by
  have h := LieAlgebra.lie_jacobi x y z
  rw [LieAlgebra.lie_antisymm] at h
  linarith
```

## 8. 范畴论 | Category Theory

### 范畴定义 | Category Definition

```lean
-- 范畴定义
class Category (C : Type) where
  Hom : C → C → Type
  id : ∀ X : C, Hom X X
  comp : ∀ {X Y Z : C}, Hom Y Z → Hom X Y → Hom X Z
  id_comp : ∀ {X Y : C} (f : Hom X Y), comp (id Y) f = f
  comp_id : ∀ {X Y : C} (f : Hom X Y), comp f (id X) = f
  assoc : ∀ {W X Y Z : C} (f : Hom W X) (g : Hom X Y) (h : Hom Y Z),
    comp h (comp g f) = comp (comp h g) f

-- 函子定义
structure Functor (C D : Type) [Category C] [Category D] where
  obj : C → D
  map : ∀ {X Y : C}, C.Hom X Y → D.Hom (obj X) (obj Y)
  map_id : ∀ X : C, map (C.id X) = D.id (obj X)
  map_comp : ∀ {X Y Z : C} (f : C.Hom X Y) (g : C.Hom Y Z),
    map (C.comp g f) = D.comp (map g) (map f)
```

### 范畴性质 | Category Properties

```lean
-- 范畴的基本性质
theorem Category.id_unique (C : Type) [Category C] (X : C) (f : C.Hom X X) :
  (∀ g : C.Hom X X, C.comp f g = g) → f = C.id X := by
  intro h
  have h1 := h (C.id X)
  rw [C.id_comp] at h1
  exact h1.symm

-- 函子的性质
theorem Functor.preserves_isomorphisms (C D : Type) [Category C] [Category D]
  (F : Functor C D) (X Y : C) (f : C.Hom X Y) (hf : IsIso f) :
  IsIso (F.map f) := by
  sorry -- 需要证明函子保持同构
```

---

*相关链接：*

- [数学库架构](./01-数学库架构.md)
- [基础数学概念](./02-基础数学概念.md)
- [分析学与拓扑](./04-分析学与拓扑.md)
