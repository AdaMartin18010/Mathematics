# åˆ†æå­¦ä¸æ‹“æ‰‘ | Analysis and Topology

> æç¤ºï¼šå»ºè®®åœ¨å¯æ„å»ºçš„ `lake` é¡¹ç›®ä¸­è¿è¡Œæœ¬é¡µç¤ºä¾‹ï¼›éœ€å®‰è£… `Mathlib` ä¸”ä½¿ç”¨æœ€æ–°ç¨³å®š Lean4 å·¥å…·é“¾ã€‚è‹¥æ¨¡å—æˆ– API æŠ¥é”™ï¼Œè¯·å‚é˜… `Lean/ç‰ˆæœ¬åŒæ­¥ç´¢å¼•.md` ä¸æœ¬é¡µâ€œç‰ˆæœ¬ä¸å…¼å®¹æ€§æ³¨è®°â€ã€‚
> æœ€å°å‰ç½®å¯¼å…¥ï¼ˆå»ºè®®æ”¾åœ¨å¯è¿è¡Œçš„ `lake` é¡¹ç›®ä¸­ï¼‰ï¼š

```lean
import Std
import Mathlib
open scoped BigOperators Interval
```

## å¸¸ç”¨æ¨¡å—å¯¼å…¥æ¸…å• | Common Imports Cheat Sheet

- æ‹“æ‰‘ä¸åŸºç¡€å®ä¾‹ï¼š`import Mathlib/Topology/Basic`ï¼Œ`import Mathlib/Topology/Instances/Real`
- åº¦é‡ä¸è¿ç»­ï¼š`import Mathlib/Topology/MetricSpace/Basic`ï¼Œ`import Mathlib/Topology/ContinuousFunction/Basic`
- æ»¤å­ä¸æé™ï¼š`import Mathlib/Topology/Algebra/Filter`
- æµ‹åº¦ä¸ç§¯åˆ†ï¼š`import Mathlib/Measure/Measure`ï¼Œ`import Mathlib/Measure/Integral/IntervalIntegral`
- å¾®ç§¯åˆ†ï¼š`import Mathlib/Analysis/Calculus/Derivative`
- å¸¸ç”¨æˆ˜æœ¯ï¼š`import Mathlib/Tactic/Linarith`ï¼Œ`import Mathlib/Tactic/NormNum`ï¼Œ`import Mathlib/Tactic/Continuity`

## ç»“æ„å±‚çº§ä¸æ¦‚å¿µæ˜ å°„ | Hierarchy & Concept Mapping

- æ‹“æ‰‘å±‚çº§ï¼š`TopologicalSpace` â†’ `T0/T1/T2 (T2Space)` â†’ `NormalSpace`/`CompactSpace`/`Connected`
- åº¦é‡è¯±å¯¼æ‹“æ‰‘ï¼š`MetricSpace` â‡’ `TopologicalSpace`ï¼ˆåº¦é‡å¼€çƒç”Ÿæˆæ‹“æ‰‘ï¼‰
- æ»¤å­ä¸æé™ï¼š`Filter`ï¼Œ`Tendsto`ï¼Œ`atTop/ğ“ x`ï¼ˆé‚»åŸŸæ»¤å­ï¼‰
- æµ‹åº¦å±‚çº§ï¼š`MeasurableSpace` â†’ `Measure` â†’ `Integrable`/`AE_measurable`
- å¾®åˆ†ä¸ç§¯åˆ†ï¼š`HasDerivAt/HasFDerivAt`ï¼Œ`IntervalIntegrable`ï¼Œ`âˆ« x in a..b, f x`

æç¤ºï¼šæ–‡ä¸­â€œä»é›¶æ­å»ºâ€ç‰‡æ®µç”¨äºæ¦‚å¿µè¯´æ˜ï¼›å®é™…é¡¹ç›®è¯·ä¼˜å…ˆä½¿ç”¨ `Mathlib` å·²æœ‰å®šä¹‰ä¸å®šç†ã€‚

## æœ€å°å¯è¿è¡Œè¯æ˜æ ·ä¾‹ | Minimal Runnable Proof Samples

```lean
-- å®æ•°ä¸ç­‰å¼ç®€å•æ€§è´¨ï¼ˆéœ€è¦ Mathlib ç›¸å…³å®ä¾‹å·²åŠ è½½ï¼‰
theorem real_add_comm (a b : â„) : a + b = b + a := by
  simpa using add_comm a b

-- åˆ—è¡¨é•¿åº¦éè´Ÿï¼ˆå½’çº³ + simpï¼‰
theorem list_length_nonneg {Î±} (xs : List Î±) : 0 â‰¤ (xs.length : Int) := by
  have : (0 : Nat) â‰¤ xs.length := Nat.zero_le _
  exact Int.ofNat_le.mpr this
```

## 1. æ‹“æ‰‘ç©ºé—´ | Topological Spaces

### æ‹“æ‰‘ç©ºé—´å®šä¹‰ | Topological Space Definition

```lean
-- æ‹“æ‰‘ç©ºé—´å®šä¹‰
class TopologicalSpace (X : Type) where
  IsOpen : Set X â†’ Prop
  isOpen_univ : IsOpen univ
  isOpen_inter : âˆ€ s t, IsOpen s â†’ IsOpen t â†’ IsOpen (s âˆ© t)
  isOpen_sUnion : âˆ€ S : Set (Set X), (âˆ€ s âˆˆ S, IsOpen s) â†’ IsOpen (â‹ƒâ‚€ S)

-- è¿ç»­æ˜ å°„
def Continuous {X Y : Type} [TopologicalSpace X] [TopologicalSpace Y] (f : X â†’ Y) : Prop :=
  âˆ€ s : Set Y, TopologicalSpace.IsOpen s â†’ TopologicalSpace.IsOpen (f â»Â¹' s)
```

> è¯´æ˜ï¼šä»¥ä¸Šä¸ºæ•™å­¦æ€§â€œä»é›¶æ­å»ºâ€é£æ ¼çš„å®šä¹‰è‰å›¾ï¼Œç”¨äºå¸®åŠ©ç†è§£æ¦‚å¿µç»“æ„ï¼›åœ¨å®é™…é¡¹ç›®ä¸­åº”ç›´æ¥ä½¿ç”¨ `Mathlib` å†…å»ºçš„æ‹“æ‰‘ç»“æ„ä¸å®šç†åº“ã€‚

### ç§¯åˆ†å­¦å¯è¿è¡Œæ ·ä¾‹ | Integral Runnable Samples

```lean
-- ä¾èµ– Mathlib æä¾›çš„å®æ•°æ‹“æ‰‘ä¸è¿ç»­æ€§å®šç†
-- è¿ç»­çš„åŠ æ³•ï¼ˆâ„ Ã— â„ â†’ â„ï¼‰
theorem continuous_add_real : Continuous fun p : â„ Ã— â„ => p.1 + p.2 := by
  simpa using (continuous_fst.add continuous_snd)

-- æ ‡å‡†å¼€é›†ï¼šå¼€åŒºé—´æ˜¯å¼€é›†ï¼ˆä½¿ç”¨ Mathlib ç°æˆå®šç†ï¼‰
theorem isOpen_Ioi (a : â„) : IsOpen (Set.Ioi a) := isOpen_Ioi

-- é—­åŒºé—´æ˜¯ç´§è‡´é›†ï¼ˆHeineâ€“Borelï¼‰
theorem isCompact_Icc (a b : â„) : IsCompact (Set.Icc a b) := isCompact_Icc
```

### æ‹“æ‰‘æ€§è´¨ | Topological Properties

```lean
-- é—­é›†å®šä¹‰
def IsClosed {X : Type} [TopologicalSpace X] (s : Set X) : Prop :=
  TopologicalSpace.IsOpen sá¶œ

-- é—­é›†æ€§è´¨
theorem IsClosed.inter {X : Type} [TopologicalSpace X] (s t : Set X) :
  IsClosed s â†’ IsClosed t â†’ IsClosed (s âˆ© t) := by
  intro hs ht
  simp [IsClosed, Set.compl_inter]
  exact TopologicalSpace.isOpen_union (IsClosed.isOpen hs) (IsClosed.isOpen ht)

-- é—­åŒ…å®šä¹‰
def closure {X : Type} [TopologicalSpace X] (s : Set X) : Set X :=
  â‹‚â‚€ {t : Set X | IsClosed t âˆ§ s âŠ† t}
```

### æ‹“æ‰‘å¯è¿è¡Œæ ·ä¾‹ | Topology Runnable Samples

```lean
-- é—­åŒºé—´æ˜¯é—­é›†ï¼ˆä¾èµ– Mathlib æ ‡å‡†ç»“æœï¼‰
theorem isClosed_Icc (a b : â„) : IsClosed (Set.Icc a b) := isClosed_Icc
```

## 2. åº¦é‡ç©ºé—´ | Metric Spaces

### åº¦é‡ç©ºé—´å®šä¹‰ | Metric Space Definition

> æ•™å­¦å ä½ï¼šä»¥ä¸‹ä¸ºæ¦‚å¿µæ€§ç¤ºæ„ï¼Œéå¯ç¼–è¯‘ä»£ç ã€‚

```lean
-- åº¦é‡ç©ºé—´å®šä¹‰
class MetricSpace (X : Type) where
  dist : X â†’ X â†’ â„
  dist_self : âˆ€ x : X, dist x x = 0
  dist_comm : âˆ€ x y : X, dist x y = dist y x
  dist_triangle : âˆ€ x y z : X, dist x z â‰¤ dist x y + dist y z
  eq_of_dist_eq_zero : âˆ€ x y : X, dist x y = 0 â†’ x = y

-- åº¦é‡ç©ºé—´ä¸Šçš„æ‹“æ‰‘
instance {X : Type} [MetricSpace X] : TopologicalSpace X where
  IsOpen s := âˆ€ x âˆˆ s, âˆƒ Îµ > 0, âˆ€ y, dist x y < Îµ â†’ y âˆˆ s
  isOpen_univ := fun x _ => âŸ¨1, by norm_num, fun y _ => trivialâŸ©
  isOpen_inter := sorry
  isOpen_sUnion := sorry
```

### åº¦é‡ç©ºé—´æ€§è´¨ | Metric Space Properties

> æ•™å­¦å ä½ï¼šä»¥ä¸‹ä¸ºæ¦‚å¿µæ€§ç¤ºæ„ï¼Œéå¯ç¼–è¯‘ä»£ç ã€‚

```lean
-- åº¦é‡ç©ºé—´çš„åŸºæœ¬æ€§è´¨
theorem MetricSpace.dist_nonneg (X : Type) [MetricSpace X] (x y : X) : 0 â‰¤ dist x y := by
  have h := MetricSpace.dist_triangle x y x
  simp [MetricSpace.dist_self] at h
  linarith

-- åº¦é‡ç©ºé—´ä¸­çš„æ”¶æ•›
def Tendsto {X : Type} [MetricSpace X] (f : â„• â†’ X) (l : X) : Prop :=
  âˆ€ Îµ > 0, âˆƒ N : â„•, âˆ€ n â‰¥ N, dist (f n) l < Îµ

-- æŸ¯è¥¿åºåˆ—
def Cauchy {X : Type} [MetricSpace X] (f : â„• â†’ X) : Prop :=
  âˆ€ Îµ > 0, âˆƒ N : â„•, âˆ€ m n â‰¥ N, dist (f m) (f n) < Îµ
```

### åº¦é‡è¯±å¯¼æ‹“æ‰‘å¯è¿è¡Œæ ·ä¾‹ | Metricâ†’Topology Runnable Samples

```lean
-- å¼€çƒæ˜¯å¼€é›†
theorem isOpen_ball (x : â„) (r : â„) : IsOpen (Metric.ball x r) := by
  simpa using Metric.isOpen_ball

-- å‡½æ•° x â†¦ dist x a è¿ç»­
theorem continuous_dist_to (a : â„) : Continuous (fun x : â„ => dist x a) := by
  simpa using (continuous_id.dist continuous_const)
```

## 3. æé™ç†è®º | Limit Theory

### å‡½æ•°æé™ | Function Limits

> æ•™å­¦å ä½ï¼šä»¥ä¸‹ä¸ºæ¦‚å¿µæ€§ç¤ºæ„ï¼Œéå¯ç¼–è¯‘ä»£ç ã€‚

```lean
-- å‡½æ•°æé™å®šä¹‰
def Tendsto {Î± Î² : Type} [TopologicalSpace Î±] [TopologicalSpace Î²] (f : Î± â†’ Î²) (l : Î²) (a : Î±) : Prop :=
  âˆ€ U : Set Î², IsOpen U â†’ l âˆˆ U â†’ âˆƒ V : Set Î±, IsOpen V â†’ a âˆˆ V â†’ âˆ€ x âˆˆ V, f x âˆˆ U

-- æ•°åˆ—æé™
def SeqLimit {Î± : Type} [TopologicalSpace Î±] (f : â„• â†’ Î±) (l : Î±) : Prop :=
  Tendsto f l atTop

-- æé™çš„å”¯ä¸€æ€§
theorem Tendsto.unique {Î± Î² : Type} [TopologicalSpace Î±] [TopologicalSpace Î²] [T2Space Î²]
  (f : Î± â†’ Î²) (a : Î±) (lâ‚ lâ‚‚ : Î²) (hâ‚ : Tendsto f lâ‚ a) (hâ‚‚ : Tendsto f lâ‚‚ a) : lâ‚ = lâ‚‚ := by
  sorry -- éœ€è¦è¯æ˜æé™çš„å”¯ä¸€æ€§
```

### æé™æ€§è´¨ | Limit Properties

> æ•™å­¦å ä½ï¼šä»¥ä¸‹ä¸ºæ¦‚å¿µæ€§ç¤ºæ„ï¼Œéå¯ç¼–è¯‘ä»£ç ã€‚

```lean
-- æé™çš„ä»£æ•°è¿ç®—
theorem Tendsto.add {Î± : Type} [TopologicalSpace Î±] [Add Î±] [ContinuousAdd Î±]
  (f g : Î± â†’ Î±) (a lâ‚ lâ‚‚ : Î±) (hf : Tendsto f lâ‚ a) (hg : Tendsto g lâ‚‚ a) :
  Tendsto (f + g) (lâ‚ + lâ‚‚) a := by
  sorry -- éœ€è¦è¯æ˜æé™çš„åŠ æ³•

theorem Tendsto.mul {Î± : Type} [TopologicalSpace Î±] [Mul Î±] [ContinuousMul Î±]
  (f g : Î± â†’ Î±) (a lâ‚ lâ‚‚ : Î±) (hf : Tendsto f lâ‚ a) (hg : Tendsto g lâ‚‚ a) :
  Tendsto (f * g) (lâ‚ * lâ‚‚) a := by
  sorry -- éœ€è¦è¯æ˜æé™çš„ä¹˜æ³•
```

### æé™å¯è¿è¡Œæ ·ä¾‹ | Limit Runnable Samples

```lean
-- å¸¸å€¼å‡½æ•°åœ¨ä»»æ„æ»¤å­ä¸‹æ”¶æ•›åˆ°è¯¥å¸¸å€¼
theorem tendsto_const_nhds (l : Filter Î±) (c : Î²) :
  Tendsto (fun _ : Î± => c) l (ğ“ c) := by
  simpa using Filter.tendsto_const_nhds (l:=l) (a:=c)

-- åŠ æ³•çš„æé™å®šç†ï¼ˆä»¥ â„ ä¸ºä¾‹ï¼‰
theorem tendsto_add_example (f g : â„• â†’ â„) (lâ‚ lâ‚‚ : â„)
    (hf : Tendsto f atTop (ğ“ lâ‚)) (hg : Tendsto g atTop (ğ“ lâ‚‚)) :
  Tendsto (fun n => f n + g n) atTop (ğ“ (lâ‚ + lâ‚‚)) := by
  simpa using hf.add hg

-- å®æ•°ä¸Šï¼šæé™å”¯ä¸€
theorem tendsto_unique_real (f : â„• â†’ â„) (lâ‚ lâ‚‚ : â„)
    (hâ‚ : Tendsto f atTop (ğ“ lâ‚)) (hâ‚‚ : Tendsto f atTop (ğ“ lâ‚‚)) :
  lâ‚ = lâ‚‚ := by
  -- â„ ä¸º T2ï¼ˆHausdorffï¼‰ç©ºé—´ï¼Œæé™å”¯ä¸€
  simpa using tendsto_nhds_unique hâ‚ hâ‚‚
```

## 9. ç»ƒä¹ ä¸å‚è€ƒè§£ | Exercises with Hints

```lean
-- ç»ƒä¹ 1ï¼ˆæ‹“æ‰‘ï¼‰ï¼šå¼€é›†çš„æœ‰é™äº¤ä»ä¸ºå¼€ï¼ˆåœ¨ â„ ä¸Šï¼‰
theorem ex_isOpen_inter (U V : Set â„) (hU : IsOpen U) (hV : IsOpen V) : IsOpen (U âˆ© V) := by
  simpa using hU.inter hV

-- ç»ƒä¹ 2ï¼ˆåº¦é‡ï¼‰ï¼šç»å¯¹å€¼è¿ç»­æ¨å‡º |x| çš„è¿ç»­æ€§ï¼ˆå·²ç”± Mathlib æä¾›ï¼‰
theorem ex_continuous_abs : Continuous fun x : â„ => |x| := by
  simpa using continuous_abs

-- ç»ƒä¹ 3ï¼ˆæé™ï¼‰ï¼šè‹¥ f â†’ lâ‚ï¼Œg â†’ lâ‚‚ï¼Œåˆ™ f+g â†’ lâ‚+lâ‚‚ï¼ˆæ•°åˆ—ç‰ˆæœ¬ï¼‰
theorem ex_tendsto_add_seq (f g : â„• â†’ â„) (lâ‚ lâ‚‚ : â„)
    (hf : Tendsto f atTop (ğ“ lâ‚)) (hg : Tendsto g atTop (ğ“ lâ‚‚)) :
  Tendsto (fun n => f n + g n) atTop (ğ“ (lâ‚ + lâ‚‚)) := by
  simpa using hf.add hg

-- ç»ƒä¹ 4ï¼ˆç§¯åˆ†ï¼‰ï¼šå¸¸æ•°å‡½æ•°åœ¨åŒºé—´ä¸Šçš„ç§¯åˆ†
theorem ex_interval_integral_const (a b : â„) :
  âˆ« x in a..b, (1 : â„) = b - a := by
  simpa using intervalIntegral.integral_const (a:=a) (b:=b) (c:=(1:â„))
```

## 4. è¿ç»­æ€§ | Continuity

### è¿ç»­å‡½æ•° | Continuous Functions

> æ•™å­¦å ä½ï¼šä»¥ä¸‹ä¸ºæ¦‚å¿µæ€§ç¤ºæ„ï¼Œéå¯ç¼–è¯‘ä»£ç ã€‚

```text
-- è¿ç»­å‡½æ•°å®šä¹‰
def ContinuousAt {X Y : Type} [TopologicalSpace X] [TopologicalSpace Y] (f : X â†’ Y) (x : X) : Prop :=
  âˆ€ U : Set Y, IsOpen U â†’ f x âˆˆ U â†’ âˆƒ V : Set X, IsOpen V â†’ x âˆˆ V â†’ âˆ€ y âˆˆ V, f y âˆˆ U

-- å…¨å±€è¿ç»­æ€§
def Continuous {X Y : Type} [TopologicalSpace X] [TopologicalSpace Y] (f : X â†’ Y) : Prop :=
  âˆ€ x : X, ContinuousAt f x

-- è¿ç»­å‡½æ•°çš„å¤åˆ
theorem Continuous.comp {X Y Z : Type} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]
  (f : X â†’ Y) (g : Y â†’ Z) (hf : Continuous f) (hg : Continuous g) : Continuous (g âˆ˜ f) := by
  simpa [Function.comp] using hg.comp hf
```

### è¿ç»­å‡½æ•°æ€§è´¨ | Continuous Function Properties

> æ•™å­¦å ä½ï¼šä»¥ä¸‹ä¸ºæ¦‚å¿µæ€§ç¤ºæ„ï¼Œéå¯ç¼–è¯‘ä»£ç ã€‚

```text
-- è¿ç»­å‡½æ•°çš„ä»£æ•°è¿ç®—
theorem Continuous.add {X : Type} [TopologicalSpace X] [Add X] [ContinuousAdd X]
  (f g : X â†’ X) (hf : Continuous f) (hg : Continuous g) : Continuous (f + g) := by
  intro x
  sorry -- éœ€è¦è¯æ˜è¿ç»­å‡½æ•°çš„åŠ æ³•

-- è¿ç»­å‡½æ•°çš„ç´§è‡´æ€§ä¿æŒ
theorem Continuous.compact_image {X Y : Type} [TopologicalSpace X] [TopologicalSpace Y]
  (f : X â†’ Y) (hf : Continuous f) (s : Set X) (hs : IsCompact s) : IsCompact (f '' s) := by
  sorry -- éœ€è¦è¯æ˜è¿ç»­å‡½æ•°ä¿æŒç´§è‡´æ€§
```

### è¿ç»­æ€§å¯è¿è¡Œæ ·ä¾‹ | Continuity Runnable Samples

```lean
-- å¤åˆçš„è¿ç»­æ€§ï¼ˆä»¥å®æ•°ä¸ºä¾‹ï¼‰
theorem continuous_comp_example : Continuous (fun x : â„ => (x + x) + 1) := by
  simpa using (continuous_const.add ((continuous_id.add continuous_id)))

-- å¤šé¡¹å¼å‡½æ•°è¿ç»­ï¼ˆç”±ä»£æ•°è¿ç®—é—­åŒ…ï¼‰
theorem continuous_poly_example : Continuous (fun x : â„ => x^2 + 3*x + 2) := by
  simpa using ((continuous_id.pow 2).add ((continuous_const.mul continuous_id)).add continuous_const)

-- è¿ç»­å‡½æ•°ä¿æŒç´§è‡´ï¼ˆå¯è¿è¡Œç¤ºä¾‹ï¼‰
theorem isCompact_image_example (f : â„ â†’ â„) (s : Set â„)
    (hf : Continuous f) (hs : IsCompact s) :
  IsCompact (f '' s) := by
  simpa using hs.image hf

-- ç»å¯¹å€¼å‡½æ•°è¿ç»­
theorem continuous_abs_real : Continuous fun x : â„ => |x| := by
  simpa using continuous_abs
```

## 5. å¾®åˆ†å­¦ | Differential Calculus

### å¯¼æ•°å®šä¹‰ | Derivative Definition

> æ•™å­¦å ä½ï¼šä»¥ä¸‹ä¸ºæ¦‚å¿µæ€§ç¤ºæ„ï¼Œéå¯ç¼–è¯‘ä»£ç ã€‚

```text
-- å¯¼æ•°å®šä¹‰
def HasDerivAt {ğ•œ : Type} [NontriviallyNormedField ğ•œ] {E F : Type} [NormedAddCommGroup E] [NormedSpace ğ•œ E] [NormedAddCommGroup F] [NormedSpace ğ•œ F] (f : E â†’ F) (f' : E â†’L[ğ•œ] F) (x : E) : Prop :=
  Tendsto (fun y => â€–y - xâ€–â»Â¹ * â€–f y - f x - f' (y - x)â€–) (ğ“ 0) (ğ“ 0)

-- å¯å¾®å‡½æ•°
def DifferentiableAt {ğ•œ : Type} [NontriviallyNormedField ğ•œ] {E F : Type} [NormedAddCommGroup E] [NormedSpace ğ•œ E] [NormedAddCommGroup F] [NormedSpace ğ•œ F] (f : E â†’ F) (x : E) : Prop :=
  âˆƒ f' : E â†’L[ğ•œ] F, HasDerivAt f f' x
```

### å¯¼æ•°æ€§è´¨ | Derivative Properties

> æ•™å­¦å ä½ï¼šä»¥ä¸‹ä¸ºæ¦‚å¿µæ€§ç¤ºæ„ï¼Œéå¯ç¼–è¯‘ä»£ç ã€‚

```text
-- å¯¼æ•°çš„å”¯ä¸€æ€§
theorem HasDerivAt.unique {ğ•œ : Type} [NontriviallyNormedField ğ•œ] {E F : Type} [NormedAddCommGroup E] [NormedSpace ğ•œ E] [NormedAddCommGroup F] [NormedSpace ğ•œ F]
  (f : E â†’ F) (x : E) (f'â‚ f'â‚‚ : E â†’L[ğ•œ] F) (hâ‚ : HasDerivAt f f'â‚ x) (hâ‚‚ : HasDerivAt f f'â‚‚ x) : f'â‚ = f'â‚‚ := by
  sorry -- éœ€è¦è¯æ˜å¯¼æ•°çš„å”¯ä¸€æ€§

-- é“¾å¼æ³•åˆ™
theorem HasDerivAt.comp {ğ•œ : Type} [NontriviallyNormedField ğ•œ] {E F G : Type} [NormedAddCommGroup E] [NormedSpace ğ•œ E] [NormedAddCommGroup F] [NormedSpace ğ•œ F] [NormedAddCommGroup G] [NormedSpace ğ•œ G]
  (f : E â†’ F) (g : F â†’ G) (x : E) (f' : E â†’L[ğ•œ] F) (g' : F â†’L[ğ•œ] G) (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' (f x)) :
  HasDerivAt (g âˆ˜ f) (g' âˆ˜ f') x := by
  sorry -- éœ€è¦è¯æ˜é“¾å¼æ³•åˆ™
```

## 6. ç§¯åˆ†å­¦ | Integral Calculus

### å¯è¿è¡Œæ ·ä¾‹ | Runnable Samples

```lean
-- åŒºé—´å¸¸æ•°ç§¯åˆ†
theorem interval_integral_const_one (a b : â„) :
  âˆ« x in a..b, (1 : â„) = b - a := by
  simpa using intervalIntegral.integral_const (a:=a) (b:=b) (c:=(1:â„))

-- å¯åŠ æ€§ï¼ˆéœ€å¯ç§¯æ€§å‰æï¼‰
theorem interval_integral_add (f g : â„ â†’ â„) (a b : â„)
    (hf : IntervalIntegrable f volume a b)
    (hg : IntervalIntegrable g volume a b) :
  âˆ« x in a..b, (f x + g x) = (âˆ« x in a..b, f x) + (âˆ« x in a..b, g x) := by
  simpa using intervalIntegral.integral_add hf hg
```

### ç§¯åˆ†å®šä¹‰ | Integral Definition

> æ•™å­¦å ä½ï¼šä»¥ä¸‹ä¸ºæ¦‚å¿µæ€§ç¤ºæ„ï¼Œéå¯ç¼–è¯‘ä»£ç ã€‚

```text
-- å¯ç§¯å‡½æ•°
def Integrable {Î± : Type} [MeasurableSpace Î±] {E : Type} [NormedAddCommGroup E] (f : Î± â†’ E) (Î¼ : Measure Î±) : Prop :=
  âˆ«â» a, â€–f aâ€–â‚Š âˆ‚Î¼ < âˆ

-- ç§¯åˆ†å®šä¹‰
def integral {Î± : Type} [MeasurableSpace Î±] {E : Type} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E] (f : Î± â†’ E) (Î¼ : Measure Î±) : E :=
  sorry -- éœ€è¦å®šä¹‰ç§¯åˆ†

-- åŸºæœ¬ç§¯åˆ†
theorem integral_const {Î± : Type} [MeasurableSpace Î±] {E : Type} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E] (c : E) (Î¼ : Measure Î±) :
  âˆ« a, c âˆ‚Î¼ = c * (Î¼ univ) := by
  sorry -- éœ€è¦è¯æ˜å¸¸æ•°ç§¯åˆ†
```

### ç§¯åˆ†æ€§è´¨ | Integral Properties

> æ•™å­¦å ä½ï¼šä»¥ä¸‹ä¸ºæ¦‚å¿µæ€§ç¤ºæ„ï¼Œéå¯ç¼–è¯‘ä»£ç ã€‚

```text
-- ç§¯åˆ†çš„çº¿æ€§æ€§
theorem integral_add {Î± : Type} [MeasurableSpace Î±] {E : Type} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E]
  (f g : Î± â†’ E) (Î¼ : Measure Î±) (hf : Integrable f Î¼) (hg : Integrable g Î¼) :
  âˆ« a, f a + g a âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ + âˆ« a, g a âˆ‚Î¼ := by
  sorry -- éœ€è¦è¯æ˜ç§¯åˆ†çš„åŠ æ³•

-- ç§¯åˆ†çš„å•è°ƒæ€§
theorem integral_mono {Î± : Type} [MeasurableSpace Î±] (f g : Î± â†’ â„) (Î¼ : Measure Î±) (hf : Integrable f Î¼) (hg : Integrable g Î¼) (h : f â‰¤ g) :
  âˆ« a, f a âˆ‚Î¼ â‰¤ âˆ« a, g a âˆ‚Î¼ := by
  sorry -- éœ€è¦è¯æ˜ç§¯åˆ†çš„å•è°ƒæ€§
```

## 7. å¤åˆ†æ | Complex Analysis

### å¤å‡½æ•° | Complex Functions

```lean
-- å¤å‡½æ•°å®šä¹‰
def ComplexFunction := â„‚ â†’ â„‚

-- å¤å‡½æ•°çš„è¿ç»­æ€§
def ComplexContinuous (f : ComplexFunction) : Prop :=
  âˆ€ z : â„‚, âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ w : â„‚, |w - z| < Î´ â†’ |f w - f z| < Îµ

-- å¤å‡½æ•°çš„å¯å¾®æ€§
def ComplexDifferentiable (f : ComplexFunction) (z : â„‚) : Prop :=
  âˆƒ f' : â„‚, Tendsto (fun w => (f w - f z) / (w - z)) (ğ“ f') (ğ“ z)
```

### å¤åˆ†ææ€§è´¨ | Complex Analysis Properties

```lean
-- æŸ¯è¥¿-é»æ›¼æ–¹ç¨‹
theorem Cauchy_Riemann (f : ComplexFunction) (z : â„‚) (hf : ComplexDifferentiable f z) :
  âˆƒ u v : â„ â†’ â„, f z = u (z.re) + v (z.im) * I âˆ§ 
  âˆ‚u/âˆ‚x = âˆ‚v/âˆ‚y âˆ§ âˆ‚u/âˆ‚y = -âˆ‚v/âˆ‚x := by
  sorry -- éœ€è¦è¯æ˜æŸ¯è¥¿-é»æ›¼æ–¹ç¨‹

-- æŸ¯è¥¿ç§¯åˆ†å®šç†
theorem Cauchy_Integral_Theorem (f : ComplexFunction) (Î³ : Path â„‚) (hf : ComplexDifferentiable f) :
  âˆ« z in Î³, f z dz = 0 := by
  sorry -- éœ€è¦è¯æ˜æŸ¯è¥¿ç§¯åˆ†å®šç†
```

## 8. æ³›å‡½åˆ†æ | Functional Analysis

### å·´æ‹¿èµ«ç©ºé—´ | Banach Spaces

```lean
-- å·´æ‹¿èµ«ç©ºé—´å®šä¹‰
class BanachSpace (E : Type) extends NormedAddCommGroup E, NormedSpace â„ E, CompleteSpace E

-- æœ‰ç•Œçº¿æ€§ç®—å­
structure BoundedLinearMap (E F : Type) [NormedAddCommGroup E] [NormedSpace â„ E] [NormedAddCommGroup F] [NormedSpace â„ F] where
  toFun : E â†’ F
  map_add : âˆ€ x y : E, toFun (x + y) = toFun x + toFun y
  map_smul : âˆ€ (c : â„) (x : E), toFun (c â€¢ x) = c â€¢ toFun x
  bound : âˆƒ C : â„, âˆ€ x : E, â€–toFun xâ€– â‰¤ C * â€–xâ€–
```

### æ³›å‡½åˆ†ææ€§è´¨ | Functional Analysis Properties

```lean
-- å¼€æ˜ å°„å®šç†
theorem Open_Mapping_Theorem (E F : Type) [BanachSpace E] [BanachSpace F]
  (T : BoundedLinearMap E F) (hT : Function.Surjective T.toFun) :
  Function.Open T.toFun := by
  sorry -- éœ€è¦è¯æ˜å¼€æ˜ å°„å®šç†

-- é—­å›¾åƒå®šç†
theorem Closed_Graph_Theorem (E F : Type) [BanachSpace E] [BanachSpace F]
  (T : E â†’ F) (hT : âˆ€ x y : E, T (x + y) = T x + T y) (hT' : âˆ€ (c : â„) (x : E), T (c â€¢ x) = c â€¢ T x) :
  Continuous T := by
  sorry -- éœ€è¦è¯æ˜é—­å›¾åƒå®šç†
```

---

*ç›¸å…³é“¾æ¥ï¼š*

- [æ•°å­¦åº“æ¶æ„](./01-æ•°å­¦åº“æ¶æ„.md)
- [åŸºç¡€æ•°å­¦æ¦‚å¿µ](./02-åŸºç¡€æ•°å­¦æ¦‚å¿µ.md)
- [ä»£æ•°ç»“æ„](./03-ä»£æ•°ç»“æ„.md)
- ç»ƒä¹ ï¼ˆå¯è¿è¡Œï¼‰ï¼š`Lean/Exercises/Analysis/Real.lean`ã€`Lean/Exercises/Analysis/Complex.lean`ã€`Lean/Exercises/Topology/Basic.lean`
- è·¨ç« èŠ‚ç»ƒä¹ ç´¢å¼•ï¼š`Lean/Exercises/è·¨ç« èŠ‚ç»ƒä¹ ç´¢å¼•.md`

---

## é™„ï¼šç‰ˆæœ¬ä¸å…¼å®¹æ€§æ³¨è®° | Version & Compatibility Notes

- ç‰ˆæœ¬åŸºçº¿ï¼šå‚è§ `Lean/ç‰ˆæœ¬åŒæ­¥ç´¢å¼•.md`ï¼›åˆ†æ/æ‹“æ‰‘ç¤ºä¾‹å¤šä¾èµ– `Mathlib` çš„ measure/topology/analysis å­åº“ã€‚
- API å˜åŠ¨ï¼šå¦‚ `TopologicalSpace`ã€`Measure`ã€`HasDerivAt` ç­‰å®šä¹‰æˆ–åå­—è°ƒæ•´ï¼Œè¯·ä»¥ `mathlib4_docs` ä¸ºå‡†æ›´æ–°å¯¼å…¥ä¸ä»£ç ã€‚
- è¿è¡Œå»ºè®®ï¼šå¸¦æœ‰ `sorry` çš„ç†è®ºæ€§æ®µè½ç”¨äºæ•™å­¦å ä½ï¼Œé¡¹ç›®ä¸­è¯·ç”¨ `Mathlib` å·²è¯å®šç†æ›¿æ¢æˆ–è¡¥å…¨è¯æ˜ã€‚

## å…¼å®¹æ€§ä¸å¯¹é½çŠ¶æ€ï¼ˆ2025-09ï¼‰ | Compatibility & Alignment

- å·¥å…·é“¾ï¼šè·Ÿéš Lean4 æœ€æ–°ç¨³å®šç‰ˆï¼›è¯¦è§ `Lean/ç‰ˆæœ¬åŒæ­¥ç´¢å¼•.md`ã€‚
- mathlib4ï¼šåˆ†æ/æ‹“æ‰‘æ¨¡å—ä»¥ `stable` æˆ–ç´¢å¼•é¡µè®°å½•æäº¤éªŒè¯ã€‚
- å¯¼å…¥æ ¸å¯¹ï¼š`Topology/Basic`ã€`Measure/Integral/IntervalIntegral`ã€`Analysis/Calculus/Derivative` ç°è¡Œè·¯å¾„å¯ç”¨ã€‚
- ç¤ºä¾‹çŠ¶æ€ï¼šæœ¬é¡µâ€œæœ€å°å¯è¿è¡Œè¯æ˜æ ·ä¾‹/ç§¯åˆ†æ ·ä¾‹/æé™æ ·ä¾‹â€åœ¨ `lake` é¡¹ç›®ä¸‹é€šè¿‡ï¼›å ä½ `sorry` æ®µä¸ºæ•™å­¦ç”¨ã€‚
