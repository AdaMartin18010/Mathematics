# 依赖类型编程 | Dependent Type Programming

> 最小前置导入（建议在可运行的 `lake` 项目中使用）：

```lean
import Std
import Mathlib
open scoped BigOperators
```

## 常用模块导入清单 | Common Imports Cheat Sheet

- 依赖类型与基础：`import Mathlib/Data/Fin/Basic`，`import Mathlib/Data/Vector/Basic`
- 等同性与异质等同性：`import Mathlib/Init/Logic`，`import Mathlib/Init/Logic`（含 `Eq/HEq` 基本工具）
- 决定性与判定：`import Mathlib/Data/Bool/Basic`，`import Mathlib/Logic/Decidable`
- 列表/数组与索引：`import Mathlib/Data/List/Basic`，`import Mathlib/Data/Array/Basic`
- 常用战术：`import Mathlib/Tactic/Linarith`，`import Mathlib/Tactic/NormNum`，`import Mathlib/Tactic`

## 结构层级与概念映射 | Hierarchy & Concept Mapping

- 依赖函数（Π-类型）：`(x : α) → β x`；特殊情形为普通函数 `α → β`
- 依赖积（Σ-类型）：`Σ x : α, β x`；对应“带证据的数据对”
- 索引族与容器：`Fin n`（界限索引），`Vector α n`（长度索引向量）
- 等同性：`Eq a b`（同型等），`HEq a b`（异型等，依赖类型下常用）
- 决定性：`Decidable p`、`DecidableEq α`（可判定谓词/等式）
- 类型类：`Inhabited/DecidableEq/Insts` 等为构造算法与性质提供实例

提示：本文中“从零搭建”的 `Fin/Vector` 等定义仅用于教学直观；实际项目优先使用 `Mathlib` 已有实现以避免冲突。

## 1. 依赖类型基础 | Dependent Type Fundamentals

### Π类型 | Pi Types

```lean
-- 依赖函数类型
def dependent_function (n : Nat) : Fin n → Nat :=
  fun i => i.val

-- 多参数依赖函数
def dependent_multi (n : Nat) (m : Nat) : Fin n → Fin m → Nat :=
  fun i j => i.val + j.val

-- 类型依赖类型
def type_dependent (α : Type) (n : Nat) : Vector α n → Nat :=
  fun v => v.length
```

### Σ类型 | Sigma Types

```lean
-- 依赖积类型
def dependent_pair (n : Nat) : Σ (i : Fin n), Nat :=
  ⟨0, n⟩

-- 存在类型
def exists_example : ∃ n : Nat, n > 0 :=
  ⟨1, Nat.one_pos⟩

-- 依赖记录类型
structure DependentRecord (n : Nat) where
  value : Fin n
  proof : value.val < n
```

## 2. 索引类型族 | Indexed Type Families

### 有限类型 | Finite Types

```lean
-- 有限类型族
inductive Fin : Nat → Type where
  | zero (n : Nat) : Fin (n + 1)
  | succ (n : Nat) (i : Fin n) : Fin (n + 1)

-- 使用示例
def fin_example : Fin 3 := Fin.succ 2 (Fin.succ 1 (Fin.zero 0))
```

### 向量类型 | Vector Types

```lean
-- 长度索引向量
inductive Vector (α : Type) : Nat → Type where
  | nil : Vector α 0
  | cons (head : α) (tail : Vector α n) : Vector α (n + 1)

-- 向量操作
def Vector.head {α : Type} {n : Nat} (v : Vector α (n + 1)) : α :=
  match v with
  | Vector.cons h _ => h

def Vector.tail {α : Type} {n : Nat} (v : Vector α (n + 1)) : Vector α n :=
  match v with
  | Vector.cons _ t => t
```

## 3. 相等类型 | Equality Types

### 命题相等 | Propositional Equality

```lean
-- 相等类型定义
inductive Eq {α : Type} (a : α) : α → Prop where
  | refl : Eq a a

-- 相等性质
theorem eq_symm {α : Type} (a b : α) : a = b → b = a :=
  fun h => h ▸ rfl

theorem eq_trans {α : Type} (a b c : α) : a = b → b = c → a = c :=
  fun hab hbc => hab ▸ hbc
```

### 计算相等 | Computational Equality

```lean
-- 定义计算相等
def comp_eq (a b : Nat) : Prop :=
  match a, b with
  | 0, 0 => True
  | n + 1, m + 1 => comp_eq n m
  | _, _ => False

-- 计算相等性质
theorem comp_eq_refl (a : Nat) : comp_eq a a := by
  induction a with
  | zero => trivial
  | succ n ih => exact ih
```

## 4. 归纳类型与递归 | Inductive Types and Recursion

### 复杂归纳类型 | Complex Inductive Types

```lean
-- 树类型
inductive Tree (α : Type) where
  | leaf (value : α) : Tree α
  | node (left right : Tree α) : Tree α

-- 树的大小
def Tree.size {α : Type} : Tree α → Nat
  | Tree.leaf _ => 1
  | Tree.node l r => Tree.size l + Tree.size r

-- 树的高度
def Tree.height {α : Type} : Tree α → Nat
  | Tree.leaf _ => 0
  | Tree.node l r => 1 + max (Tree.height l) (Tree.height r)
```

### 依赖归纳类型 | Dependent Inductive Types

```lean
-- 长度索引列表
inductive DList (α : Type) : Nat → Type where
  | nil : DList α 0
  | cons (head : α) (tail : DList α n) : DList α (n + 1)

-- 依赖列表操作
def DList.append {α : Type} {n m : Nat} (xs : DList α n) (ys : DList α m) : DList α (n + m) :=
  match xs with
  | DList.nil => ys
  | DList.cons h t => DList.cons h (DList.append t ys)
```

## 5. 类型类与实例 | Type Classes and Instances

### 依赖类型类 | Dependent Type Classes

```lean
-- 可比较类型类
class Comparable (α : Type) where
  compare : α → α → Ordering
  compare_refl : ∀ a : α, compare a a = Ordering.eq
  compare_symm : ∀ a b : α, compare a b = Ordering.gt ↔ compare b a = Ordering.lt

-- 实例定义
instance : Comparable Nat where
  compare a b :=
    if a < b then Ordering.lt
    else if a = b then Ordering.eq
    else Ordering.gt
  compare_refl a := by simp [compare]
  compare_symm a b := by simp [compare]; cases Nat.lt_trichotomy a b <;> simp
```

### 多参数类型类 | Multi-Parameter Type Classes

```lean
-- 关系类型类
class Relation (α : Type) (β : Type) where
  rel : α → β → Prop
  refl : ∀ a : α, rel a a
  symm : ∀ a b : α, rel a b → rel b a
  trans : ∀ a b c : α, rel a b → rel b c → rel a c

-- 等价关系实例
instance : Relation Nat Nat where
  rel := Eq
  refl := fun a => rfl
  symm := fun a b h => h.symm
  trans := fun a b c hab hbc => hab.trans hbc
```

## 6. 证明相关编程 | Proof-Relevant Programming

### 证明对象 | Proof Objects

```lean
-- 证明作为数据
def proof_example (n : Nat) : n + 0 = n :=
  Nat.add_zero n

-- 条件证明
def conditional_proof (n : Nat) (h : n > 0) : ∃ m : Nat, m + 1 = n :=
  ⟨n - 1, Nat.sub_add_cancel (Nat.pos_iff_ne_zero.mp h)⟩
```

### 证明策略 | Proof Strategies

```lean
-- 构造性证明
def constructive_proof (p q : Prop) : p ∨ q → (p → r) → (q → r) → r :=
  fun hpq hpr hqr =>
    match hpq with
    | Or.inl hp => hpr hp
    | Or.inr hq => hqr hq

-- 非构造性证明（使用经典逻辑）
def non_constructive_proof (p : Prop) : ¬¬p → p :=
  fun hnnp => Classical.by_contradiction (fun hnp => hnnp hnp)
```

## 7. 高级类型技术 | Advanced Type Techniques

### 类型级编程 | Type-Level Programming

```lean
-- 类型级自然数
inductive TNat : Type where
  | zero : TNat
  | succ : TNat → TNat

-- 类型级加法
def TNat.add : TNat → TNat → TNat
  | TNat.zero, n => n
  | TNat.succ m, n => TNat.succ (TNat.add m n)

-- 类型级比较
def TNat.le : TNat → TNat → Prop
  | TNat.zero, _ => True
  | TNat.succ m, TNat.zero => False
  | TNat.succ m, TNat.succ n => TNat.le m n
```

### 类型族编程 | Type Family Programming

```lean
-- 类型族定义
def TypeFamily (n : Nat) : Type :=
  match n with
  | 0 => Unit
  | n + 1 => Nat × TypeFamily n

-- 类型族操作
def TypeFamily.map {n : Nat} (f : Nat → Nat) : TypeFamily n → TypeFamily n :=
  match n with
  | 0 => fun _ => ()
  | n + 1 => fun ⟨x, xs⟩ => ⟨f x, TypeFamily.map f xs⟩
```

## 8. 实际应用 | Practical Applications

### 安全编程 | Safe Programming

```lean
-- 安全数组访问
def safe_array_access {α : Type} (arr : Array α) (i : Fin arr.size) : α :=
  arr.get i

-- 安全列表操作
def safe_list_head {α : Type} (xs : List α) (h : xs ≠ []) : α :=
  match xs with
  | [] => absurd h (fun h' => h' rfl)
  | x :: _ => x
```

### 可运行示例合集 | Runnable Snippets

```lean
-- 示例：使用 by-block 与 simp 证明简单性质
theorem vec_len_cons {α} (h : α) (t : List α) : (h :: t).length = t.length + 1 := by
  simp

-- 示例：Nat 的加法交换
theorem add_comm_example (a b : Nat) : a + b = b + a := by
  exact Nat.add_comm a b

-- 示例：存在性构造
theorem exists_pos : ∃ n : Nat, n > 0 := by
  exact ⟨1, Nat.one_pos⟩
```

## 9. 练习与参考解 | Exercises with Hints

```lean
-- 练习1（Π-类型）：证明 (Π i : Fin n, α) 到函数类型的展开与回收互逆（n=0/1 情况）
theorem ex_pi_unit {α : Type} : ((Unit → α) ≃ α) :=
  { toFun := fun f => f ()
    invFun := fun a _ => a
    left_inv := by intro f; funext u; cases u; rfl
    right_inv := by intro a; rfl }

-- 练习2（Σ-类型）：从 (Σ n, Vector α n) 中投影长度
def ex_sigma_len {α : Type} (p : Σ n, Vector α n) : Nat := p.1

-- 练习3（Fin 索引）：安全取数组元素
def ex_safe_get {α : Type} (arr : Array α) (i : Fin arr.size) : α := arr.get i

-- 练习4（等同性）：使用 cong 与 congrArg 提升等式
theorem ex_congrArg {α β} (f : α → β) {x y : α} (h : x = y) : f x = f y := by
  simpa using congrArg f h
```

### 形式化规范 | Formal Specifications

```lean
-- 排序规范
def IsSorted {α : Type} [LE α] (xs : List α) : Prop :=
  ∀ i j : Fin xs.length, i.val < j.val → xs.get i ≤ xs.get j

-- 排序函数
def insertion_sort {α : Type} [LE α] [DecidableRel (· ≤ ·)] (xs : List α) : List α :=
  sorry -- 实现插入排序

-- 排序正确性
theorem insertion_sort_correct {α : Type} [LE α] [DecidableRel (· ≤ ·)] (xs : List α) :
  IsSorted (insertion_sort xs) :=
  sorry -- 证明排序正确性
```

---

*相关链接：*

- [形式化验证](./02-形式化验证.md)
- [函数式编程实践](./03-函数式编程实践.md)
- [AI与Lean集成](./04-AI与Lean集成.md)
