# 依赖类型基础 | Dependent Types Fundamentals

## 概述 | Overview

依赖类型是Lean类型系统的核心特性，允许类型依赖于值。这种强大的机制使得我们能够表达更精确的类型约束，实现更安全的程序。

Dependent types are a core feature of Lean's type system, allowing types to depend on values. This powerful mechanism enables us to express more precise type constraints and implement safer programs.

## 基本概念 | Basic Concepts

### 1. 依赖函数类型 | Dependent Function Types

```lean
-- 基本依赖函数类型 | Basic dependent function type
def identity (α : Type) (x : α) : α := x

-- 依赖函数类型语法 | Dependent function type syntax
-- (x : A) → B x 表示对于类型A的每个值x，返回类型B x
def dependentFunction (n : Nat) : (x : Nat) → (h : x < n) → Nat :=
  fun x h => x

-- 使用依赖函数 | Using dependent functions
#check identity Nat 5
#check dependentFunction 10
```

### 2. 依赖对类型 | Dependent Pair Types

```lean
-- 依赖对类型 | Dependent pair type
-- Σ x : A, B x 表示存在类型A的值x，使得B x成立
def dependentPair : Σ n : Nat, n > 0 :=
  ⟨1, by norm_num⟩

-- 依赖对类型的使用 | Using dependent pair types
def extractValue (p : Σ n : Nat, n > 0) : Nat :=
  p.1

def extractProof (p : Σ n : Nat, n > 0) : p.1 > 0 :=
  p.2

-- 示例 | Example
#eval extractValue dependentPair  -- 结果: 1
```

### 3. 依赖归纳类型 | Dependent Inductive Types

```lean
-- 依赖归纳类型 | Dependent inductive type
inductive Vector (α : Type) : Nat → Type where
  | nil : Vector α 0
  | cons : α → Vector α n → Vector α (n + 1)

-- 使用依赖归纳类型 | Using dependent inductive types
def Vector.head (v : Vector α (n + 1)) : α :=
  match v with
  | cons x _ => x

def Vector.tail (v : Vector α (n + 1)) : Vector α n :=
  match v with
  | cons _ xs => xs

-- 示例 | Example
def myVector : Vector Nat 3 :=
  Vector.cons 1 (Vector.cons 2 (Vector.cons 3 Vector.nil))

#eval Vector.head myVector  -- 结果: 1
```

## 高级依赖类型技术 | Advanced Dependent Type Techniques

### 1. 类型族 | Type Families

```lean
-- 类型族定义 | Type family definition
def ListType (n : Nat) : Type :=
  match n with
  | 0 => Unit
  | n + 1 => Nat × ListType n

-- 使用类型族 | Using type families
def emptyList : ListType 0 := ()
def singleList : ListType 1 := (1, ())
def doubleList : ListType 2 := (1, (2, ()))

-- 类型族函数 | Type family functions
def ListType.head (xs : ListType (n + 1)) : Nat :=
  match xs with
  | (x, _) => x
```

### 2. 索引类型 | Indexed Types

```lean
-- 索引类型 | Indexed type
inductive Fin : Nat → Type where
  | zero : Fin (n + 1)
  | succ : Fin n → Fin (n + 1)

-- 使用索引类型 | Using indexed types
def Fin.toNat : Fin n → Nat
  | .zero => 0
  | .succ i => i.toNat + 1

-- 索引类型的安全访问 | Safe access with indexed types
def Vector.get (v : Vector α n) (i : Fin n) : α :=
  match v, i with
  | cons x _, .zero => x
  | cons _ xs, .succ i => xs.get i

-- 示例 | Example
def myVector : Vector Nat 3 :=
  Vector.cons 1 (Vector.cons 2 (Vector.cons 3 Vector.nil))

#eval myVector.get Fin.zero  -- 结果: 1
#eval myVector.get (Fin.succ Fin.zero)  -- 结果: 2
```

### 3. 相等类型 | Equality Types

```lean
-- 相等类型 | Equality type
def equalTypes (x y : α) : Prop := x = y

-- 使用相等类型 | Using equality types
def transport (P : α → Type) (x y : α) (h : x = y) (px : P x) : P y :=
  h ▸ px

-- 相等类型的证明 | Proofs with equality types
theorem equalTypes_refl (x : α) : equalTypes x x := by
  rfl

theorem equalTypes_symm (x y : α) (h : equalTypes x y) : equalTypes y x := by
  rw [h]

theorem equalTypes_trans (x y z : α) (h1 : equalTypes x y) (h2 : equalTypes y z) : equalTypes x z := by
  rw [h1, h2]
```

## 依赖类型编程模式 | Dependent Type Programming Patterns

### 1. 安全列表操作 | Safe List Operations

```lean
-- 安全列表操作 | Safe list operations
def safeHead (xs : List α) (h : xs.length > 0) : α :=
  match xs with
  | x :: _ => x

def safeTail (xs : List α) (h : xs.length > 0) : List α :=
  match xs with
  | _ :: xs => xs

-- 使用安全操作 | Using safe operations
def processList (xs : List Nat) : Option Nat :=
  if h : xs.length > 0 then
    some (safeHead xs h)
  else
    none

-- 示例 | Example
#eval processList [1, 2, 3]  -- 结果: some 1
#eval processList []  -- 结果: none
```

### 2. 矩阵操作 | Matrix Operations

```lean
-- 矩阵类型 | Matrix type
def Matrix (α : Type) (m n : Nat) : Type :=
  Vector (Vector α n) m

-- 矩阵构造 | Matrix construction
def Matrix.zero (α : Type) (m n : Nat) : Matrix α m n :=
  Vector.replicate m (Vector.replicate n (0 : α))

-- 矩阵访问 | Matrix access
def Matrix.get (M : Matrix α m n) (i : Fin m) (j : Fin n) : α :=
  (M.get i).get j

-- 矩阵设置 | Matrix setting
def Matrix.set (M : Matrix α m n) (i : Fin m) (j : Fin n) (x : α) : Matrix α m n :=
  M.set i ((M.get i).set j x)

-- 示例 | Example
def myMatrix : Matrix Nat 2 3 :=
  Matrix.zero Nat 2 3

#eval myMatrix.get Fin.zero Fin.zero  -- 结果: 0
```

### 3. 状态机 | State Machines

```lean
-- 状态机类型 | State machine type
inductive State where
  | idle
  | running
  | paused
  | stopped

-- 状态转换类型 | State transition type
def Transition (from to : State) : Type :=
  match from, to with
  | .idle, .running => Unit
  | .running, .paused => Unit
  | .running, .stopped => Unit
  | .paused, .running => Unit
  | .paused, .stopped => Unit
  | .stopped, .idle => Unit
  | _, _ => Empty

-- 状态机操作 | State machine operations
def StateMachine.transition (from : State) (to : State) (t : Transition from to) : State :=
  to

-- 示例 | Example
def startMachine : Transition State.idle State.running := ()
def pauseMachine : Transition State.running State.paused := ()

#eval StateMachine.transition State.idle State.running startMachine  -- 结果: State.running
```

## 依赖类型证明 | Dependent Type Proofs

### 1. 类型安全证明 | Type Safety Proofs

```lean
-- 类型安全证明 | Type safety proof
theorem vectorHeadTypeSafe (v : Vector α (n + 1)) : Vector.head v : α := by
  match v with
  | cons x _ => exact x

theorem vectorTailTypeSafe (v : Vector α (n + 1)) : Vector.tail v : Vector α n := by
  match v with
  | cons _ xs => exact xs
```

### 2. 不变量证明 | Invariant Proofs

```lean
-- 不变量证明 | Invariant proof
theorem vectorLengthInvariant (v : Vector α n) : v.length = n := by
  match v with
  | nil => rfl
  | cons _ xs => 
    rw [Vector.length_cons]
    exact vectorLengthInvariant xs

-- 使用不变量 | Using invariants
def Vector.append (v1 : Vector α n) (v2 : Vector α m) : Vector α (n + m) :=
  match v1 with
  | nil => v2
  | cons x xs => cons x (xs.append v2)
```

## 实际应用示例 | Practical Application Examples

### 1. 数据库模式 | Database Schema

```lean
-- 数据库模式 | Database schema
structure Column (α : Type) where
  name : String
  nullable : Bool

def Schema : Type := List (Column Type)

-- 行类型 | Row type
def Row (s : Schema) : Type :=
  match s with
  | [] => Unit
  | col :: cols => (if col.nullable then Option col.1 else col.1) × Row cols

-- 表类型 | Table type
def Table (s : Schema) : Type := List (Row s)

-- 示例 | Example
def userSchema : Schema :=
  [⟨"id", Nat, false⟩, ⟨"name", String, false⟩, ⟨"email", String, true⟩]

def UserRow : Row userSchema :=
  (1, ("John", some "john@example.com"))
```

### 2. 网络协议 | Network Protocol

```lean
-- 网络协议类型 | Network protocol type
inductive MessageType where
  | request
  | response
  | error

def Message (t : MessageType) : Type :=
  match t with
  | .request => String
  | .response => Nat
  | .error => String

-- 协议处理 | Protocol handling
def handleMessage (t : MessageType) (msg : Message t) : Message .response :=
  match t, msg with
  | .request, req => 200
  | .response, resp => resp
  | .error, err => 500

-- 示例 | Example
def requestMsg : Message MessageType.request := "GET /api/data"
def responseMsg : Message MessageType.response := 200
def errorMsg : Message MessageType.error := "Not Found"

#eval handleMessage MessageType.request requestMsg  -- 结果: 200
```

## 最佳实践 | Best Practices

### 1. 依赖类型设计 | Dependent Type Design

```lean
-- 好的依赖类型设计 | Good dependent type design
-- 使用清晰的索引 | Use clear indices
inductive SafeList (α : Type) : Nat → Type where
  | nil : SafeList α 0
  | cons : α → SafeList α n → SafeList α (n + 1)

-- 避免过度复杂的依赖 | Avoid overly complex dependencies
-- 保持类型简单明了 | Keep types simple and clear
```

### 2. 性能考虑 | Performance Considerations

```lean
-- 考虑性能的依赖类型 | Performance-conscious dependent types
-- 使用结构体而非依赖对 | Use structures instead of dependent pairs
structure SafeVector (α : Type) (n : Nat) where
  data : List α
  length_eq : data.length = n

-- 避免不必要的依赖 | Avoid unnecessary dependencies
def simpleFunction (x : Nat) : Nat := x + 1  -- 简单函数
-- def complexFunction (x : Nat) : (y : Nat) → y = x + 1 → Nat := ...  -- 避免过度复杂
```

## 相关链接 | Related Links

- [02-类型等价与同构](./02-类型等价与同构/README.md)
- [03-高级类型技术](./03-高级类型技术/README.md)
- [形式化验证](../../02-形式化验证/README.md)

## 练习 | Exercises

1. 实现安全的数组访问函数
2. 设计依赖类型的状态机
3. 创建类型安全的数据库操作

---

*最后更新：2025年1月*
*版本：1.0*
