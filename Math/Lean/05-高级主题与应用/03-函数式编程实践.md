# 函数式编程实践 | Functional Programming Practice

> 最小前置导入（建议在可运行的 `lake` 项目中使用）：

```lean
import Std
import Mathlib
open scoped BigOperators
```

## 常用模块导入清单 | Common Imports Cheat Sheet

- 列表/数组/映射：`import Mathlib/Data/List/Basic`，`import Mathlib/Data/Array/Basic`，`import Mathlib/Data/HashMap/Basic`
- 选项与结果：`import Mathlib/Init/Algebra/Option`
- 证明辅助：`import Mathlib/Tactic`，`import Mathlib/Tactic/Decide`，`import Mathlib/Tactic/Linarith`

## 概念层级与映射 | Concepts & Mapping

- 纯函数与不可变：无副作用、引用透明、值语义
- 高阶函数：组合/柯里化/部分应用、fold/map/filter
- 数据结构：不可变 `List/Array/Tree` 与递归处理
- 副作用建模：`Option/Except/State/IO` 与 `Monad` 抽象
- 设计模式：`Functor/Applicative/Monad` 实例与律

## 1. 纯函数编程 | Pure Functional Programming

### 纯函数定义 | Pure Function Definition

```lean
-- 纯函数：无副作用
def pure_add (x y : ℕ) : ℕ := x + y

-- 纯函数：确定性
def pure_factorial (n : ℕ) : ℕ :=
  match n with
  | 0 => 1
  | n + 1 => (n + 1) * pure_factorial n

-- 纯函数：引用透明
theorem pure_function_referential_transparency (x y : ℕ) :
  pure_add x y = pure_add x y := rfl
```

### 副作用管理 | Side Effect Management

```lean
-- 使用Monad管理副作用
class Monad (m : Type → Type) where
  pure : α → m α
  bind : m α → (α → m β) → m β

-- IO Monad示例
def IO.sequence {α : Type} : List (IO α) → IO (List α)
  | [] => pure []
  | x :: xs => do
    let y ← x
    let ys ← IO.sequence xs
    pure (y :: ys)

-- 状态Monad
def State (σ α : Type) := σ → (α × σ)

def State.pure {σ α : Type} (a : α) : State σ α :=
  fun s => (a, s)

def State.bind {σ α β : Type} (m : State σ α) (f : α → State σ β) : State σ β :=
  fun s => let (a, s') := m s; f a s'
```

## 2. 高阶函数 | Higher-Order Functions

### 函数组合 | Function Composition

```lean
-- 函数组合
def compose {α β γ : Type} (f : β → γ) (g : α → β) : α → γ :=
  fun x => f (g x)

-- 使用函数组合
def add_one (x : ℕ) : ℕ := x + 1
def multiply_two (x : ℕ) : ℕ := x * 2

def add_one_then_multiply_two : ℕ → ℕ :=
  compose multiply_two add_one

-- 函数组合性质
theorem compose_assoc {α β γ δ : Type} (f : γ → δ) (g : β → γ) (h : α → β) :
  compose f (compose g h) = compose (compose f g) h := by
  ext x
  rfl
```

### 函数应用 | Function Application

```lean
-- 部分应用
def partial_application (x : ℕ) : ℕ → ℕ :=
  fun y => x + y

-- 柯里化
def curry {α β γ : Type} (f : α × β → γ) : α → β → γ :=
  fun x y => f (x, y)

-- 反柯里化
def uncurry {α β γ : Type} (f : α → β → γ) : α × β → γ :=
  fun (x, y) => f x y

-- 柯里化性质
theorem curry_uncurry {α β γ : Type} (f : α → β → γ) :
  curry (uncurry f) = f := by
  ext x y
  rfl
```

## 3. 不可变数据结构 | Immutable Data Structures

### 不可变列表 | Immutable Lists

```lean
-- 不可变列表操作
def List.append {α : Type} : List α → List α → List α
  | [], ys => ys
  | x :: xs, ys => x :: List.append xs ys

-- 列表映射
def List.map {α β : Type} (f : α → β) : List α → List β
  | [] => []
  | x :: xs => f x :: List.map f xs

-- 列表过滤
def List.filter {α : Type} (p : α → Bool) : List α → List α
  | [] => []
  | x :: xs => if p x then x :: List.filter p xs else List.filter p xs

-- 列表折叠
def List.foldl {α β : Type} (f : β → α → β) (init : β) : List α → β
  | [] => init
  | x :: xs => List.foldl f (f init x) xs
```

### 不可变树 | Immutable Trees

```lean
-- 不可变二叉树
inductive Tree (α : Type) where
  | leaf : Tree α
  | node (left : Tree α) (value : α) (right : Tree α) : Tree α

-- 树映射
def Tree.map {α β : Type} (f : α → β) : Tree α → Tree β
  | Tree.leaf => Tree.leaf
  | Tree.node l v r => Tree.node (Tree.map f l) (f v) (Tree.map f r)

-- 树折叠
def Tree.fold {α β : Type} (f : β → α → β → β) (init : β) : Tree α → β
  | Tree.leaf => init
  | Tree.node l v r => f (Tree.fold f init l) v (Tree.fold f init r)

-- 树插入
def Tree.insert {α : Type} [LE α] (x : α) : Tree α → Tree α
  | Tree.leaf => Tree.node Tree.leaf x Tree.leaf
  | Tree.node l v r => 
    if x ≤ v then Tree.node (Tree.insert x l) v r
    else Tree.node l v (Tree.insert x r)
```

## 4. 模式匹配 | Pattern Matching

### 基本模式匹配 | Basic Pattern Matching

```lean
-- 自然数模式匹配
def is_even : ℕ → Bool
  | 0 => true
  | 1 => false
  | n + 2 => is_even n

-- 列表模式匹配
def list_head {α : Type} : List α → Option α
  | [] => none
  | x :: _ => some x

-- 元组模式匹配
def tuple_add : ℕ × ℕ → ℕ
  | (x, y) => x + y
```

### 高级模式匹配 | Advanced Pattern Matching

```lean
-- 嵌套模式匹配
def nested_match {α : Type} : List (List α) → ℕ
  | [] => 0
  | [] :: xss => nested_match xss
  | (x :: xs) :: xss => 1 + nested_match (xs :: xss)

-- 守卫模式
def guarded_match (x : ℕ) : String :=
  match x with
  | 0 => "zero"
  | n if n < 10 => "small"
  | n if n < 100 => "medium"
  | _ => "large"

-- 模式匹配与证明
def pattern_match_proof (xs : List ℕ) : xs.length ≥ 0 :=
  match xs with
  | [] => by simp
  | x :: xs => by simp [List.length_cons]
```

## 5. 递归与尾递归 | Recursion and Tail Recursion

### 基本递归 | Basic Recursion

```lean
-- 基本递归
def factorial (n : ℕ) : ℕ :=
  match n with
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

-- 斐波那契数列
def fibonacci (n : ℕ) : ℕ :=
  match n with
  | 0 => 0
  | 1 => 1
  | n + 2 => fibonacci n + fibonacci (n + 1)
```

### 尾递归优化 | Tail Recursion Optimization

```lean
-- 尾递归阶乘
def factorial_tail (n : ℕ) : ℕ :=
  let rec aux (acc i : ℕ) : ℕ :=
    match i with
    | 0 => acc
    | i + 1 => aux (acc * (i + 1)) i
  aux 1 n

-- 尾递归斐波那契
def fibonacci_tail (n : ℕ) : ℕ :=
  let rec aux (a b i : ℕ) : ℕ :=
    match i with
    | 0 => a
    | i + 1 => aux b (a + b) i
  aux 0 1 n

-- 尾递归性质
theorem factorial_tail_correct (n : ℕ) : factorial_tail n = factorial n := by
  sorry -- 需要证明尾递归正确性
```

## 6. 惰性求值 | Lazy Evaluation

### 流处理 | Stream Processing

```lean
-- 流定义
structure Stream (α : Type) where
  head : α
  tail : Stream α

-- 无限流
def natural_numbers : Stream ℕ :=
  let rec aux (n : ℕ) : Stream ℕ :=
    { head := n, tail := aux (n + 1) }
  aux 0

-- 流映射
def Stream.map {α β : Type} (f : α → β) : Stream α → Stream β
  | s => { head := f s.head, tail := Stream.map f s.tail }

-- 流过滤
def Stream.filter {α : Type} (p : α → Bool) : Stream α → Stream α
  | s => if p s.head then { head := s.head, tail := Stream.filter p s.tail }
         else Stream.filter p s.tail
```

### 惰性列表 | Lazy Lists

```lean
-- 惰性列表
inductive LazyList (α : Type) where
  | nil : LazyList α
  | cons (head : α) (tail : LazyList α) : LazyList α

-- 惰性列表生成
def LazyList.range (start : ℕ) : LazyList ℕ :=
  LazyList.cons start (LazyList.range (start + 1))

-- 惰性列表映射
def LazyList.map {α β : Type} (f : α → β) : LazyList α → LazyList β
  | LazyList.nil => LazyList.nil
  | LazyList.cons x xs => LazyList.cons (f x) (LazyList.map f xs)
```

## 7. 函数式设计模式 | Functional Design Patterns

### 函子模式 | Functor Pattern

```lean
-- 函子类型类
class Functor (f : Type → Type) where
  map : (α → β) → f α → f β
  map_id : ∀ x : f α, map id x = x
  map_comp : ∀ (g : β → γ) (h : α → β) (x : f α), 
    map (g ∘ h) x = map g (map h x)

-- Maybe函子实例
instance : Functor Option where
  map f := fun
    | none => none
    | some x => some (f x)
  map_id := by intro x; cases x <;> rfl
  map_comp := by intro g h x; cases x <;> rfl

-- 列表函子实例
instance : Functor List where
  map := List.map
  map_id := by intro x; induction x <;> simp [List.map]
  map_comp := by intro g h x; induction x <;> simp [List.map]
```

### 单子模式 | Monad Pattern

```lean
-- 单子类型类
class Monad (m : Type → Type) extends Functor m where
  pure : α → m α
  bind : m α → (α → m β) → m β
  pure_bind : ∀ (a : α) (f : α → m β), bind (pure a) f = f a
  bind_pure : ∀ (x : m α), bind x pure = x
  bind_assoc : ∀ (x : m α) (f : α → m β) (g : β → m γ),
    bind (bind x f) g = bind x (fun a => bind (f a) g)

-- Maybe单子实例
instance : Monad Option where
  pure := some
  bind := fun
    | none, _ => none
    | some x, f => f x
  pure_bind := by intro a f; rfl
  bind_pure := by intro x; cases x <;> rfl
  bind_assoc := by intro x f g; cases x <;> rfl
```

## 8. 函数式编程最佳实践 | Functional Programming Best Practices

### 代码组织 | Code Organization

```lean
-- 模块化设计
namespace FunctionalProgramming
  -- 纯函数模块
  namespace PureFunctions
    def add (x y : ℕ) : ℕ := x + y
    def multiply (x y : ℕ) : ℕ := x * y
  end PureFunctions

  -- 高阶函数模块
  namespace HigherOrder
    def compose {α β γ : Type} (f : β → γ) (g : α → β) : α → γ :=
      fun x => f (g x)
    
    def curry {α β γ : Type} (f : α × β → γ) : α → β → γ :=
      fun x y => f (x, y)
  end HigherOrder

  -- 数据结构模块
  namespace DataStructures
    def List.foldl {α β : Type} (f : β → α → β) (init : β) : List α → β
      | [] => init
      | x :: xs => List.foldl f (f init x) xs
  end DataStructures
end FunctionalProgramming
```

## 9. 练习与参考解 | Exercises with Hints

```lean
-- 练习1：证明 compose 的结合律
theorem ex_compose_assoc {α β γ δ} (f : γ → δ) (g : β → γ) (h : α → β) (x : α) :
  (f ∘ g ∘ h) x = f (g (h x)) := by rfl

-- 练习2：验证 curry 与 uncurry 互逆
theorem ex_curry_uncurry {α β γ} (f : α → β → γ) : curry (uncurry f) = f := by
  funext x y; rfl

-- 练习3：List.map 与 foldl 的简单性质
theorem ex_map_length {α β} (f : α → β) (xs : List α) :
  (xs.map f).length = xs.length := by
  induction xs <;> simp

-- 练习4：State 单子单位律（简化版）
def State (σ α : Type) := σ → (α × σ)

def State.pure {σ α} (a : α) : State σ α := fun s => (a, s)

def State.bind {σ α β} (m : State σ α) (f : α → State σ β) : State σ β :=
  fun s => let (a, s') := m s; f a s'

theorem ex_state_left_identity {σ α β} (a : α) (f : α → State σ β) :
  State.bind (State.pure a) f = f a := by
  funext s; rfl
```

### 性能优化 | Performance Optimization

```lean
-- 记忆化
def memoize {α β : Type} [BEq α] [Hashable α] (f : α → β) : α → β :=
  let cache := HashMap.empty
  fun x => 
    match cache.find? x with
    | some y => y
    | none => 
      let y := f x
      cache.insert x y
      y

-- 尾递归优化
def optimized_factorial (n : ℕ) : ℕ :=
  let rec aux (acc i : ℕ) : ℕ :=
    if i = 0 then acc
    else aux (acc * i) (i - 1)
  aux 1 n

-- 惰性求值优化
def lazy_fibonacci (n : ℕ) : ℕ :=
  let rec aux (a b i : ℕ) : ℕ :=
    if i = 0 then a
    else aux b (a + b) (i - 1)
  aux 0 1 n
```

---

*相关链接：*

- [依赖类型编程](./01-依赖类型编程.md)
- [形式化验证](./02-形式化验证.md)
- [AI与Lean集成](./04-AI与Lean集成.md)
