# 纯函数设计 | Pure Function Design

## 概述 | Overview

纯函数是函数式编程的核心概念，具有无副作用、引用透明性等特性。在Lean中，纯函数设计是构建可靠、可测试、可推理程序的基础。

Pure functions are a core concept in functional programming, characterized by no side effects and referential transparency. In Lean, pure function design is the foundation for building reliable, testable, and reason-able programs.

## 纯函数的基本特性 | Basic Properties of Pure Functions

### 1. 无副作用 | No Side Effects

```lean
-- 纯函数示例 | Pure function example
def add (x y : Nat) : Nat := x + y

-- 纯函数不会修改外部状态 | Pure functions don't modify external state
def multiply (x y : Nat) : Nat := x * y

-- 纯函数不会产生副作用 | Pure functions don't produce side effects
def factorial (n : Nat) : Nat :=
  match n with
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

-- 验证纯函数特性 | Verify pure function properties
#eval add 3 4  -- 结果: 7
#eval add 3 4  -- 结果: 7 (相同输入总是产生相同输出)
```

### 2. 引用透明性 | Referential Transparency

```lean
-- 引用透明性示例 | Referential transparency example
def square (x : Nat) : Nat := x * x

-- 可以安全地替换表达式 | Can safely replace expressions
def example1 : Nat := square (add 2 3)
def example2 : Nat := square 5  -- 等价于 example1

-- 引用透明性证明 | Referential transparency proof
theorem referentialTransparency (x : Nat) : square x = x * x := by
  rfl

-- 函数组合的引用透明性 | Referential transparency of function composition
def compose (f : α → β) (g : β → γ) : α → γ :=
  fun x => g (f x)

theorem composeTransparency (f : α → β) (g : β → γ) (x : α) :
  compose f g x = g (f x) := by
  rfl
```

### 3. 确定性 | Determinism

```lean
-- 确定性函数 | Deterministic function
def max (a b : Nat) : Nat :=
  if a ≥ b then a else b

-- 确定性证明 | Determinism proof
theorem maxDeterministic (a b : Nat) : max a b = max a b := by
  rfl

-- 非确定性函数（避免）| Non-deterministic function (avoid)
-- def randomNumber : Nat := ...  -- 这不是纯函数

-- 确定性列表处理 | Deterministic list processing
def map (f : α → β) (xs : List α) : List β :=
  match xs with
  | [] => []
  | x :: xs => f x :: map f xs

theorem mapDeterministic (f : α → β) (xs : List α) :
  map f xs = map f xs := by
  rfl
```

## 纯函数设计模式 | Pure Function Design Patterns

### 1. 不可变数据结构 | Immutable Data Structures

```lean
-- 不可变列表 | Immutable list
inductive List (α : Type) where
  | nil : List α
  | cons : α → List α → List α

-- 不可变操作 | Immutable operations
def List.append (xs ys : List α) : List α :=
  match xs with
  | [] => ys
  | x :: xs => x :: xs.append ys

-- 不可变性证明 | Immutability proof
theorem appendImmutability (xs ys : List α) :
  xs.append ys = xs.append ys := by
  rfl

-- 不可变树结构 | Immutable tree structure
inductive Tree (α : Type) where
  | leaf : α → Tree α
  | node : Tree α → Tree α → Tree α

def Tree.insert (t : Tree α) (x : α) : Tree α :=
  match t with
  | .leaf y => .node (.leaf x) (.leaf y)
  | .node left right => .node (left.insert x) right
```

### 2. 函数组合 | Function Composition

```lean
-- 函数组合 | Function composition
def compose (f : α → β) (g : β → γ) : α → γ :=
  fun x => g (f x)

-- 使用函数组合 | Using function composition
def addOne (x : Nat) : Nat := x + 1
def multiplyByTwo (x : Nat) : Nat := x * 2

def addOneThenMultiplyByTwo : Nat → Nat :=
  compose addOne multiplyByTwo

-- 函数组合的关联性 | Associativity of function composition
theorem composeAssociative (f : α → β) (g : β → γ) (h : γ → δ) :
  compose (compose f g) h = compose f (compose g h) := by
  rfl

-- 高阶函数 | Higher-order functions
def map (f : α → β) : List α → List β :=
  fun xs => xs.map f

def filter (p : α → Bool) : List α → List α :=
  fun xs => xs.filter p

def reduce (f : α → α → α) (init : α) : List α → α :=
  fun xs => xs.foldl f init
```

### 3. 递归设计 | Recursive Design

```lean
-- 尾递归 | Tail recursion
def factorialTail (n : Nat) : Nat :=
  let rec aux (n acc : Nat) : Nat :=
    match n with
    | 0 => acc
    | n + 1 => aux n (acc * (n + 1))
  aux n 1

-- 尾递归优化 | Tail recursion optimization
theorem factorialTailCorrect (n : Nat) : factorialTail n = factorial n := by
  sorry  -- 需要详细的证明

-- 结构递归 | Structural recursion
def listLength (xs : List α) : Nat :=
  match xs with
  | [] => 0
  | _ :: xs => 1 + listLength xs

-- 递归终止性 | Recursive termination
theorem listLengthTerminates (xs : List α) : listLength xs ≠ 0 ∨ xs = [] := by
  match xs with
  | [] => right; rfl
  | _ :: _ => left; simp [listLength]
```

## 纯函数的高级技术 | Advanced Pure Function Techniques

### 1. 柯里化 | Currying

```lean
-- 柯里化函数 | Curried function
def addCurried : Nat → Nat → Nat :=
  fun x => fun y => x + y

-- 部分应用 | Partial application
def addFive : Nat → Nat := addCurried 5

-- 柯里化等价性 | Currying equivalence
theorem curryingEquivalence (x y : Nat) :
  addCurried x y = x + y := by
  rfl

-- 高阶柯里化 | Higher-order currying
def curry (f : α × β → γ) : α → β → γ :=
  fun x => fun y => f (x, y)

def uncurry (f : α → β → γ) : α × β → γ :=
  fun (x, y) => f x y
```

### 2. 惰性求值 | Lazy Evaluation

```lean
-- 惰性列表 | Lazy list
inductive LazyList (α : Type) where
  | nil : LazyList α
  | cons : α → (Unit → LazyList α) → LazyList α

-- 惰性求值函数 | Lazy evaluation function
def LazyList.head (xs : LazyList α) : Option α :=
  match xs with
  | .nil => none
  | .cons x _ => some x

def LazyList.tail (xs : LazyList α) : LazyList α :=
  match xs with
  | .nil => .nil
  | .cons _ xs => xs ()

-- 惰性生成器 | Lazy generator
def naturalNumbers : LazyList Nat :=
  let rec aux (n : Nat) : LazyList Nat :=
    .cons n (fun _ => aux (n + 1))
  aux 0
```

### 3. 记忆化 | Memoization

```lean
-- 记忆化函数 | Memoized function
def memoize (f : α → β) : α → β :=
  let cache := {}
  fun x => 
    match cache.find? x with
    | some y => y
    | none => 
      let result := f x
      -- 更新缓存
      result

-- 斐波那契记忆化 | Fibonacci memoization
def fibonacciMemo (n : Nat) : Nat :=
  let rec aux (n : Nat) (cache : Array Nat) : (Nat × Array Nat) :=
    if n < cache.size then
      (cache[n]!, cache)
    else
      let (prev, cache) := aux (n - 1) cache
      let (prev2, cache) := aux (n - 2) cache
      let result := prev + prev2
      (result, cache.push result)
  (aux n #[]).1

-- 记忆化正确性 | Memoization correctness
theorem memoizationCorrect (f : α → β) (x : α) :
  memoize f x = f x := by
  sorry  -- 需要详细的证明
```

## 纯函数的实际应用 | Practical Applications of Pure Functions

### 1. 数据处理管道 | Data Processing Pipelines

```lean
-- 数据处理管道 | Data processing pipeline
def processData (xs : List Nat) : List Nat :=
  xs
  |> List.filter (· > 0)  -- 过滤正数
  |> List.map (· * 2)     -- 乘以2
  |> List.sort            -- 排序

-- 管道组合 | Pipeline composition
def pipeline (f : α → β) (g : β → γ) (h : γ → δ) : α → δ :=
  h ∘ g ∘ f

-- 使用管道 | Using pipeline
def processNumbers : List Nat → List Nat :=
  pipeline
    (List.filter (· > 0))
    (List.map (· * 2))
    (List.sort)

-- 管道正确性 | Pipeline correctness
theorem pipelineCorrect (xs : List Nat) :
  processData xs = processNumbers xs := by
  rfl
```

### 2. 状态管理 | State Management

```lean
-- 状态转换函数 | State transition function
def State (σ α : Type) : Type := σ → (α × σ)

-- 状态操作 | State operations
def State.return (x : α) : State σ α :=
  fun s => (x, s)

def State.bind (m : State σ α) (f : α → State σ β) : State σ β :=
  fun s => 
    let (x, s') := m s
    f x s'

-- 状态更新 | State update
def State.modify (f : σ → σ) : State σ Unit :=
  fun s => ((), f s)

def State.get : State σ σ :=
  fun s => (s, s)

-- 状态计算 | State computation
def counter : State Nat Nat :=
  State.bind State.get (fun n => 
    State.bind (State.modify (· + 1)) (fun _ => 
      State.return n))
```

### 3. 错误处理 | Error Handling

```lean
-- 错误类型 | Error type
inductive Result (α : Type) where
  | ok : α → Result α
  | error : String → Result α

-- 错误处理函数 | Error handling functions
def Result.bind (m : Result α) (f : α → Result β) : Result β :=
  match m with
  | .ok x => f x
  | .error msg => .error msg

def Result.map (f : α → β) (m : Result α) : Result β :=
  match m with
  | .ok x => .ok (f x)
  | .error msg => .error msg

-- 安全除法 | Safe division
def safeDivide (x y : Nat) : Result Nat :=
  if y = 0 then
    .error "Division by zero"
  else
    .ok (x / y)

-- 错误处理链 | Error handling chain
def complexCalculation (x y z : Nat) : Result Nat :=
  safeDivide x y >>= fun result1 =>
  safeDivide result1 z >>= fun result2 =>
  .ok (result2 * 2)
```

## 最佳实践 | Best Practices

### 1. 纯函数设计原则 | Pure Function Design Principles

```lean
-- 单一职责原则 | Single responsibility principle
def add (x y : Nat) : Nat := x + y  -- 只做加法
def multiply (x y : Nat) : Nat := x * y  -- 只做乘法

-- 避免混合职责 | Avoid mixing responsibilities
-- def addAndPrint (x y : Nat) : Nat := ...  -- 避免

-- 可组合性 | Composability
def addThenMultiply (x y z : Nat) : Nat :=
  multiply (add x y) z

-- 可测试性 | Testability
theorem addCommutative (x y : Nat) : add x y = add y x := by
  rfl
```

### 2. 性能考虑 | Performance Considerations

```lean
-- 尾递归优化 | Tail recursion optimization
def sumTail (xs : List Nat) : Nat :=
  let rec aux (xs acc : List Nat × Nat) : Nat :=
    match xs with
    | [] => acc
    | x :: xs => aux xs (acc + x)
  aux xs 0

-- 避免不必要的计算 | Avoid unnecessary computation
def efficientFilter (xs : List α) (p : α → Bool) : List α :=
  xs.filter p  -- 使用内置的高效实现

-- 记忆化优化 | Memoization optimization
def memoizedExpensiveFunction (x : Nat) : Nat :=
  -- 对于昂贵的计算使用记忆化
  x * x * x
```

## 相关链接 | Related Links

- [02-副作用管理](./02-副作用管理/README.md)
- [03-函数式编程模式](./03-函数式编程模式/README.md)
- [依赖类型编程](../../01-依赖类型编程/README.md)

## 练习 | Exercises

1. 设计纯函数的数据处理管道
2. 实现不可变的数据结构
3. 创建可组合的函数库

---

*最后更新：2025年1月*
*版本：1.0*
