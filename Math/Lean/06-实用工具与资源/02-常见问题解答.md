# 常见问题解答 | Frequently Asked Questions

## 1. 基础语法问题 | Basic Syntax Issues

### Q1: 如何定义函数？

**A**: 使用`def`关键字定义函数：

```lean
-- 基本函数定义
def add (x y : ℕ) : ℕ := x + y

-- 带类型推断的函数
def multiply (x y) := x * y  -- 类型被推断为 ℕ → ℕ → ℕ

-- 递归函数
def factorial : ℕ → ℕ
  | 0 => 1
  | n + 1 => (n + 1) * factorial n
```

### Q2: 如何处理类型错误？

**A**: 类型错误通常由以下原因引起：

```lean
-- 错误示例
-- def bad_function (x : ℕ) : String := x + 1  -- 类型不匹配

-- 正确示例
def good_function (x : ℕ) : ℕ := x + 1
def string_function (x : ℕ) : String := toString (x + 1)

-- 类型转换
def convert_types (x : ℕ) : ℤ := Int.ofNat x
```

### Q3: 如何导入模块？

**A**: 使用`import`语句导入模块：

```lean
-- 推荐：最小前置导入
import Std
import Mathlib
open scoped BigOperators

-- 按需精细模块
-- import Mathlib/Data/Nat/Basic
-- import Mathlib/Algebra/Group/Basic

#check Nat.add_comm
#check List.map
```

## 2. 证明相关问题 | Proof-Related Issues

### Q4: 如何开始一个证明？

**A**: 使用`theorem`或`lemma`关键字，然后用`by`开始证明：

```lean
-- 基本证明结构
theorem example_proof (p q : Prop) : p → q → p ∧ q := by
  intro hp hq
  exact ⟨hp, hq⟩

-- 使用sorry占位符
theorem incomplete_proof (n : ℕ) : n + 0 = n := by
  sorry  -- 稍后完成
```

### Q5: 证明卡住了怎么办？

**A**: 尝试以下策略：

```lean
-- 1. 检查目标状态
theorem stuck_proof (a b : ℕ) : a = b → a + 1 = b + 1 := by
  intro h
  -- 此时目标：a + 1 = b + 1
  -- 假设：h : a = b
  rw [h]  -- 使用假设重写目标

-- 2. 使用simp简化
theorem simp_example (a b : ℕ) : a + 0 + b = a + b := by
  simp  -- 自动简化

-- 3. 分情况讨论
theorem cases_example (n : ℕ) : n = 0 ∨ n > 0 := by
  cases n with
  | zero => left; rfl
  | succ n => right; exact Nat.succ_pos n
```

### Q6: 如何选择合适的证明策略？

**A**: 根据目标类型选择策略：

```lean
-- 等式目标：使用rw, simp, ring
theorem eq_goal (a b : ℕ) : a + b = b + a := by
  ring

-- 存在性目标：使用exists, use
theorem exists_goal : ∃ n : ℕ, n > 0 := by
  exists 1
  exact Nat.one_pos

-- 析取目标：使用left, right
theorem or_goal (p q : Prop) : p → p ∨ q := by
  intro hp
  left
  exact hp

-- 合取目标：使用constructor
theorem and_goal (p q : Prop) : p → q → p ∧ q := by
  intros hp hq
  constructor
  · exact hp
  · exact hq
```

## 3. 类型系统问题 | Type System Issues

### Q7: 什么是依赖类型？

**A**: 依赖类型是依赖于值的类型：

```lean
-- 依赖函数类型
def dependent_function (n : ℕ) : Fin n → ℕ :=
  fun i => i.val

-- 依赖积类型
def dependent_pair (n : ℕ) : Σ (i : Fin n), ℕ :=
  ⟨0, n⟩

-- 向量类型（长度依赖）
inductive Vector (α : Type) : ℕ → Type where
  | nil : Vector α 0
  | cons (head : α) (tail : Vector α n) : Vector α (n + 1)
```

### Q8: 如何处理类型类？

**A**: 类型类提供多态行为：

```lean
-- 定义类型类
class Add (α : Type) where
  add : α → α → α

-- 实现类型类实例
instance : Add ℕ where
  add := Nat.add

instance : Add String where
  add := String.append

-- 使用类型类
def generic_add {α : Type} [Add α] (x y : α) : α :=
  Add.add x y
```

## 4. 性能优化问题 | Performance Issues

### Q9: 如何优化Lean代码性能？

**A**: 使用以下优化技巧：

```lean
-- 1. 使用尾递归
def factorial_tail (n : ℕ) : ℕ :=
  let rec aux (acc i : ℕ) : ℕ :=
    if i = 0 then acc
    else aux (acc * i) (i - 1)
  aux 1 n

-- 2. 避免不必要的计算
def efficient_sum (xs : List ℕ) : ℕ :=
  xs.foldl (· + ·) 0  -- 使用foldl而不是递归

-- 3. 使用适当的数据结构
def efficient_lookup (m : HashMap String ℕ) (key : String) : Option ℕ :=
  m.find? key  -- 使用HashMap而不是List
```

### Q10: 如何减少编译时间？

**A**: 采用以下策略：

```lean
-- 1. 模块化设计
namespace Optimized
  -- 将相关定义放在同一个命名空间
  def helper_function (x : ℕ) : ℕ := x * 2
  
  def main_function (x : ℕ) : ℕ := helper_function x
end Optimized

-- 2. 避免过度导入
-- 只导入需要的模块
import Mathlib.Data.Nat.Basic  -- 而不是 import Mathlib.All

-- 3. 使用类型推断
def inferred_type (x) := x + 1  -- 让Lean推断类型
```

## 5. 调试技巧 | Debugging Tips

### Q11: 如何调试Lean代码？

**A**: 使用以下调试方法：

```lean
-- 1. 使用#check检查类型
#check Nat.add  -- 输出：ℕ → ℕ → ℕ

-- 2. 使用#eval计算值
#eval 2 + 3  -- 输出：5

-- 3. 使用#reduce查看计算过程
#reduce factorial 5

-- 4. 使用sorry逐步构建证明
theorem debug_proof (a b : ℕ) : a = b → a + 1 = b + 1 := by
  intro h
  -- 在这里添加sorry，逐步完成证明
  sorry
```

### Q12: 如何理解错误信息？

**A**: 常见错误信息解读：

```lean
-- 类型不匹配错误
-- def error1 (x : ℕ) : String := x  -- 错误：类型不匹配

-- 未定义标识符错误
-- def error2 (x : ℕ) : ℕ := undefined_function x  -- 错误：未定义

-- 类型类实例缺失错误
-- def error3 {α : Type} (x y : α) : α := x + y  -- 错误：缺少Add实例

-- 正确的修复方法
def correct1 (x : ℕ) : String := toString x
def correct2 (x : ℕ) : ℕ := x + 1
def correct3 {α : Type} [Add α] (x y : α) : α := x + y
```

## 6. 最佳实践 | Best Practices

### Q13: Lean编程的最佳实践是什么？

**A**: 遵循以下最佳实践：

```lean
-- 1. 使用描述性命名
def calculate_fibonacci_number (n : ℕ) : ℕ :=
  match n with
  | 0 => 0
  | 1 => 1
  | n + 2 => calculate_fibonacci_number n + calculate_fibonacci_number (n + 1)

-- 2. 添加类型注解
def explicit_types (x : ℕ) (y : String) : ℕ × String :=
  (x, y)

-- 3. 使用适当的抽象
def generic_operation {α : Type} [Add α] (x y : α) : α :=
  x + y

-- 4. 编写清晰的证明
theorem clear_proof (a b c : ℕ) : a = b → b = c → a = c := by
  intro hab hbc
  rw [hab, hbc]
```

### Q14: 如何组织大型项目？

**A**: 采用模块化组织：

```lean
-- 1. 使用命名空间
namespace MyProject
  namespace DataStructures
    def List.unique {α : Type} [BEq α] : List α → List α :=
      sorry
  end DataStructures
  
  namespace Algorithms
    def sorting.merge_sort {α : Type} [LE α] : List α → List α :=
      sorry
  end Algorithms
end MyProject

-- 2. 分离接口和实现
namespace Interface
  def process_data (data : List ℕ) : List ℕ :=
    sorry
end Interface

namespace Implementation
  def process_data_impl (data : List ℕ) : List ℕ :=
    data.map (· * 2)
end Implementation
```

## 7. 社区资源 | Community Resources

### Q15: 如何获得帮助？

**A**: 通过以下渠道获得帮助：

1. **官方文档**：[Lean官方文档](https://leanprover.github.io/)
2. **社区论坛**：[Lean Zulip](https://leanprover.zulipchat.com/)
3. **GitHub**：[Lean GitHub仓库](https://github.com/leanprover/lean4)
4. **Stack Overflow**：使用`lean`标签提问
5. **本地用户组**：寻找当地的Lean用户组

### Q16: 如何贡献代码？

**A**: 贡献代码的步骤：

1. **Fork仓库**：Fork Lean或Mathlib仓库
2. **创建分支**：为你的功能创建新分支
3. **编写代码**：遵循编码规范
4. **运行测试**：确保所有测试通过
5. **提交PR**：创建Pull Request
6. **代码审查**：根据反馈修改代码

---

*相关链接：*

- [学习路径指南](./01-学习路径指南.md)
- [基础语法与类型系统](../02-基础语法与类型系统/01-基础语法元素.md)
- [证明系统与策略](../03-证明系统与策略/01-交互式证明环境.md)
- [实用工具与资源](./03-性能优化指南.md)
