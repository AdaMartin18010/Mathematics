# 性能优化指南 | Performance Optimization Guide

## 1. 编译时优化 | Compile-Time Optimization

### 模块化设计 | Modular Design

```lean
-- 避免过度导入
-- 错误做法
-- import Mathlib.All  -- 导入所有模块

-- 正确做法
import Mathlib.Data.Nat.Basic
import Mathlib.Data.List.Basic
import Mathlib.Algebra.Group.Basic

-- 使用命名空间组织代码
namespace PerformanceOptimized
  -- 相关定义放在一起
  def helper_function (x : ℕ) : ℕ := x * 2
  
  def main_function (x : ℕ) : ℕ := helper_function x
end PerformanceOptimized
```

### 类型推断优化 | Type Inference Optimization

```lean
-- 让Lean推断类型，减少类型注解
def inferred_types (x) := x + 1  -- 类型被推断为 ℕ → ℕ

-- 只在必要时添加类型注解
def explicit_when_needed (x : ℕ) (y : String) : ℕ × String :=
  (x, y)

-- 使用类型类约束
def generic_optimized {α : Type} [Add α] (x y : α) : α :=
  x + y
```

## 2. 运行时优化 | Runtime Optimization

### 尾递归优化 | Tail Recursion Optimization

```lean
-- 非尾递归（低效）
def factorial_inefficient (n : ℕ) : ℕ :=
  match n with
  | 0 => 1
  | n + 1 => (n + 1) * factorial_inefficient n

-- 尾递归（高效）
def factorial_efficient (n : ℕ) : ℕ :=
  let rec aux (acc i : ℕ) : ℕ :=
    if i = 0 then acc
    else aux (acc * i) (i - 1)
  aux 1 n

-- 尾递归斐波那契
def fibonacci_efficient (n : ℕ) : ℕ :=
  let rec aux (a b i : ℕ) : ℕ :=
    if i = 0 then a
    else aux b (a + b) (i - 1)
  aux 0 1 n
```

### 数据结构优化 | Data Structure Optimization

```lean
-- 使用适当的数据结构
-- 列表查找（O(n)）
def list_lookup (xs : List (String × ℕ)) (key : String) : Option ℕ :=
  xs.lookup key

-- HashMap查找（O(1)）
def hashmap_lookup (m : HashMap String ℕ) (key : String) : Option ℕ :=
  m.find? key

-- 使用Array进行随机访问
def array_access (arr : Array ℕ) (i : Fin arr.size) : ℕ :=
  arr.get i

-- 使用Vector进行类型安全的访问
def vector_access {α : Type} (v : Vector α n) (i : Fin n) : α :=
  v.get i
```

## 3. 算法优化 | Algorithm Optimization

### 排序算法优化 | Sorting Algorithm Optimization

```lean
-- 高效的归并排序
def merge_sort {α : Type} [LE α] [DecidableRel (· ≤ ·)] : List α → List α
  | [] => []
  | [x] => [x]
  | xs => 
    let mid := xs.length / 2
    let (left, right) := xs.splitAt mid
    merge (merge_sort left) (merge_sort right)
where
  merge : List α → List α → List α
    | [], ys => ys
    | xs, [] => xs
    | x :: xs, y :: ys => 
      if x ≤ y then x :: merge xs (y :: ys)
      else y :: merge (x :: xs) ys

-- 高效的快速排序
def quicksort {α : Type} [LE α] [DecidableRel (· ≤ ·)] : List α → List α
  | [] => []
  | x :: xs => 
    let smaller := xs.filter (· ≤ x)
    let larger := xs.filter (· > x)
    quicksort smaller ++ [x] ++ quicksort larger
```

### 搜索算法优化 | Search Algorithm Optimization

```lean
-- 二分搜索（O(log n)）
def binary_search {α : Type} [LE α] [DecidableRel (· ≤ ·)] (x : α) (xs : List α) (h : IsSorted xs) : Option (Fin xs.length) :=
  let rec search (low high : ℕ) : Option (Fin xs.length) :=
    if low > high then none
    else
      let mid := (low + high) / 2
      let mid_val := xs.get ⟨mid, sorry⟩
      if x = mid_val then some ⟨mid, sorry⟩
      else if x < mid_val then search low (mid - 1)
      else search (mid + 1) high
  search 0 (xs.length - 1)

-- 哈希表搜索（O(1)）
def hash_search (m : HashMap String ℕ) (key : String) : Option ℕ :=
  m.find? key
```

## 4. 内存优化 | Memory Optimization

### 惰性求值 | Lazy Evaluation

```lean
-- 使用惰性列表
inductive LazyList (α : Type) where
  | nil : LazyList α
  | cons (head : α) (tail : LazyList α) : LazyList α

-- 惰性列表生成
def LazyList.range (start : ℕ) : LazyList ℕ :=
  LazyList.cons start (LazyList.range (start + 1))

-- 惰性列表操作
def LazyList.map {α β : Type} (f : α → β) : LazyList α → LazyList β
  | LazyList.nil => LazyList.nil
  | LazyList.cons x xs => LazyList.cons (f x) (LazyList.map f xs)

-- 惰性列表过滤
def LazyList.filter {α : Type} (p : α → Bool) : LazyList α → LazyList α
  | LazyList.nil => LazyList.nil
  | LazyList.cons x xs => 
    if p x then LazyList.cons x (LazyList.filter p xs)
    else LazyList.filter p xs
```

### 内存池管理 | Memory Pool Management

```lean
-- 对象池模式
structure ObjectPool (α : Type) where
  available : List α
  in_use : List α
  factory : Unit → α
  reset : α → α

def ObjectPool.acquire {α : Type} (pool : ObjectPool α) : α × ObjectPool α :=
  match pool.available with
  | [] => 
    let obj := pool.factory ()
    (obj, { pool with in_use := obj :: pool.in_use })
  | obj :: rest => 
    (obj, { pool with available := rest, in_use := obj :: pool.in_use })

def ObjectPool.release {α : Type} (pool : ObjectPool α) (obj : α) : ObjectPool α :=
  { pool with 
    available := pool.reset obj :: pool.available,
    in_use := pool.in_use.erase obj }
```

## 5. 并发优化 | Concurrency Optimization

### 并行计算 | Parallel Computation

```lean
-- 并行映射
def parallel_map {α β : Type} (f : α → β) (xs : List α) : List β :=
  -- 在实际实现中，这里会使用并行计算
  xs.map f

-- 并行归约
def parallel_reduce {α : Type} (f : α → α → α) (init : α) (xs : List α) : α :=
  -- 在实际实现中，这里会使用并行归约
  xs.foldl f init

-- 分治算法
def divide_and_conquer {α β : Type} (f : α → β) (combine : β → β → β) (xs : List α) : β :=
  match xs with
  | [] => sorry -- 处理空列表
  | [x] => f x
  | xs => 
    let mid := xs.length / 2
    let (left, right) := xs.splitAt mid
    combine (divide_and_conquer f combine left) (divide_and_conquer f combine right)
```

### 异步处理 | Asynchronous Processing

```lean
-- 异步任务
structure AsyncTask (α : Type) where
  result : Option α
  completed : Bool

def AsyncTask.create {α : Type} (f : Unit → α) : AsyncTask α :=
  { result := none, completed := false }

def AsyncTask.await {α : Type} (task : AsyncTask α) : Option α :=
  if task.completed then task.result else none

-- 任务组合
def AsyncTask.combine {α β γ : Type} (f : α → β → γ) (task1 : AsyncTask α) (task2 : AsyncTask β) : AsyncTask γ :=
  { result := none, completed := false }
```

## 6. 缓存优化 | Caching Optimization

### 记忆化 | Memoization

```lean
-- 简单记忆化
def memoize {α β : Type} [BEq α] [Hashable α] (f : α → β) : α → β :=
  let cache := HashMap.empty
  fun x => 
    match cache.find? x with
    | some y => y
    | none => 
      let y := f x
      cache.insert x y
      y

-- 记忆化斐波那契
def memoized_fibonacci : ℕ → ℕ :=
  memoize (fun n =>
    match n with
    | 0 => 0
    | 1 => 1
    | n + 2 => memoized_fibonacci n + memoized_fibonacci (n + 1))

-- 动态规划
def dynamic_programming {α β : Type} [BEq α] [Hashable α] (f : α → β) : α → β :=
  let cache := HashMap.empty
  fun x => 
    match cache.find? x with
    | some y => y
    | none => 
      let y := f x
      cache.insert x y
      y
```

### 缓存策略 | Caching Strategies

```lean
-- LRU缓存
structure LRUCache (α β : Type) where
  capacity : ℕ
  data : HashMap α β
  access_order : List α

def LRUCache.get {α β : Type} [BEq α] [Hashable α] (cache : LRUCache α β) (key : α) : Option β :=
  match cache.data.find? key with
  | some value => 
    let new_order := key :: cache.access_order.erase key
    some value
  | none => none

def LRUCache.put {α β : Type} [BEq α] [Hashable α] (cache : LRUCache α β) (key : α) (value : β) : LRUCache α β :=
  if cache.data.contains key then
    { cache with 
      data := cache.data.insert key value,
      access_order := key :: cache.access_order.erase key }
  else if cache.access_order.length < cache.capacity then
    { cache with 
      data := cache.data.insert key value,
      access_order := key :: cache.access_order }
  else
    let evicted := cache.access_order.getLast
    { cache with 
      data := cache.data.erase evicted |>.insert key value,
      access_order := key :: cache.access_order.dropLast }
```

## 7. 性能监控 | Performance Monitoring

### 性能指标 | Performance Metrics

```lean
-- 执行时间测量
structure PerformanceMetrics where
  execution_time : ℕ  -- 微秒
  memory_usage : ℕ    -- 字节
  cpu_usage : Float   -- 百分比

def measure_performance {α : Type} (f : Unit → α) : α × PerformanceMetrics :=
  let start_time := sorry -- 获取开始时间
  let result := f ()
  let end_time := sorry -- 获取结束时间
  let metrics := { 
    execution_time := end_time - start_time,
    memory_usage := sorry, -- 获取内存使用量
    cpu_usage := sorry     -- 获取CPU使用率
  }
  (result, metrics)

-- 性能分析
def analyze_performance {α : Type} (f : Unit → α) (iterations : ℕ) : PerformanceMetrics :=
  let results := (List.range iterations).map (fun _ => measure_performance f)
  let avg_time := results.map (·.2.execution_time) |>.sum / iterations
  let avg_memory := results.map (·.2.memory_usage) |>.sum / iterations
  let avg_cpu := results.map (·.2.cpu_usage) |>.sum / iterations
  { execution_time := avg_time, memory_usage := avg_memory, cpu_usage := avg_cpu }
```

### 性能测试 | Performance Testing

```lean
-- 基准测试
def benchmark {α : Type} (name : String) (f : Unit → α) (iterations : ℕ) : PerformanceMetrics :=
  let metrics := analyze_performance f iterations
  -- 在实际实现中，这里会记录和报告性能数据
  metrics

-- 性能比较
def compare_performance {α : Type} (f1 f2 : Unit → α) (iterations : ℕ) : String :=
  let metrics1 := benchmark "Function 1" f1 iterations
  let metrics2 := benchmark "Function 2" f2 iterations
  if metrics1.execution_time < metrics2.execution_time then
    "Function 1 is faster"
  else
    "Function 2 is faster"
```

## 8. 最佳实践总结 | Best Practices Summary

### 性能优化检查清单 | Performance Optimization Checklist

```lean
-- 1. 使用尾递归
def tail_recursive_example (n : ℕ) : ℕ :=
  let rec aux (acc i : ℕ) : ℕ :=
    if i = 0 then acc
    else aux (acc * i) (i - 1)
  aux 1 n

-- 2. 选择合适的数据结构
def appropriate_data_structure (m : HashMap String ℕ) (key : String) : Option ℕ :=
  m.find? key

-- 3. 避免不必要的计算
def avoid_unnecessary_computation (xs : List ℕ) : ℕ :=
  xs.foldl (· + ·) 0

-- 4. 使用记忆化
def use_memoization {α β : Type} [BEq α] [Hashable α] (f : α → β) : α → β :=
  memoize f

-- 5. 模块化设计
namespace OptimizedModule
  def helper (x : ℕ) : ℕ := x * 2
  def main (x : ℕ) : ℕ := helper x
end OptimizedModule
```

---

*相关链接：*

- [学习路径指南](./01-学习路径指南.md)
- [常见问题解答](./02-常见问题解答.md)
- [基础语法与类型系统](../02-基础语法与类型系统/01-基础语法元素.md)
- [函数式编程实践](../05-高级主题与应用/03-函数式编程实践.md)
