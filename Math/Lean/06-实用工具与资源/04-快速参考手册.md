# 快速参考手册 | Quick Reference Guide

> 提示：就地跳转
>
> - 术语索引：见《[术语表与索引](./10-术语表与索引.md)》的“首批术语↔Lean定义↔mathlib链接”。
> - 导航搜索：见《[导航与搜索指南](./13-导航与搜索指南.md)》的“快速索引清单/Playbook/命令区”。

## 1. 基础语法速查 | Basic Syntax Quick Reference

### 关键字 | Keywords

```lean
-- 声明关键字
def, theorem, lemma, example, variable, constant, axiom

-- 控制流关键字
if, then, else, match, with, cases, induction

-- 类型关键字
Type, Prop, Sort, Type*, Prop*

-- 导入关键字
import, open, namespace, end
```

### 运算符 | Operators

```lean
-- 算术运算符
+, -, *, /, ^, %  -- 加法、减法、乘法、除法、幂、取模

-- 比较运算符
=, ≠, <, ≤, >, ≥  -- 等于、不等于、小于、小于等于、大于、大于等于

-- 逻辑运算符
∧, ∨, ¬, →, ↔  -- 合取、析取、否定、蕴含、等价

-- 集合运算符
∈, ∉, ⊆, ⊂, ∪, ∩, \  -- 属于、不属于、子集、真子集、并集、交集、差集
```

### 类型注解 | Type Annotations

```lean
-- 基本类型
ℕ, ℤ, ℚ, ℝ, ℂ  -- 自然数、整数、有理数、实数、复数
Bool, String, Unit  -- 布尔、字符串、单位类型

-- 复合类型
α × β  -- 积类型
α ⊕ β  -- 和类型
α → β  -- 函数类型
List α  -- 列表类型
Array α  -- 数组类型
```

## 2. 证明策略速查 | Proof Tactics Quick Reference

### 基本策略 | Basic Tactics

```lean
-- 引入策略
intro h        -- 引入一个假设
intros h1 h2   -- 引入多个假设
intros         -- 自动引入所有假设

-- 精确策略
exact h        -- 精确匹配假设
apply h        -- 应用定理或假设
assumption     -- 自动寻找匹配的假设

-- 重写策略
rw [h]         -- 使用假设重写
rw [←h]        -- 反向重写
rw [h] at h'   -- 在特定位置重写
rfl            -- 自反性
```

相关：`simp`/`rw` 排错最小示例与命令参见《[导航与搜索指南](./13-导航与搜索指南.md)》。

直达示例：

- `rw`/`simp`/`rfl`：见《[示例库](./05-示例库.md)》“最小可运行证明集”1-6、12
- `cases`/`induction`：见“最小可运行证明集”5、6、14
- `exists`/`Or`/`and` 构造：见“最小可运行证明集”7、8、9

### 自动化策略 | Automation Tactics

```lean
-- 简化策略
simp           -- 自动简化
simp [h1, h2]  -- 使用特定假设简化
norm_num       -- 数值计算
ring           -- 环运算

-- 决策过程
linarith       -- 线性算术
omega          -- 整数线性算术
decide         -- 可判定命题

-- 搜索策略
auto           -- 自动证明
trivial        -- 简单证明
contradiction  -- 寻找矛盾
```

### 案例分析策略 | Case Analysis Tactics

```lean
-- 案例分析
cases h        -- 案例分析
induction n    -- 归纳证明
cases n with   -- 带模式匹配的案例分析
  | zero => ...
  | succ n => ...

-- 存在性策略
exists x       -- 构造存在性证明
use x          -- 使用特定值
```

#### simp/rw 排错对照输出 | Troubleshooting simp/rw

最小示例：

```lean
-- 方向不符导致 rw 失败
example (x y : Nat) (h : x = y) : y = x := by
  -- 目标是 y = x，但 h 的方向是 x = y
  -- 解决1：使用对称等式
  have hx : y = x := Eq.symm h
  exact hx

-- 指定方向或在特定位置重写
example (x y : Nat) (h : x = y) : y + 1 = x + 1 := by
  rw [← h]

-- 查看 simp 使用了哪些规则
set_option trace.simp true
example (n : Nat) : n + 0 = n := by
  simp  -- 观察消息面板中加载的规则
```

常见症状 → 原因 → 解决：

- 目标方向不匹配 → `rw` 默认按给定等式方向重写 → 使用 `←` 或 `Eq.symm`
- `simp` 不收敛/无效果 → 缺少 `[simp]` 标注或实例/导入缺失 → 为定理加 `@[simp]`，`simp [h]`，确认 `import` 与实例存在
- 重写位置不对 → 上下文目标不匹配 → 使用 `rw [h] at h'` 指定位置，或用 `have/convert/calc` 中间过渡
-- 规则过多导致慢 → `simp` 规则集过大 → 局部化：`simp [only: ...]`，或临时禁用昂贵规则

## 3. 数据结构速查 | Data Structures Quick Reference

### 列表操作 | List Operations

```lean
-- 列表构造
[]              -- 空列表
x :: xs         -- 头部添加元素
[x1, x2, x3]    -- 列表字面量

-- 列表操作
xs.length       -- 列表长度
xs.head         -- 头部元素
xs.tail         -- 尾部列表
xs.append ys    -- 列表连接
xs.map f        -- 映射函数
xs.filter p     -- 过滤元素
xs.foldl f init -- 左折叠
xs.foldr f init -- 右折叠
```

### 数组操作 | Array Operations

```lean
-- 数组构造
#[]             -- 空数组
#[x1, x2, x3]   -- 数组字面量

-- 数组操作
arr.size        -- 数组大小
arr.get i       -- 获取元素
arr.set i x     -- 设置元素
arr.push x      -- 添加元素
arr.pop         -- 移除最后一个元素
```

### 哈希表操作 | HashMap Operations

```lean
-- 哈希表构造
HashMap.empty   -- 空哈希表
HashMap.ofList  -- 从列表构造

-- 哈希表操作
m.find? k       -- 查找键
m.contains k    -- 检查键是否存在
m.insert k v    -- 插入键值对
m.erase k       -- 删除键
m.size          -- 哈希表大小
```

## 4. 类型类速查 | Type Classes Quick Reference

### 基本类型类 | Basic Type Classes

```lean
-- 数值类型类
Add α           -- 加法
Mul α           -- 乘法
Sub α           -- 减法
Div α           -- 除法
Neg α           -- 取负
Zero α          -- 零元
One α           -- 单位元

-- 比较类型类
LE α            -- 小于等于
LT α            -- 小于
BEq α           -- 布尔相等
Hashable α      -- 可哈希

-- 逻辑类型类
And α           -- 合取
Or α            -- 析取
Not α           -- 否定
```

### 高级类型类 | Advanced Type Classes

```lean
-- 代数结构
Group α         -- 群
Ring α          -- 环
Field α         -- 域
VectorSpace V K -- 向量空间

-- 范畴论
Functor F       -- 函子
Monad M         -- 单子
Applicative F   -- 应用函子
```

## 5. 数学符号速查 | Mathematical Symbols Quick Reference

### 集合论符号 | Set Theory Symbols

```lean
-- 基本集合
∅, univ         -- 空集、全集
s ∪ t           -- 并集
s ∩ t           -- 交集
s \ t           -- 差集
sᶜ              -- 补集

-- 集合关系
x ∈ s           -- 属于
x ∉ s           -- 不属于
s ⊆ t           -- 子集
s ⊂ t           -- 真子集
s = t           -- 相等
```

### 逻辑符号 | Logical Symbols

```lean
-- 基本逻辑
P ∧ Q           -- 合取
P ∨ Q           -- 析取
¬P              -- 否定
P → Q           -- 蕴含
P ↔ Q           -- 等价

-- 量词
∀ x, P x        -- 全称量词
∃ x, P x        -- 存在量词
∃! x, P x       -- 存在唯一
```

### 数学函数符号 | Mathematical Function Symbols

```lean
-- 基本函数
f ∘ g           -- 函数复合
f⁻¹             -- 逆函数
f'              -- 导数
∫ f             -- 积分

-- 极限和连续性
lim f           -- 极限
Tendsto f a b   -- 趋向
Continuous f    -- 连续
```

## 6. 常用模式速查 | Common Patterns Quick Reference

### 函数定义模式 | Function Definition Patterns

```lean
-- 简单函数
def f (x : α) : β := expr

-- 递归函数
def f : α → β
  | pattern1 => expr1
  | pattern2 => expr2

-- 带守卫的函数
def f (x : α) (h : P x) : β := expr

-- 多参数函数
def f (x : α) (y : β) (z : γ) : δ := expr
```

### 证明模式 | Proof Patterns

```lean
-- 直接证明
theorem name (h1 : P) (h2 : Q) : R := by
  exact expr

-- 分情况证明
theorem name (h : P ∨ Q) : R := by
  cases h with
  | inl hp => exact expr1
  | inr hq => exact expr2

-- 归纳证明
theorem name (n : ℕ) : P n := by
  induction n with
  | zero => exact expr1
  | succ n ih => exact expr2
```

### 类型定义模式 | Type Definition Patterns

```lean
-- 简单归纳类型
inductive TypeName where
  | constructor1 : TypeName
  | constructor2 : α → TypeName

-- 参数化类型
inductive TypeName (α : Type) where
  | constructor : α → TypeName α

-- 递归类型
inductive TypeName where
  | base : TypeName
  | recursive : TypeName → TypeName
```

## 7. 错误处理速查 | Error Handling Quick Reference

### 常见错误类型 | Common Error Types

```lean
-- 类型不匹配
-- def f (x : ℕ) : String := x  -- 错误：类型不匹配

-- 未定义标识符
-- def f (x : ℕ) : ℕ := undefined_function x  -- 错误：未定义

-- 缺少类型类实例
-- def f {α : Type} (x y : α) : α := x + y  -- 错误：缺少Add实例

-- 模式匹配不完整
-- def f : ℕ → ℕ
--   | 0 => 1  -- 错误：缺少其他情况
```

### 错误修复方法 | Error Fixing Methods

```lean
-- 类型转换
def f (x : ℕ) : String := toString x

-- 添加类型类约束
def f {α : Type} [Add α] (x y : α) : α := x + y

-- 完整模式匹配
def f : ℕ → ℕ
  | 0 => 1
  | n + 1 => f n + 1

-- 使用sorry占位符
theorem incomplete : P := by
  sorry  -- 稍后完成
```

## 8. 性能优化速查 | Performance Optimization Quick Reference

### 编译优化 | Compilation Optimization

```lean
-- 避免过度导入
import Mathlib.Data.Nat.Basic  -- 而不是 import Mathlib.All

-- 使用类型推断
def f (x) := x + 1  -- 让Lean推断类型

-- 模块化设计
namespace Optimized
  def helper (x : ℕ) : ℕ := x * 2
  def main (x : ℕ) : ℕ := helper x
end Optimized
```

### 运行时优化 | Runtime Optimization

```lean
-- 尾递归
def factorial (n : ℕ) : ℕ :=
  let rec aux (acc i : ℕ) : ℕ :=
    if i = 0 then acc
    else aux (acc * i) (i - 1)
  aux 1 n

-- 适当的数据结构
def lookup (m : HashMap String ℕ) (key : String) : Option ℕ :=
  m.find? key  -- 使用HashMap而不是List

-- 避免重复计算
def memoized_fib : ℕ → ℕ :=
  memoize (fun n => 
    match n with
    | 0 => 0
    | 1 => 1
    | n + 2 => memoized_fib n + memoized_fib (n + 1))
```

## 9. 调试技巧速查 | Debugging Tips Quick Reference

### 调试命令 | Debugging Commands

```lean
-- 检查类型
#check expr        -- 显示表达式类型
#check Type        -- 显示类型信息

-- 计算值
#eval expr         -- 计算表达式值
#reduce expr       -- 显示计算过程

-- 证明状态
-- 在证明中使用 sorry 逐步构建
theorem debug : P := by
  intro h
  -- 在这里添加 sorry，逐步完成证明
  sorry
```

### 调试策略 | Debugging Strategies

```lean
-- 1. 检查类型匹配
#check Nat.add     -- 输出：ℕ → ℕ → ℕ

-- 2. 验证计算
#eval 2 + 3        -- 输出：5

-- 3. 逐步构建证明
theorem step_by_step (a b : ℕ) : a = b → a + 1 = b + 1 := by
  intro h
  -- 检查目标：a + 1 = b + 1
  -- 检查假设：h : a = b
  rw [h]  -- 使用假设重写目标
```

## 10. 最佳实践速查 | Best Practices Quick Reference

### 代码组织 | Code Organization

```lean
-- 使用描述性命名
def calculate_fibonacci_number (n : ℕ) : ℕ :=
  match n with
  | 0 => 0
  | 1 => 1
  | n + 2 => calculate_fibonacci_number n + calculate_fibonacci_number (n + 1)

-- 添加类型注解
def explicit_types (x : ℕ) (y : String) : ℕ × String :=
  (x, y)

-- 使用适当的抽象
def generic_operation {α : Type} [Add α] (x y : α) : α :=
  x + y
```

### 证明风格 | Proof Style

```lean
-- 清晰的证明结构
theorem clear_proof (a b c : ℕ) : a = b → b = c → a = c := by
  intro hab hbc
  rw [hab, hbc]

-- 使用注释
theorem commented_proof (n : ℕ) : n + 0 = n := by
  -- 使用自然数的加法单位元性质
  exact Nat.add_zero n

-- 分步骤证明
theorem step_proof (p q : Prop) : p → q → p ∧ q := by
  intro hp hq
  constructor
  · exact hp  -- 证明第一个目标
  · exact hq  -- 证明第二个目标
```

---

*相关链接：*

- [学习路径指南](./01-学习路径指南.md)
- [常见问题解答](./02-常见问题解答.md)
- [性能优化指南](./03-性能优化指南.md)
- [基础语法与类型系统](../02-基础语法与类型系统/01-基础语法元素.md)
