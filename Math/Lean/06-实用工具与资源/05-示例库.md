# ç¤ºä¾‹åº“ | Examples Library

## 1. åŸºç¡€è¯­æ³•ç¤ºä¾‹ | Basic Syntax Examples

### å‡½æ•°å®šä¹‰ç¤ºä¾‹ | Function Definition Examples

```lean
-- ç®€å•å‡½æ•°
def add (x y : â„•) : â„• := x + y

-- é€’å½’å‡½æ•°
def factorial : â„• â†’ â„•
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

-- å¸¦æ¨¡å¼åŒ¹é…çš„å‡½æ•°
def is_even : â„• â†’ Bool
  | 0 => true
  | 1 => false
  | n + 2 => is_even n

-- é«˜é˜¶å‡½æ•°
def apply_twice {Î± : Type} (f : Î± â†’ Î±) (x : Î±) : Î± := f (f x)

-- å¤šå‚æ•°å‡½æ•°
def power (base : â„•) (exp : â„•) : â„• :=
  match exp with
  | 0 => 1
  | n + 1 => base * power base n
```

### ç±»å‹å®šä¹‰ç¤ºä¾‹ | Type Definition Examples

```lean
-- ç®€å•å½’çº³ç±»å‹
inductive Color where
  | red : Color
  | green : Color
  | blue : Color

-- å‚æ•°åŒ–ç±»å‹
inductive Option (Î± : Type) where
  | none : Option Î±
  | some (val : Î±) : Option Î±

-- é€’å½’ç±»å‹
inductive Tree (Î± : Type) where
  | leaf (value : Î±) : Tree Î±
  | node (left right : Tree Î±) : Tree Î±

-- ä¾èµ–ç±»å‹
inductive Vector (Î± : Type) : â„• â†’ Type where
  | nil : Vector Î± 0
  | cons (head : Î±) (tail : Vector Î± n) : Vector Î± (n + 1)
```

## 2. è¯æ˜ç¤ºä¾‹ | Proof Examples

### åŸºæœ¬è¯æ˜ç¤ºä¾‹ | Basic Proof Examples

```lean
-- ç­‰å¼è¯æ˜
theorem add_zero (n : â„•) : n + 0 = n := by
  exact Nat.add_zero n

-- æ¡ä»¶è¯æ˜
theorem conditional (p q : Prop) : p â†’ q â†’ p âˆ§ q := by
  intro hp hq
  exact âŸ¨hp, hqâŸ©

-- åˆ†æƒ…å†µè¯æ˜
theorem cases_example (n : â„•) : n = 0 âˆ¨ n > 0 := by
  cases n with
  | zero => left; rfl
  | succ n => right; exact Nat.succ_pos n

-- å½’çº³è¯æ˜
theorem induction_example (n : â„•) : n + 0 = n := by
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.add_succ, ih]
```

### æœ€å°å¯è¿è¡Œè¯æ˜é›† | Minimal Runnable Proof Set

```lean
-- 1. è‡ªåæ€§ä¸ rw
example (x : Nat) : x = x := by rfl

-- 2. ä½¿ç”¨å‡è®¾é‡å†™
example (x y : Nat) (h : x = y) : x + 1 = y + 1 := by
  rw [h]

-- 3. åå‘é‡å†™
example (x y : Nat) (h : x = y) : y + 1 = x + 1 := by
  rw [â† h]

-- 4. simp ä½¿ç”¨ï¼ˆåŠ æ³•å•ä½å…ƒï¼‰
example (n : Nat) : n + 0 = n := by
  simp

-- 5. cases åˆ†è§£å¸ƒå°”ç­‰å¼
example (b : Bool) : b = true âˆ¨ b = false := by
  cases b <;> simp

-- 6. è‡ªç„¶æ•°å½’çº³
example (n : Nat) : n + 0 = n := by
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.add_succ, ih]

-- 7. å­˜åœ¨æ€§æ„é€ 
example : âˆƒ n : Nat, n > 0 := by
  refine âŸ¨1, ?_âŸ©
  decide

-- 8. conjunction æ„é€ 
example (p q : Prop) (hp : p) (hq : q) : p âˆ§ q := by
  exact âŸ¨hp, hqâŸ©

-- 9. disjunction æ„é€ 
example (p q : Prop) (hp : p) : p âˆ¨ q := by
  exact Or.inl hp

-- 10. implication é“¾
example (p q r : Prop) : (p â†’ q) â†’ (q â†’ r) â†’ (p â†’ r) := by
  intro hpq hqr hp
  exact hqr (hpq hp)

-- 11. ç±»å‹æ£€æŸ¥è¾…åŠ©
example : (fun x : Nat => x + 1) 2 = 3 := by
  rfl

-- 12. ç®€å•ç­‰å¼é“¾ï¼ˆcalcï¼‰
example (a b : Nat) (h : a = b) : a + 2 = b + 2 := by
  calc
    a + 2 = b + 2 := by simpa [h]
```

#### ç»“æ„/ç±»å‹ç±»/å½’çº³ç›¸å…³æœ€å°ä¾‹

```lean
-- 13. structure å®šä¹‰ä¸å­—æ®µè®¿é—®
structure Point where
  x : Nat
  y : Nat

example : Point := { x := 1, y := 2 }
example (p : Point) : p.x + p.y = p.y + p.x := by
  simp [Nat.add_comm]

-- 14. inductive å®šä¹‰ä¸ cases
inductive Sign where
  | pos | neg

example (s : Sign) : s = Sign.pos âˆ¨ s = Sign.neg := by
  cases s <;> simp

-- 15. class/instance ä¸ä½¿ç”¨
class HasDouble (Î± : Type) where
  double : Î± â†’ Î±

instance : HasDouble Nat where
  double x := x * 2

example : HasDouble Nat := inferInstance
example (n : Nat) : HasDouble.double n = n * 2 := by rfl

-- 16. ç®€å•å®šç†ä½¿ç”¨ï¼šcommutativity
example (a b : Nat) : a + b = b + a := by simpa [Nat.add_comm]

-- 17. calc ç­‰å¼é“¾æ›´å¤æ‚ä¸€æ­¥
example (a : Nat) : a + 1 + 1 = a + 2 := by
  calc
    a + 1 + 1 = a + (1 + 1) := by simp [Nat.add_assoc]
    _ = a + 2 := by rfl

-- 18. æ¨¡å‹åŒ–çº¿æ€§æ˜ å°„ï¼ˆä»¥å‡½æ•°ä»£æ›¿ï¼‰
def linearLike (k : Nat) : Nat â†’ Nat := fun x => k * x
example : linearLike 2 3 = 6 := by rfl

-- 19. Option æ¡ˆä¾‹åˆ†æ
example (o : Option Nat) : o = none âˆ¨ âˆƒ n, o = some n := by
  cases o with
  | none => exact Or.inl rfl
  | some n => exact Or.inr âŸ¨n, rflâŸ©

-- 20. List åŸºæœ¬æ€§è´¨ï¼ˆé•¿åº¦ï¼‰
example (xs : List Nat) : (xs ++ []) = xs := by
  simp
```

> ç›¸å…³ï¼šæ›´å¤šåŸºç¡€æœ¯è¯­ä¸æ¨¡å—è·¯å¾„è§ã€Š[æœ¯è¯­è¡¨ä¸ç´¢å¼•](./10-æœ¯è¯­è¡¨ä¸ç´¢å¼•.md)ã€‹ã€‚

#### è¿½åŠ ï¼šä»£æ•°/åˆ—è¡¨ç­‰æœ€å°å¯è¿è¡Œè¯æ˜ï¼ˆè¡¥å……6ä¸ªï¼‰

```lean
-- 21. è‡ªç„¶æ•°åŠ æ³•ç»“åˆå¾‹ï¼ˆä½¿ç”¨ simpï¼‰
example (a b c : Nat) : (a + b) + c = a + (b + c) := by
  simpa [Nat.add_assoc]

-- 22. è‡ªç„¶æ•°ä¹˜æ³•äº¤æ¢å¾‹
example (a b : Nat) : a * b = b * a := by
  simpa [Nat.mul_comm]

-- 23. åˆ†é…å¾‹ç¤ºä¾‹
example (a b c : Nat) : a * (b + c) = a * b + a * c := by
  simpa [Nat.mul_add]

-- 24. åˆ—è¡¨è¿æ¥ä¸é•¿åº¦
example (xs ys : List Nat) : (xs ++ ys).length = xs.length + ys.length := by
  simp

-- 25. åˆ—è¡¨ map èº«ä»½å‡½æ•°ä¸å˜
example (xs : List Nat) : xs.map (fun x => x) = xs := by
  simpa

-- 26. åˆ—è¡¨ filter æ’çœŸç­‰äºè‡ªèº«
example (xs : List Nat) : xs.filter (fun _ => True) = xs := by
  simpa
```

#### è¿½åŠ ï¼šä»£æ•°ä¸æ‹“æ‰‘æœ€å°å¯è¿è¡Œè¯æ˜ï¼ˆå„3ä¸ªï¼‰

```lean
-- 27. ä»£æ•°ï¼šè‡ªç„¶æ•°åŠ æ³•çš„å·¦å•ä½å…ƒ
example (a : Nat) : 0 + a = a := by
  simpa [Nat.zero_add]

-- 28. ä»£æ•°ï¼šè‡ªç„¶æ•°ä¹˜æ³•çš„å³å•ä½å…ƒ
example (a : Nat) : a * 1 = a := by
  simpa [Nat.mul_one]

-- 29. ä»£æ•°ï¼šä¹˜æ³•å¯¹ 0 çš„å¸æ”¶
example (a : Nat) : a * 0 = 0 := by
  simpa [Nat.mul_zero]

-- 30. æ‹“æ‰‘ï¼šäº¤é›†åŒ…å«ï¼ˆéœ€è¦ mathlibï¼‰
import Mathlib.Topology.Basic
open Set

example (Î± : Type) [TopologicalSpace Î±] (s t : Set Î±) : s âˆ© t âŠ† s := by
  intro x hx
  exact And.left hx

-- 31. æ’ç­‰æ˜ å°„è¿ç»­ï¼ˆéœ€è¦ mathlibï¼‰
example (Î± : Type) [TopologicalSpace Î±] : Continuous (fun x : Î± => x) := by
  simpa using continuous_id

-- 32. é—­é›†ä¸å¼€é›†çš„äº’è¡¥äº’æ¨ï¼ˆéœ€è¦ mathlibï¼‰
example (Î± : Type) [TopologicalSpace Î±] (s : Set Î±) : IsClosed s â†” IsOpen sá¶œ := by
  simpa using isClosed_compl_iff
```

### é«˜çº§è¯æ˜ç¤ºä¾‹ | Advanced Proof Examples

```lean
-- å­˜åœ¨æ€§è¯æ˜
theorem exists_example : âˆƒ n : â„•, n > 0 := by
  exists 1
  exact Nat.one_pos

-- å”¯ä¸€æ€§è¯æ˜
theorem unique_example (a : â„•) : âˆƒ! b : â„•, a + b = a + 1 := by
  constructor
  Â· exists 1
    constructor
    Â· rfl
    Â· intro b hb
      linarith
  Â· intro b1 b2 h1 h2
    linarith

-- åè¯æ³•
theorem contradiction_example (p : Prop) : p â†’ Â¬p â†’ False := by
  intro hp hnp
  exact hnp hp
```

#### è¿½åŠ ï¼šç¾¤/ç¯/åŸŸä¸ tactic é“¾æ¡ï¼ˆæ–°å¢12ä¸ªï¼‰

```lean
-- 33. ç¾¤ï¼šå·¦é€†æ¶ˆå»
section GroupExamples
variable {G : Type} [Group G]
example (a b : G) : aâ»Â¹ * (a * b) = b := by
  simpa [mul_assoc, inv_mul_cancel_left] using inv_mul_cancel_left a b

-- 34. ç¾¤ï¼šå…±è½­çš„ä¹˜æ³•åˆ†é…
example (a b c : G) : a * (b * aâ»Â¹) * (a * c * aâ»Â¹) = a * (b * c) * aâ»Â¹ := by
  group

-- 35. äº¤æ¢ç¾¤ï¼šåŠ æ³•äº¤æ¢å¾‹ç›´æ¥åŒ–ç®€
example (x y z : AddCommGroup) : (x + y) + z = x + (y + z) := by
  simpa [add_assoc]
end GroupExamples

-- 36. ç¯ï¼šåˆ†é…å¾‹ä¸é›¶å…ƒ
section RingExamples
variable {R : Type} [Semiring R]
example (a b : R) : a * (b + 0) = a * b := by
  simpa using by
    simpa [add_comm] using (by simp : a * (0 + b) = a * b)

-- 37. ç¯ï¼šä¹˜æ³•å¯¹å’Œçš„åˆ†é…
example (a b c : R) : (a + b) * c = a * c + b * c := by
  simpa [left_distrib]
end RingExamples

-- 38. åŸŸï¼šéé›¶æœ‰å€’æ•°
section FieldExamples
variable {K : Type} [Field K] {a : K}
example (h : a â‰  0) : a * aâ»Â¹ = 1 := by
  simpa using mul_inv_cancel h
end FieldExamples

-- 39. tactic é“¾ï¼šintro â†’ apply â†’ rw
example (p q r : Prop) (hpq : p â†’ q) (hqr : q â†’ r) : p â†’ r := by
  intro hp
  apply hqr
  apply hpq
  exact hp

-- 40. tactic é“¾ï¼šcases â†’ simp
example (o : Option Nat) : o = none âˆ¨ âˆƒ n, o = some n := by
  cases o with
  | none => exact Or.inl rfl
  | some n => exact Or.inr âŸ¨n, rflâŸ©

-- 41. tactic é“¾ï¼šinduction â†’ simp
example (xs : List Nat) : xs ++ [] = xs := by
  induction xs with
  | nil => simp
  | cons x xs ih => simp [ih]

-- 42. calc é“¾ï¼šç­‰å¼ä¼ é€’
example (a b : Nat) (h : a = b) : a + 3 = b + 3 := by
  calc
    a + 3 = b + 3 := by simpa [h]

-- 43. rw å®šä½ï¼šåœ¨å‡è®¾å¤„é‡å†™
example (a b c : Nat) (h : a = b) (hc : a + c = c + a) : b + c = c + b := by
  have hc' := hc
  rw [h] at hc'
  simpa [Nat.add_comm] using hc'

-- 44. simp ä»…è§„åˆ™ï¼šonly é™å®šè§„åˆ™é›†
example (a b c : Nat) : (a + b) + c = a + (b + c) := by
  simp [Nat.add_assoc]

-- 45. aesop ç®€åŒ–ï¼ˆå¦‚å¯ç”¨ï¼‰
-- example (p q r : Prop) : (p âˆ§ q) â†’ q := by
--   aesop
```

#### è¿½åŠ ï¼šæ ¸å¿ƒä¸»é¢˜æœ€å°å¯è¿è¡Œè¯æ˜ï¼ˆæ–°å¢15ä¸ªï¼ŒP0ï¼‰

```lean
-- A. ä»£æ•°ï¼ˆç¾¤/ç¯/åŸŸï¼‰å„2
section CoreAlgebra
variable {G : Type} [Group G]
variable {R : Type} [Semiring R]
variable {K : Type} [Field K]

-- 46. ç¾¤ï¼šå³æ¶ˆå»
example (a b : G) : (a * b) * bâ»Â¹ = a := by
  simpa [mul_assoc] using mul_mul_inv a b

-- 47. ç¾¤ï¼šå•ä½å…ƒå”¯ä¸€
example (eâ‚ eâ‚‚ : G) (h1 : âˆ€ a, eâ‚ * a = a) (h2 : âˆ€ a, eâ‚‚ * a = a) : eâ‚ = eâ‚‚ := by
  have := h1 eâ‚‚
  simpa using this.trans (h2 eâ‚).symm

-- 48. ç¯ï¼šé›¶ä¹˜å¸æ”¶
example (a : R) : 0 * a = 0 := by simpa [zero_mul]

-- 49. ç¯ï¼šåŠ æ³•æ¶ˆå»
example (a b c : R) : a + b = a + c â†’ b = c := by
  intro h; simpa using add_left_cancel h

-- 50. åŸŸï¼šåˆ†å¼æ­£è§„åŒ–ï¼ˆéé›¶ï¼‰
example (x : K) (hx : x â‰  0) : x / x = 1 := by simpa [div_eq_mul_inv] using mul_inv_cancel hx

-- 51. åŸŸï¼šå€’æ•°å”¯ä¸€
example (x : K) (hx : x â‰  0) {y z : K} (hy : x * y = 1) (hz : x * z = 1) : y = z := by
  have : y = y * 1 := by simp
  simpa [hy, hz, mul_assoc] using congrArg (fun t => y * t) (by simpa using hz)
end CoreAlgebra

-- B. ç­–ç•¥é“¾æ¡ï¼ˆintro/apply/rw/inductionï¼‰å„2
section CoreTactics
-- 52. intro â†’ apply
example (p q r : Prop) (hpq : p â†’ q) (hqr : q â†’ r) : p â†’ r := by
  intro hp; apply hqr; exact hpq hp

-- 53. rw é“¾ï¼ˆå¤šæ­¥ï¼‰
example (a b c : Nat) (hâ‚ : a = b) (hâ‚‚ : b = c) : a + 1 = c + 1 := by
  rw [hâ‚, hâ‚‚]

-- 54. ç®€å•å½’çº³ï¼ˆListï¼‰
example (xs : List Nat) : xs ++ [] = xs := by
  induction xs with
  | nil => simp
  | cons x xs ih => simp [ih]

-- 55. Nat å½’çº³ä¸ simp
example (n : Nat) : n + 0 = n := by
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.add_succ, ih]
end CoreTactics

-- C. ç±»å‹ç³»ç»Ÿï¼ˆstructure/inductive/class/instanceï¼‰å„1
section CoreTypes
-- 56. structure ä¸å­—æ®µ
structure Pair where
  fst : Nat
  snd : Nat

example (p : Pair) : p.fst + p.snd = p.snd + p.fst := by
  simp [Nat.add_comm]

-- 57. inductive ä¸ cases
inductive Bit where | zero | one
example (b : Bit) : b = Bit.zero âˆ¨ b = Bit.one := by cases b <;> simp

-- 58. class/instance åŸºæœ¬ä½¿ç”¨
class HasTriple (Î± : Type) where triple : Î± â†’ Î±
instance : HasTriple Nat where triple x := 3 * x
example (n : Nat) : HasTriple.triple n = 3 * n := rfl
end CoreTypes

-- D. é›†åˆä¸æ‹“æ‰‘/åˆ†æå„1
section CoreMathlib
import Mathlib.Topology.Basic
import Mathlib/Analysis/Calculus/Deriv
open Set

-- 59. æ‹“æ‰‘ï¼šäº¤é›†åŒ…å«
example (Î± : Type) [TopologicalSpace Î±] (s t : Set Î±) : s âˆ© t âŠ† s := by
  intro x hx; exact And.left hx

-- 60. åˆ†æï¼šå¸¸å€¼å‡½æ•°å¯¼æ•°ä¸º 0
example : deriv (fun x : â„ => (5 : â„)) = 0 := by
  simpa using deriv_const (c := (5 : â„))
end CoreMathlib
```

#### è¿½åŠ ï¼šåˆ†æ/èŒƒç•´/æµ‹åº¦ æœ€å°å¯è¿è¡Œè¯æ˜ï¼ˆæ–°å¢12ä¸ªï¼‰

```lean
-- åˆ†æï¼ˆ4ï¼‰
section AnalysisMini
import Mathlib/Analysis/Calculus/Deriv
open Real

-- 61. å¸¸å€¼å‡½æ•°å¯¼æ•°ä¸º 0ï¼ˆå†æ¬¡ä»¥å˜ä½“å±•ç¤ºï¼‰
example : deriv (fun x : â„ => (7 : â„)) = 0 := by simpa using deriv_const (c := (7 : â„))

-- 62. x â†¦ x çš„å¯¼æ•°ä¸º 1
example : deriv (fun x : â„ => x) = 1 := by simpa using deriv_id (ğ•œ := â„)

-- 63. çº¿æ€§å‡½æ•° ax çš„å¯¼æ•°ä¸ºå¸¸æ•° a
example (a : â„) : deriv (fun x : â„ => a * x) = fun _ => a := by
  simpa using deriv_const_mul (c := a) (f := fun x : â„ => x)

-- 64. å’Œçš„å¯¼æ•°ä¸ºå¯¼æ•°ä¹‹å’Œ
example (f g : â„ â†’ â„) (hf : Differentiable â„ f) (hg : Differentiable â„ g) :
    deriv (fun x => f x + g x) = fun x => deriv f x + deriv g x := by
  simpa using (deriv_add hf.differentiableAt hg.differentiableAt)
end AnalysisMini

-- èŒƒç•´ï¼ˆ4ï¼‰
section CategoryMini
import Mathlib/CategoryTheory/Category/Basic
open CategoryTheory

-- 65. ä»»ä¸€èŒƒç•´åŒæ„çš„å·¦å³é€†äº’ä¸ºé€†
example {C : Type} [Category C] {X Y : C} (e : X â‰… Y) : e.hom â‰« e.inv = ğŸ™ X := by
  simpa using e.hom_inv_id

-- 66. æ’ç­‰åŒæ„çš„åŒæ„æ€§
example {C : Type} [Category C] (X : C) : (Iso.refl X).hom = ğŸ™ X := rfl

-- 67. åŒæ„çš„åˆæˆä»ä¸ºåŒæ„
example {C : Type} [Category C] {X Y Z : C} (eâ‚ : X â‰… Y) (eâ‚‚ : Y â‰… Z) : X â‰… Z :=
  eâ‚.trans eâ‚‚

-- 68. è‡ªååŒæ„ç­‰äºæ’ç­‰åŒæ„ï¼ˆå‘½é¢˜å±‚é¢ï¼‰
example {C : Type} [Category C] (X : C) : (Iso.refl X).inv = ğŸ™ X := rfl
end CategoryMini

-- æµ‹åº¦ï¼ˆ4ï¼‰
section MeasureMini
import Mathlib/MeasureTheory/Measure/MeasureSpace
open MeasureTheory

-- 69. å¯æµ‹ç©ºé—´ä¸Šç©ºé›†å¯æµ‹
example {Î± : Type} [MeasurableSpace Î±] : MeasurableSet (âˆ… : Set Î±) := by
  simpa using (measurableSet_empty : MeasurableSet (âˆ… : Set Î±))

-- 70. å•ç‚¹é›†å¯æµ‹ï¼ˆå¯æ•°é›†å¯æµ‹ï¼‰
example {Î± : Type} [MeasurableSpace Î±] [MeasurableSingleton Î±] (x : Î±) :
    MeasurableSet ({x} : Set Î±) := by
  simpa using (measurableSet_singleton x)

-- 71. å¯æµ‹æ€§çš„å¹¶é—­åŒ…
example {Î± : Type} [MeasurableSpace Î±] {s t : Set Î±}
    (hs : MeasurableSet s) (ht : MeasurableSet t) : MeasurableSet (s âˆª t) := by
  simpa using hs.union ht

-- 72. å¯æµ‹æ€§çš„äº¤é—­åŒ…
example {Î± : Type} [MeasurableSpace Î±] {s t : Set Î±}
    (hs : MeasurableSet s) (ht : MeasurableSet t) : MeasurableSet (s âˆ© t) := by
  simpa using hs.inter ht
end MeasureMini
```

#### è¿½åŠ ï¼šèŒƒç•´æé™/ä½™æé™ ä¸ æµ‹åº¦-ç§¯åˆ†ï¼ˆæ–°å¢8ä¸ªï¼‰

```lean
-- èŒƒç•´ï¼šæé™/ä½™æé™ï¼ˆ4ï¼‰
section LimitsMini
import Mathlib/CategoryTheory/Limits/Shapes/Products
import Mathlib/CategoryTheory/Limits/Shapes/Terminal
open CategoryTheory
open CategoryTheory.Limits

-- 73. ç»ˆå¯¹è±¡å”¯ä¸€åˆ°åŒæ„
example {C : Type} [Category C] (Tâ‚ Tâ‚‚ : C) [IsTerminal Tâ‚] [IsTerminal Tâ‚‚] :
    Nonempty (Tâ‚ â‰… Tâ‚‚) := by infer_instance

-- 74. å§‹å¯¹è±¡å”¯ä¸€åˆ°åŒæ„
example {C : Type} [Category C] (Iâ‚ Iâ‚‚ : C) [IsInitial Iâ‚] [IsInitial Iâ‚‚] :
    Nonempty (Iâ‚ â‰… Iâ‚‚) := by infer_instance

-- 75. äºŒå…ƒç§¯å­˜åœ¨æ—¶å…¶æŠ•å½±æ˜¯æé™é”¥çš„è„šï¼ˆAPIä½¿ç”¨ï¼‰
example {C : Type} [Category C] [HasBinaryProducts C] (X Y : C) :
    (prod.fst : X â¨¯ Y âŸ¶ X) â‰« ğŸ™ X = prod.fst := by simp

-- 76. äºŒå…ƒä½™ç§¯æ³¨å…¥æ»¡è¶³ä¸‰è§’ç­‰å¼ï¼ˆAPIä½¿ç”¨ï¼‰
example {C : Type} [Category C] [HasBinaryCoproducts C] (X Y : C) :
    (Sigma.Î¹ X Y) â‰« coprod.desc (ğŸ™ X) 0 = ğŸ™ X := by
  simp
end LimitsMini

-- æµ‹åº¦ä¸ç§¯åˆ†ï¼ˆ4ï¼‰
section IntegralMini
import Mathlib/MeasureTheory/Integral/Bochner
open MeasureTheory

-- 77. å¸¸å€¼å‡½æ•°å¯ç§¯ï¼ˆæœ‰é™æµ‹åº¦å‰æï¼‰
example {Î± : Type} [MeasurableSpace Î±] (Î¼ : Measure Î±) [IsFiniteMeasure Î¼] :
    Integrable (fun _ : Î± => (1 : â„)) Î¼ := by
  simpa using integrable_const (c := (1 : â„))

-- 78. å¯ç§¯å‡½æ•°ä¹‹å’Œä»å¯ç§¯
example {Î± : Type} [MeasurableSpace Î±] (Î¼ : Measure Î±)
    {f g : Î± â†’ â„} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :
    Integrable (fun x => f x + g x) Î¼ := by
  simpa using hf.add hg

-- 79. å¸¸å€¼å‡½æ•°ç§¯åˆ†ï¼ˆéœ€è¦æœ‰é™æµ‹åº¦ï¼‰
example {Î± : Type} [MeasurableSpace Î±] (Î¼ : Measure Î±) [IsFiniteMeasure Î¼] :
    âˆ« x, (2 : â„) âˆ‚Î¼ = 2 * Î¼ Set.univ := by
  simpa using integral_const (c := (2 : â„))

-- 80. çº¿æ€§æ€§ï¼šç§¯åˆ†ä¸åŠ æ³•
example {Î± : Type} [MeasurableSpace Î±] (Î¼ : Measure Î±)
    {f g : Î± â†’ â„} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :
    âˆ« x, (f x + g x) âˆ‚Î¼ = (âˆ« x, f x âˆ‚Î¼) + (âˆ« x, g x âˆ‚Î¼) := by
  simpa using integral_add hf hg
end IntegralMini
```

#### è¿½åŠ ï¼šæ‹“æ‰‘/æ»¤å­ã€èŒƒç•´è¡¥å……ã€æµ‹åº¦å¯æµ‹æ€§ï¼ˆæ–°å¢8ä¸ªï¼‰

```lean
-- æ‹“æ‰‘ä¸æ»¤å­ï¼ˆ3ï¼‰
section TopoFilterMini
import Mathlib/Topology/Algebra/Group
open Filter

-- 81. principal æ»¤å­å•è°ƒæ€§
example {Î± : Type} (s t : Set Î±) (h : s âŠ† t) : principal s â‰¤ principal t := by
  simpa [Filter.le_def, principal_def] using principal_mono.mpr h

-- 82. Tendsto çš„æ’ç­‰æ˜ å°„æ€§è´¨
example {Î± : Type} [TopologicalSpace Î±] : Tendsto (fun x : Î± => x) (ğ“Ÿ Set.univ) (ğ“Ÿ Set.univ) := by
  simpa using tendsto_id'

-- 83. è¿ç»­å‡½æ•°åœ¨å¤åˆä¸‹é—­åˆ
example {Î± Î² Î³ : Type} [TopologicalSpace Î±] [TopologicalSpace Î²] [TopologicalSpace Î³]
    {f : Î± â†’ Î²} {g : Î² â†’ Î³} (hf : Continuous f) (hg : Continuous g) : Continuous (fun x => g (f x)) := by
  simpa using hg.comp hf
end TopoFilterMini

-- èŒƒç•´è¡¥å……ï¼ˆ2ï¼‰
section CategoryExtra
import Mathlib/CategoryTheory/Functor/Category
open CategoryTheory

-- 84. æ’ç­‰å‡½å­ä¿æ’ç­‰ä¸åˆæˆ
example {C : Type} [Category C] : (Functor.id C).map (ğŸ™ (ğŸ™_ C)) = ğŸ™ (ğŸ™_ C) := rfl

-- 85. è‡ªç„¶å˜æ¢çš„åˆ†é‡åœ¨å¯¹è±¡ä¸Šç»™å‡ºæ€å°„
example {C D : Type} [Category C] [Category D] (F G : C â¥¤ D) (Î· : F âŸ¶ G) (X : C) :
    F.obj X âŸ¶ G.obj X := Î·.app X
end CategoryExtra

-- æµ‹åº¦å¯æµ‹æ€§ï¼ˆ3ï¼‰
section MeasureExtra
import Mathlib/MeasureTheory/Measure/MeasureSpace
open MeasureTheory

-- 86. å¯æµ‹å‡½æ•°å’Œï¼ˆBool æŒ‡ç¤ºå‡½æ•°ä¾‹ï¼‰
example {Î± : Type} [MeasurableSpace Î±] :
    Measurable fun x : Î± => (if True then (0 : â„•) else 1) := by
  measurability

-- 87. å¯æµ‹é›†çš„è¡¥ä¸å¹¶ä»å¯æµ‹
example {Î± : Type} [MeasurableSpace Î±] {s t : Set Î±}
    (hs : MeasurableSet s) (ht : MeasurableSet t) :
    MeasurableSet (sá¶œ âˆª t) := by
  simpa using (hs.compl.union ht)

-- 88. å‡ ä¹å¤„å¤„ç›¸ç­‰æ˜¯ç­‰ä»·å…³ç³»ï¼ˆä½¿ç”¨å·²æœ‰å®ä¾‹ï¼‰
example {Î± : Type} [MeasurableSpace Î±] (Î¼ : Measure Î±) : Equivalence (Measure.aeEq Î¼) := by
  infer_instance
end MeasureExtra
```

## 3. æ•°æ®ç»“æ„ç¤ºä¾‹ | Data Structure Examples

### åˆ—è¡¨æ“ä½œç¤ºä¾‹ | List Operation Examples

```lean
-- åˆ—è¡¨åŸºæœ¬æ“ä½œ
def list_operations : List â„• :=
  let xs := [1, 2, 3, 4, 5]
  let ys := xs.map (Â· * 2)
  let zs := ys.filter (Â· > 5)
  zs

-- åˆ—è¡¨æŠ˜å 
def list_sum (xs : List â„•) : â„• :=
  xs.foldl (Â· + Â·) 0

-- åˆ—è¡¨æ˜ å°„
def list_map {Î± Î² : Type} (f : Î± â†’ Î²) : List Î± â†’ List Î²
  | [] => []
  | x :: xs => f x :: list_map f xs

-- åˆ—è¡¨è¿‡æ»¤
def list_filter {Î± : Type} (p : Î± â†’ Bool) : List Î± â†’ List Î±
  | [] => []
  | x :: xs => if p x then x :: list_filter p xs else list_filter p xs
```

### æ ‘æ“ä½œç¤ºä¾‹ | Tree Operation Examples

```lean
-- æ ‘çš„å¤§å°
def Tree.size {Î± : Type} : Tree Î± â†’ â„•
  | Tree.leaf _ => 1
  | Tree.node l r => Tree.size l + Tree.size r

-- æ ‘çš„æ·±åº¦
def Tree.depth {Î± : Type} : Tree Î± â†’ â„•
  | Tree.leaf _ => 0
  | Tree.node l r => 1 + max (Tree.depth l) (Tree.depth r)

-- æ ‘æ˜ å°„
def Tree.map {Î± Î² : Type} (f : Î± â†’ Î²) : Tree Î± â†’ Tree Î²
  | Tree.leaf x => Tree.leaf (f x)
  | Tree.node l r => Tree.node (Tree.map f l) (Tree.map f r)

-- æ ‘æŠ˜å 
def Tree.fold {Î± Î² : Type} (f : Î² â†’ Î± â†’ Î² â†’ Î²) (init : Î²) : Tree Î± â†’ Î²
  | Tree.leaf x => f init x init
  | Tree.node l r => f (Tree.fold f init l) (Tree.fold f init r)
```

## 4. ç®—æ³•ç¤ºä¾‹ | Algorithm Examples

### æ’åºç®—æ³•ç¤ºä¾‹ | Sorting Algorithm Examples

```lean
-- æ’å…¥æ’åº
def insertion_sort {Î± : Type} [LE Î±] [DecidableRel (Â· â‰¤ Â·)] : List Î± â†’ List Î±
  | [] => []
  | x :: xs => insert x (insertion_sort xs)
where
  insert (x : Î±) : List Î± â†’ List Î±
    | [] => [x]
    | y :: ys => if x â‰¤ y then x :: y :: ys else y :: insert x ys

-- å½’å¹¶æ’åº
def merge_sort {Î± : Type} [LE Î±] [DecidableRel (Â· â‰¤ Â·)] : List Î± â†’ List Î±
  | [] => []
  | [x] => [x]
  | xs => 
    let mid := xs.length / 2
    let (left, right) := xs.splitAt mid
    merge (merge_sort left) (merge_sort right)
where
  merge : List Î± â†’ List Î± â†’ List Î±
    | [], ys => ys
    | xs, [] => xs
    | x :: xs, y :: ys => 
      if x â‰¤ y then x :: merge xs (y :: ys)
      else y :: merge (x :: xs) ys

-- å¿«é€Ÿæ’åº
def quicksort {Î± : Type} [LE Î±] [DecidableRel (Â· â‰¤ Â·)] : List Î± â†’ List Î±
  | [] => []
  | x :: xs => 
    let smaller := xs.filter (Â· â‰¤ x)
    let larger := xs.filter (Â· > x)
    quicksort smaller ++ [x] ++ quicksort larger
```

### æœç´¢ç®—æ³•ç¤ºä¾‹ | Search Algorithm Examples

```lean
-- çº¿æ€§æœç´¢
def linear_search {Î± : Type} [BEq Î±] (x : Î±) : List Î± â†’ Option (Fin (List.length xs))
  | [] => none
  | y :: ys => if x == y then some 0 else 
    match linear_search x ys with
    | none => none
    | some i => some (i + 1)

-- äºŒåˆ†æœç´¢
def binary_search {Î± : Type} [LE Î±] [DecidableRel (Â· â‰¤ Â·)] (x : Î±) (xs : List Î±) (h : IsSorted xs) : Option (Fin xs.length) :=
  let rec search (low high : â„•) : Option (Fin xs.length) :=
    if low > high then none
    else
      let mid := (low + high) / 2
      let mid_val := xs.get âŸ¨mid, sorryâŸ©
      if x = mid_val then some âŸ¨mid, sorryâŸ©
      else if x < mid_val then search low (mid - 1)
      else search (mid + 1) high
  search 0 (xs.length - 1)
```

## 5. æ•°å­¦ç¤ºä¾‹ | Mathematical Examples

### æ•°è®ºç¤ºä¾‹ | Number Theory Examples

```lean
-- æœ€å¤§å…¬çº¦æ•°
def gcd (a b : â„•) : â„• :=
  if a = 0 then b
  else if b = 0 then a
  else if a > b then gcd (a - b) b
  else gcd a (b - a)

-- ç´ æ•°åˆ¤æ–­
def is_prime (n : â„•) : Bool :=
  if n < 2 then false
  else (List.range n).drop 2 |>.all (Â· âˆ£ n)

-- æ–æ³¢é‚£å¥‘æ•°åˆ—
def fibonacci : â„• â†’ â„•
  | 0 => 0
  | 1 => 1
  | n + 2 => fibonacci n + fibonacci (n + 1)

-- é˜¶ä¹˜
def factorial : â„• â†’ â„•
  | 0 => 1
  | n + 1 => (n + 1) * factorial n
```

### ä»£æ•°ç¤ºä¾‹ | Algebra Examples

```lean
-- ç¾¤çš„å®šä¹‰
class Group (G : Type) extends Mul G, One G, Inv G where
  mul_assoc : âˆ€ a b c : G, (a * b) * c = a * (b * c)
  one_mul : âˆ€ a : G, 1 * a = a
  mul_one : âˆ€ a : G, a * 1 = a
  mul_left_inv : âˆ€ a : G, aâ»Â¹ * a = 1

-- ç¯çš„å®šä¹‰
class Ring (R : Type) extends Add R, Mul R, Neg R, Zero R, One R where
  add_assoc : âˆ€ a b c : R, (a + b) + c = a + (b + c)
  add_comm : âˆ€ a b : R, a + b = b + a
  add_zero : âˆ€ a : R, a + 0 = a
  add_left_neg : âˆ€ a : R, -a + a = 0
  mul_assoc : âˆ€ a b c : R, (a * b) * c = a * (b * c)
  mul_one : âˆ€ a : R, a * 1 = a
  one_mul : âˆ€ a : R, 1 * a = a
  left_distrib : âˆ€ a b c : R, a * (b + c) = a * b + a * c
  right_distrib : âˆ€ a b c : R, (a + b) * c = a * c + b * c
```

## 6. å½¢å¼åŒ–éªŒè¯ç¤ºä¾‹ | Formal Verification Examples

### ç¨‹åºéªŒè¯ç¤ºä¾‹ | Program Verification Examples

```lean
-- æ’åºç®—æ³•æ­£ç¡®æ€§
theorem insertion_sort_correct {Î± : Type} [LE Î±] [DecidableRel (Â· â‰¤ Â·)] (xs : List Î±) :
  IsSorted (insertion_sort xs) âˆ§ IsPermutation xs (insertion_sort xs) := by
  sorry -- éœ€è¦å®Œæ•´è¯æ˜

-- æœç´¢ç®—æ³•æ­£ç¡®æ€§
theorem binary_search_correct {Î± : Type} [LE Î±] [DecidableRel (Â· â‰¤ Â·)] (x : Î±) (xs : List Î±) (h : IsSorted xs) :
  match binary_search x xs h with
  | some i => xs.get i = x
  | none => x âˆ‰ xs := by
  sorry -- éœ€è¦å®Œæ•´è¯æ˜

-- å¾ªç¯ä¸å˜é‡
theorem loop_invariant (n : â„•) : n â‰¥ 0 â†’ factorial n â‰¥ 1 := by
  intro hn
  induction n with
  | zero => simp [factorial]
  | succ n ih => 
    simp [factorial]
    exact Nat.mul_pos (Nat.succ_pos n) ih
```

### ç³»ç»ŸéªŒè¯ç¤ºä¾‹ | System Verification Examples

```lean
-- çŠ¶æ€æœºéªŒè¯
inductive State where
  | initial : State
  | running : State
  | finished : State

def transition : State â†’ State
  | State.initial => State.running
  | State.running => State.finished
  | State.finished => State.finished

theorem state_machine_property (s : State) : 
  s = State.initial â†’ âˆƒ n : â„•, (transition^[n]) s = State.finished := by
  intro hs
  exists 2
  simp [hs, transition]

-- å¹¶å‘ç³»ç»ŸéªŒè¯
theorem concurrent_system_safety (s : ConcurrentState) : 
  SafeState s â†’ NextState s â†’ SafeState (NextState s) := by
  sorry -- éœ€è¦å®Œæ•´è¯æ˜
```

## 7. é«˜çº§ç±»å‹ç¤ºä¾‹ | Advanced Type Examples

### ä¾èµ–ç±»å‹ç¤ºä¾‹ | Dependent Type Examples

```lean
-- é•¿åº¦ç´¢å¼•åˆ—è¡¨
def Vector (Î± : Type) : â„• â†’ Type :=
  fun n => { xs : List Î± // xs.length = n }

-- å®‰å…¨æ•°ç»„è®¿é—®
def safe_array_access {Î± : Type} (arr : Array Î±) (i : Fin arr.size) : Î± :=
  arr.get i

-- å½¢å¼åŒ–è§„èŒƒ
def IsSorted {Î± : Type} [LE Î±] (xs : List Î±) : Prop :=
  âˆ€ i j : Fin xs.length, i.val < j.val â†’ xs.get i â‰¤ xs.get j

-- è¯æ˜ç›¸å…³ç¼–ç¨‹
def proof_relevant_function (n : â„•) : n + 0 = n :=
  Nat.add_zero n
```

### ç±»å‹ç±»ç¤ºä¾‹ | Type Class Examples

```lean
-- å¯æ¯”è¾ƒç±»å‹ç±»
class Comparable (Î± : Type) where
  compare : Î± â†’ Î± â†’ Ordering
  compare_refl : âˆ€ a : Î±, compare a a = Ordering.eq
  compare_symm : âˆ€ a b : Î±, compare a b = Ordering.gt â†” compare b a = Ordering.lt

-- å®ä¾‹å®šä¹‰
instance : Comparable â„• where
  compare a b :=
    if a < b then Ordering.lt
    else if a = b then Ordering.eq
    else Ordering.gt
  compare_refl a := by simp [compare]
  compare_symm a b := by simp [compare]; cases Nat.lt_trichotomy a b <;> simp

-- ä½¿ç”¨ç±»å‹ç±»
def sort_with_comparable {Î± : Type} [Comparable Î±] (xs : List Î±) : List Î± :=
  xs.sort (fun a b => Comparable.compare a b)
```

## 8. å®é™…åº”ç”¨ç¤ºä¾‹ | Practical Application Examples

### æ•°æ®å¤„ç†ç¤ºä¾‹ | Data Processing Examples

```lean
-- æ•°æ®è½¬æ¢ç®¡é“
def data_pipeline (data : List String) : List â„• :=
  data
  |>.filter (Â·.length > 0)
  |>.map String.toNat
  |>.filter (Â·.isSome)
  |>.map (Â·.get)

-- ç»Ÿè®¡åˆ†æ
def statistics (xs : List â„•) : â„• Ã— â„• Ã— â„• :=
  let sum := xs.sum
  let count := xs.length
  let average := if count = 0 then 0 else sum / count
  (sum, count, average)

-- æ•°æ®éªŒè¯
def validate_data (xs : List â„•) : Bool :=
  xs.all (Â· â‰¥ 0) && xs.length > 0
```

### é…ç½®ç®¡ç†ç¤ºä¾‹ | Configuration Management Examples

```lean
-- é…ç½®ç»“æ„
structure Config where
  host : String
  port : â„•
  timeout : â„•
  debug : Bool

-- é»˜è®¤é…ç½®
def default_config : Config :=
  { host := "localhost", port := 8080, timeout := 30, debug := false }

-- é…ç½®éªŒè¯
def validate_config (config : Config) : Bool :=
  config.port > 0 && config.port < 65536 && config.timeout > 0

-- é…ç½®æ›´æ–°
def update_config (config : Config) (updates : List (String Ã— String)) : Config :=
  updates.foldl (fun cfg (key, value) =>
    match key with
    | "host" => { cfg with host := value }
    | "port" => { cfg with port := value.toNat }
    | "timeout" => { cfg with timeout := value.toNat }
    | "debug" => { cfg with debug := value.toBool }
    | _ => cfg
  ) config
```

---

*ç›¸å…³é“¾æ¥ï¼š*

- [å¿«é€Ÿå‚è€ƒæ‰‹å†Œ](./04-å¿«é€Ÿå‚è€ƒæ‰‹å†Œ.md)
- [å­¦ä¹ è·¯å¾„æŒ‡å—](./01-å­¦ä¹ è·¯å¾„æŒ‡å—.md)
- [åŸºç¡€è¯­æ³•ä¸ç±»å‹ç³»ç»Ÿ](../02-åŸºç¡€è¯­æ³•ä¸ç±»å‹ç³»ç»Ÿ/01-åŸºç¡€è¯­æ³•å…ƒç´ .md)
- [è¯æ˜ç³»ç»Ÿä¸ç­–ç•¥](../03-è¯æ˜ç³»ç»Ÿä¸ç­–ç•¥/01-äº¤äº’å¼è¯æ˜ç¯å¢ƒ.md)
