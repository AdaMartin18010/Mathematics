# 示例库 | Examples Library

## 1. 基础语法示例 | Basic Syntax Examples

### 函数定义示例 | Function Definition Examples

```lean
-- 简单函数
def add (x y : ℕ) : ℕ := x + y

-- 递归函数
def factorial : ℕ → ℕ
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

-- 带模式匹配的函数
def is_even : ℕ → Bool
  | 0 => true
  | 1 => false
  | n + 2 => is_even n

-- 高阶函数
def apply_twice {α : Type} (f : α → α) (x : α) : α := f (f x)

-- 多参数函数
def power (base : ℕ) (exp : ℕ) : ℕ :=
  match exp with
  | 0 => 1
  | n + 1 => base * power base n
```

### 类型定义示例 | Type Definition Examples

```lean
-- 简单归纳类型
inductive Color where
  | red : Color
  | green : Color
  | blue : Color

-- 参数化类型
inductive Option (α : Type) where
  | none : Option α
  | some (val : α) : Option α

-- 递归类型
inductive Tree (α : Type) where
  | leaf (value : α) : Tree α
  | node (left right : Tree α) : Tree α

-- 依赖类型
inductive Vector (α : Type) : ℕ → Type where
  | nil : Vector α 0
  | cons (head : α) (tail : Vector α n) : Vector α (n + 1)
```

## 2. 证明示例 | Proof Examples

### 基本证明示例 | Basic Proof Examples

```lean
-- 等式证明
theorem add_zero (n : ℕ) : n + 0 = n := by
  exact Nat.add_zero n

-- 条件证明
theorem conditional (p q : Prop) : p → q → p ∧ q := by
  intro hp hq
  exact ⟨hp, hq⟩

-- 分情况证明
theorem cases_example (n : ℕ) : n = 0 ∨ n > 0 := by
  cases n with
  | zero => left; rfl
  | succ n => right; exact Nat.succ_pos n

-- 归纳证明
theorem induction_example (n : ℕ) : n + 0 = n := by
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.add_succ, ih]
```

### 最小可运行证明集 | Minimal Runnable Proof Set

```lean
-- 1. 自反性与 rw
example (x : Nat) : x = x := by rfl

-- 2. 使用假设重写
example (x y : Nat) (h : x = y) : x + 1 = y + 1 := by
  rw [h]

-- 3. 反向重写
example (x y : Nat) (h : x = y) : y + 1 = x + 1 := by
  rw [← h]

-- 4. simp 使用（加法单位元）
example (n : Nat) : n + 0 = n := by
  simp

-- 5. cases 分解布尔等式
example (b : Bool) : b = true ∨ b = false := by
  cases b <;> simp

-- 6. 自然数归纳
example (n : Nat) : n + 0 = n := by
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.add_succ, ih]

-- 7. 存在性构造
example : ∃ n : Nat, n > 0 := by
  refine ⟨1, ?_⟩
  decide

-- 8. conjunction 构造
example (p q : Prop) (hp : p) (hq : q) : p ∧ q := by
  exact ⟨hp, hq⟩

-- 9. disjunction 构造
example (p q : Prop) (hp : p) : p ∨ q := by
  exact Or.inl hp

-- 10. implication 链
example (p q r : Prop) : (p → q) → (q → r) → (p → r) := by
  intro hpq hqr hp
  exact hqr (hpq hp)

-- 11. 类型检查辅助
example : (fun x : Nat => x + 1) 2 = 3 := by
  rfl

-- 12. 简单等式链（calc）
example (a b : Nat) (h : a = b) : a + 2 = b + 2 := by
  calc
    a + 2 = b + 2 := by simpa [h]
```

#### 结构/类型类/归纳相关最小例

```lean
-- 13. structure 定义与字段访问
structure Point where
  x : Nat
  y : Nat

example : Point := { x := 1, y := 2 }
example (p : Point) : p.x + p.y = p.y + p.x := by
  simp [Nat.add_comm]

-- 14. inductive 定义与 cases
inductive Sign where
  | pos | neg

example (s : Sign) : s = Sign.pos ∨ s = Sign.neg := by
  cases s <;> simp

-- 15. class/instance 与使用
class HasDouble (α : Type) where
  double : α → α

instance : HasDouble Nat where
  double x := x * 2

example : HasDouble Nat := inferInstance
example (n : Nat) : HasDouble.double n = n * 2 := by rfl

-- 16. 简单定理使用：commutativity
example (a b : Nat) : a + b = b + a := by simpa [Nat.add_comm]

-- 17. calc 等式链更复杂一步
example (a : Nat) : a + 1 + 1 = a + 2 := by
  calc
    a + 1 + 1 = a + (1 + 1) := by simp [Nat.add_assoc]
    _ = a + 2 := by rfl

-- 18. 模型化线性映射（以函数代替）
def linearLike (k : Nat) : Nat → Nat := fun x => k * x
example : linearLike 2 3 = 6 := by rfl

-- 19. Option 案例分析
example (o : Option Nat) : o = none ∨ ∃ n, o = some n := by
  cases o with
  | none => exact Or.inl rfl
  | some n => exact Or.inr ⟨n, rfl⟩

-- 20. List 基本性质（长度）
example (xs : List Nat) : (xs ++ []) = xs := by
  simp
```

> 相关：更多基础术语与模块路径见《[术语表与索引](./10-术语表与索引.md)》。

#### 追加：代数/列表等最小可运行证明（补充6个）

```lean
-- 21. 自然数加法结合律（使用 simp）
example (a b c : Nat) : (a + b) + c = a + (b + c) := by
  simpa [Nat.add_assoc]

-- 22. 自然数乘法交换律
example (a b : Nat) : a * b = b * a := by
  simpa [Nat.mul_comm]

-- 23. 分配律示例
example (a b c : Nat) : a * (b + c) = a * b + a * c := by
  simpa [Nat.mul_add]

-- 24. 列表连接与长度
example (xs ys : List Nat) : (xs ++ ys).length = xs.length + ys.length := by
  simp

-- 25. 列表 map 身份函数不变
example (xs : List Nat) : xs.map (fun x => x) = xs := by
  simpa

-- 26. 列表 filter 恒真等于自身
example (xs : List Nat) : xs.filter (fun _ => True) = xs := by
  simpa
```

#### 追加：代数与拓扑最小可运行证明（各3个）

```lean
-- 27. 代数：自然数加法的左单位元
example (a : Nat) : 0 + a = a := by
  simpa [Nat.zero_add]

-- 28. 代数：自然数乘法的右单位元
example (a : Nat) : a * 1 = a := by
  simpa [Nat.mul_one]

-- 29. 代数：乘法对 0 的吸收
example (a : Nat) : a * 0 = 0 := by
  simpa [Nat.mul_zero]

-- 30. 拓扑：交集包含（需要 mathlib）
import Mathlib.Topology.Basic
open Set

example (α : Type) [TopologicalSpace α] (s t : Set α) : s ∩ t ⊆ s := by
  intro x hx
  exact And.left hx

-- 31. 恒等映射连续（需要 mathlib）
example (α : Type) [TopologicalSpace α] : Continuous (fun x : α => x) := by
  simpa using continuous_id

-- 32. 闭集与开集的互补互推（需要 mathlib）
example (α : Type) [TopologicalSpace α] (s : Set α) : IsClosed s ↔ IsOpen sᶜ := by
  simpa using isClosed_compl_iff
```

### 高级证明示例 | Advanced Proof Examples

```lean
-- 存在性证明
theorem exists_example : ∃ n : ℕ, n > 0 := by
  exists 1
  exact Nat.one_pos

-- 唯一性证明
theorem unique_example (a : ℕ) : ∃! b : ℕ, a + b = a + 1 := by
  constructor
  · exists 1
    constructor
    · rfl
    · intro b hb
      linarith
  · intro b1 b2 h1 h2
    linarith

-- 反证法
theorem contradiction_example (p : Prop) : p → ¬p → False := by
  intro hp hnp
  exact hnp hp
```

#### 追加：群/环/域与 tactic 链条（新增12个）

```lean
-- 33. 群：左逆消去
section GroupExamples
variable {G : Type} [Group G]
example (a b : G) : a⁻¹ * (a * b) = b := by
  simpa [mul_assoc, inv_mul_cancel_left] using inv_mul_cancel_left a b

-- 34. 群：共轭的乘法分配
example (a b c : G) : a * (b * a⁻¹) * (a * c * a⁻¹) = a * (b * c) * a⁻¹ := by
  group

-- 35. 交换群：加法交换律直接化简
example (x y z : AddCommGroup) : (x + y) + z = x + (y + z) := by
  simpa [add_assoc]
end GroupExamples

-- 36. 环：分配律与零元
section RingExamples
variable {R : Type} [Semiring R]
example (a b : R) : a * (b + 0) = a * b := by
  simpa using by
    simpa [add_comm] using (by simp : a * (0 + b) = a * b)

-- 37. 环：乘法对和的分配
example (a b c : R) : (a + b) * c = a * c + b * c := by
  simpa [left_distrib]
end RingExamples

-- 38. 域：非零有倒数
section FieldExamples
variable {K : Type} [Field K] {a : K}
example (h : a ≠ 0) : a * a⁻¹ = 1 := by
  simpa using mul_inv_cancel h
end FieldExamples

-- 39. tactic 链：intro → apply → rw
example (p q r : Prop) (hpq : p → q) (hqr : q → r) : p → r := by
  intro hp
  apply hqr
  apply hpq
  exact hp

-- 40. tactic 链：cases → simp
example (o : Option Nat) : o = none ∨ ∃ n, o = some n := by
  cases o with
  | none => exact Or.inl rfl
  | some n => exact Or.inr ⟨n, rfl⟩

-- 41. tactic 链：induction → simp
example (xs : List Nat) : xs ++ [] = xs := by
  induction xs with
  | nil => simp
  | cons x xs ih => simp [ih]

-- 42. calc 链：等式传递
example (a b : Nat) (h : a = b) : a + 3 = b + 3 := by
  calc
    a + 3 = b + 3 := by simpa [h]

-- 43. rw 定位：在假设处重写
example (a b c : Nat) (h : a = b) (hc : a + c = c + a) : b + c = c + b := by
  have hc' := hc
  rw [h] at hc'
  simpa [Nat.add_comm] using hc'

-- 44. simp 仅规则：only 限定规则集
example (a b c : Nat) : (a + b) + c = a + (b + c) := by
  simp [Nat.add_assoc]

-- 45. aesop 简化（如可用）
-- example (p q r : Prop) : (p ∧ q) → q := by
--   aesop
```

#### 追加：核心主题最小可运行证明（新增15个，P0）

```lean
-- A. 代数（群/环/域）各2
section CoreAlgebra
variable {G : Type} [Group G]
variable {R : Type} [Semiring R]
variable {K : Type} [Field K]

-- 46. 群：右消去
example (a b : G) : (a * b) * b⁻¹ = a := by
  simpa [mul_assoc] using mul_mul_inv a b

-- 47. 群：单位元唯一
example (e₁ e₂ : G) (h1 : ∀ a, e₁ * a = a) (h2 : ∀ a, e₂ * a = a) : e₁ = e₂ := by
  have := h1 e₂
  simpa using this.trans (h2 e₁).symm

-- 48. 环：零乘吸收
example (a : R) : 0 * a = 0 := by simpa [zero_mul]

-- 49. 环：加法消去
example (a b c : R) : a + b = a + c → b = c := by
  intro h; simpa using add_left_cancel h

-- 50. 域：分式正规化（非零）
example (x : K) (hx : x ≠ 0) : x / x = 1 := by simpa [div_eq_mul_inv] using mul_inv_cancel hx

-- 51. 域：倒数唯一
example (x : K) (hx : x ≠ 0) {y z : K} (hy : x * y = 1) (hz : x * z = 1) : y = z := by
  have : y = y * 1 := by simp
  simpa [hy, hz, mul_assoc] using congrArg (fun t => y * t) (by simpa using hz)
end CoreAlgebra

-- B. 策略链条（intro/apply/rw/induction）各2
section CoreTactics
-- 52. intro → apply
example (p q r : Prop) (hpq : p → q) (hqr : q → r) : p → r := by
  intro hp; apply hqr; exact hpq hp

-- 53. rw 链（多步）
example (a b c : Nat) (h₁ : a = b) (h₂ : b = c) : a + 1 = c + 1 := by
  rw [h₁, h₂]

-- 54. 简单归纳（List）
example (xs : List Nat) : xs ++ [] = xs := by
  induction xs with
  | nil => simp
  | cons x xs ih => simp [ih]

-- 55. Nat 归纳与 simp
example (n : Nat) : n + 0 = n := by
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.add_succ, ih]
end CoreTactics

-- C. 类型系统（structure/inductive/class/instance）各1
section CoreTypes
-- 56. structure 与字段
structure Pair where
  fst : Nat
  snd : Nat

example (p : Pair) : p.fst + p.snd = p.snd + p.fst := by
  simp [Nat.add_comm]

-- 57. inductive 与 cases
inductive Bit where | zero | one
example (b : Bit) : b = Bit.zero ∨ b = Bit.one := by cases b <;> simp

-- 58. class/instance 基本使用
class HasTriple (α : Type) where triple : α → α
instance : HasTriple Nat where triple x := 3 * x
example (n : Nat) : HasTriple.triple n = 3 * n := rfl
end CoreTypes

-- D. 集合与拓扑/分析各1
section CoreMathlib
import Mathlib.Topology.Basic
import Mathlib/Analysis/Calculus/Deriv
open Set

-- 59. 拓扑：交集包含
example (α : Type) [TopologicalSpace α] (s t : Set α) : s ∩ t ⊆ s := by
  intro x hx; exact And.left hx

-- 60. 分析：常值函数导数为 0
example : deriv (fun x : ℝ => (5 : ℝ)) = 0 := by
  simpa using deriv_const (c := (5 : ℝ))
end CoreMathlib
```

#### 追加：分析/范畴/测度 最小可运行证明（新增12个）

```lean
-- 分析（4）
section AnalysisMini
import Mathlib/Analysis/Calculus/Deriv
open Real

-- 61. 常值函数导数为 0（再次以变体展示）
example : deriv (fun x : ℝ => (7 : ℝ)) = 0 := by simpa using deriv_const (c := (7 : ℝ))

-- 62. x ↦ x 的导数为 1
example : deriv (fun x : ℝ => x) = 1 := by simpa using deriv_id (𝕜 := ℝ)

-- 63. 线性函数 ax 的导数为常数 a
example (a : ℝ) : deriv (fun x : ℝ => a * x) = fun _ => a := by
  simpa using deriv_const_mul (c := a) (f := fun x : ℝ => x)

-- 64. 和的导数为导数之和
example (f g : ℝ → ℝ) (hf : Differentiable ℝ f) (hg : Differentiable ℝ g) :
    deriv (fun x => f x + g x) = fun x => deriv f x + deriv g x := by
  simpa using (deriv_add hf.differentiableAt hg.differentiableAt)
end AnalysisMini

-- 范畴（4）
section CategoryMini
import Mathlib/CategoryTheory/Category/Basic
open CategoryTheory

-- 65. 任一范畴同构的左右逆互为逆
example {C : Type} [Category C] {X Y : C} (e : X ≅ Y) : e.hom ≫ e.inv = 𝟙 X := by
  simpa using e.hom_inv_id

-- 66. 恒等同构的同构性
example {C : Type} [Category C] (X : C) : (Iso.refl X).hom = 𝟙 X := rfl

-- 67. 同构的合成仍为同构
example {C : Type} [Category C] {X Y Z : C} (e₁ : X ≅ Y) (e₂ : Y ≅ Z) : X ≅ Z :=
  e₁.trans e₂

-- 68. 自反同构等于恒等同构（命题层面）
example {C : Type} [Category C] (X : C) : (Iso.refl X).inv = 𝟙 X := rfl
end CategoryMini

-- 测度（4）
section MeasureMini
import Mathlib/MeasureTheory/Measure/MeasureSpace
open MeasureTheory

-- 69. 可测空间上空集可测
example {α : Type} [MeasurableSpace α] : MeasurableSet (∅ : Set α) := by
  simpa using (measurableSet_empty : MeasurableSet (∅ : Set α))

-- 70. 单点集可测（可数集可测）
example {α : Type} [MeasurableSpace α] [MeasurableSingleton α] (x : α) :
    MeasurableSet ({x} : Set α) := by
  simpa using (measurableSet_singleton x)

-- 71. 可测性的并闭包
example {α : Type} [MeasurableSpace α] {s t : Set α}
    (hs : MeasurableSet s) (ht : MeasurableSet t) : MeasurableSet (s ∪ t) := by
  simpa using hs.union ht

-- 72. 可测性的交闭包
example {α : Type} [MeasurableSpace α] {s t : Set α}
    (hs : MeasurableSet s) (ht : MeasurableSet t) : MeasurableSet (s ∩ t) := by
  simpa using hs.inter ht
end MeasureMini
```

#### 追加：范畴极限/余极限 与 测度-积分（新增8个）

```lean
-- 范畴：极限/余极限（4）
section LimitsMini
import Mathlib/CategoryTheory/Limits/Shapes/Products
import Mathlib/CategoryTheory/Limits/Shapes/Terminal
open CategoryTheory
open CategoryTheory.Limits

-- 73. 终对象唯一到同构
example {C : Type} [Category C] (T₁ T₂ : C) [IsTerminal T₁] [IsTerminal T₂] :
    Nonempty (T₁ ≅ T₂) := by infer_instance

-- 74. 始对象唯一到同构
example {C : Type} [Category C] (I₁ I₂ : C) [IsInitial I₁] [IsInitial I₂] :
    Nonempty (I₁ ≅ I₂) := by infer_instance

-- 75. 二元积存在时其投影是极限锥的脚（API使用）
example {C : Type} [Category C] [HasBinaryProducts C] (X Y : C) :
    (prod.fst : X ⨯ Y ⟶ X) ≫ 𝟙 X = prod.fst := by simp

-- 76. 二元余积注入满足三角等式（API使用）
example {C : Type} [Category C] [HasBinaryCoproducts C] (X Y : C) :
    (Sigma.ι X Y) ≫ coprod.desc (𝟙 X) 0 = 𝟙 X := by
  simp
end LimitsMini

-- 测度与积分（4）
section IntegralMini
import Mathlib/MeasureTheory/Integral/Bochner
open MeasureTheory

-- 77. 常值函数可积（有限测度前提）
example {α : Type} [MeasurableSpace α] (μ : Measure α) [IsFiniteMeasure μ] :
    Integrable (fun _ : α => (1 : ℝ)) μ := by
  simpa using integrable_const (c := (1 : ℝ))

-- 78. 可积函数之和仍可积
example {α : Type} [MeasurableSpace α] (μ : Measure α)
    {f g : α → ℝ} (hf : Integrable f μ) (hg : Integrable g μ) :
    Integrable (fun x => f x + g x) μ := by
  simpa using hf.add hg

-- 79. 常值函数积分（需要有限测度）
example {α : Type} [MeasurableSpace α] (μ : Measure α) [IsFiniteMeasure μ] :
    ∫ x, (2 : ℝ) ∂μ = 2 * μ Set.univ := by
  simpa using integral_const (c := (2 : ℝ))

-- 80. 线性性：积分与加法
example {α : Type} [MeasurableSpace α] (μ : Measure α)
    {f g : α → ℝ} (hf : Integrable f μ) (hg : Integrable g μ) :
    ∫ x, (f x + g x) ∂μ = (∫ x, f x ∂μ) + (∫ x, g x ∂μ) := by
  simpa using integral_add hf hg
end IntegralMini
```

#### 追加：拓扑/滤子、范畴补充、测度可测性（新增8个）

```lean
-- 拓扑与滤子（3）
section TopoFilterMini
import Mathlib/Topology/Algebra/Group
open Filter

-- 81. principal 滤子单调性
example {α : Type} (s t : Set α) (h : s ⊆ t) : principal s ≤ principal t := by
  simpa [Filter.le_def, principal_def] using principal_mono.mpr h

-- 82. Tendsto 的恒等映射性质
example {α : Type} [TopologicalSpace α] : Tendsto (fun x : α => x) (𝓟 Set.univ) (𝓟 Set.univ) := by
  simpa using tendsto_id'

-- 83. 连续函数在复合下闭合
example {α β γ : Type} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ]
    {f : α → β} {g : β → γ} (hf : Continuous f) (hg : Continuous g) : Continuous (fun x => g (f x)) := by
  simpa using hg.comp hf
end TopoFilterMini

-- 范畴补充（2）
section CategoryExtra
import Mathlib/CategoryTheory/Functor/Category
open CategoryTheory

-- 84. 恒等函子保恒等与合成
example {C : Type} [Category C] : (Functor.id C).map (𝟙 (𝟙_ C)) = 𝟙 (𝟙_ C) := rfl

-- 85. 自然变换的分量在对象上给出态射
example {C D : Type} [Category C] [Category D] (F G : C ⥤ D) (η : F ⟶ G) (X : C) :
    F.obj X ⟶ G.obj X := η.app X
end CategoryExtra

-- 测度可测性（3）
section MeasureExtra
import Mathlib/MeasureTheory/Measure/MeasureSpace
open MeasureTheory

-- 86. 可测函数和（Bool 指示函数例）
example {α : Type} [MeasurableSpace α] :
    Measurable fun x : α => (if True then (0 : ℕ) else 1) := by
  measurability

-- 87. 可测集的补与并仍可测
example {α : Type} [MeasurableSpace α] {s t : Set α}
    (hs : MeasurableSet s) (ht : MeasurableSet t) :
    MeasurableSet (sᶜ ∪ t) := by
  simpa using (hs.compl.union ht)

-- 88. 几乎处处相等是等价关系（使用已有实例）
example {α : Type} [MeasurableSpace α] (μ : Measure α) : Equivalence (Measure.aeEq μ) := by
  infer_instance
end MeasureExtra
```

## 3. 数据结构示例 | Data Structure Examples

### 列表操作示例 | List Operation Examples

```lean
-- 列表基本操作
def list_operations : List ℕ :=
  let xs := [1, 2, 3, 4, 5]
  let ys := xs.map (· * 2)
  let zs := ys.filter (· > 5)
  zs

-- 列表折叠
def list_sum (xs : List ℕ) : ℕ :=
  xs.foldl (· + ·) 0

-- 列表映射
def list_map {α β : Type} (f : α → β) : List α → List β
  | [] => []
  | x :: xs => f x :: list_map f xs

-- 列表过滤
def list_filter {α : Type} (p : α → Bool) : List α → List α
  | [] => []
  | x :: xs => if p x then x :: list_filter p xs else list_filter p xs
```

### 树操作示例 | Tree Operation Examples

```lean
-- 树的大小
def Tree.size {α : Type} : Tree α → ℕ
  | Tree.leaf _ => 1
  | Tree.node l r => Tree.size l + Tree.size r

-- 树的深度
def Tree.depth {α : Type} : Tree α → ℕ
  | Tree.leaf _ => 0
  | Tree.node l r => 1 + max (Tree.depth l) (Tree.depth r)

-- 树映射
def Tree.map {α β : Type} (f : α → β) : Tree α → Tree β
  | Tree.leaf x => Tree.leaf (f x)
  | Tree.node l r => Tree.node (Tree.map f l) (Tree.map f r)

-- 树折叠
def Tree.fold {α β : Type} (f : β → α → β → β) (init : β) : Tree α → β
  | Tree.leaf x => f init x init
  | Tree.node l r => f (Tree.fold f init l) (Tree.fold f init r)
```

## 4. 算法示例 | Algorithm Examples

### 排序算法示例 | Sorting Algorithm Examples

```lean
-- 插入排序
def insertion_sort {α : Type} [LE α] [DecidableRel (· ≤ ·)] : List α → List α
  | [] => []
  | x :: xs => insert x (insertion_sort xs)
where
  insert (x : α) : List α → List α
    | [] => [x]
    | y :: ys => if x ≤ y then x :: y :: ys else y :: insert x ys

-- 归并排序
def merge_sort {α : Type} [LE α] [DecidableRel (· ≤ ·)] : List α → List α
  | [] => []
  | [x] => [x]
  | xs => 
    let mid := xs.length / 2
    let (left, right) := xs.splitAt mid
    merge (merge_sort left) (merge_sort right)
where
  merge : List α → List α → List α
    | [], ys => ys
    | xs, [] => xs
    | x :: xs, y :: ys => 
      if x ≤ y then x :: merge xs (y :: ys)
      else y :: merge (x :: xs) ys

-- 快速排序
def quicksort {α : Type} [LE α] [DecidableRel (· ≤ ·)] : List α → List α
  | [] => []
  | x :: xs => 
    let smaller := xs.filter (· ≤ x)
    let larger := xs.filter (· > x)
    quicksort smaller ++ [x] ++ quicksort larger
```

### 搜索算法示例 | Search Algorithm Examples

```lean
-- 线性搜索
def linear_search {α : Type} [BEq α] (x : α) : List α → Option (Fin (List.length xs))
  | [] => none
  | y :: ys => if x == y then some 0 else 
    match linear_search x ys with
    | none => none
    | some i => some (i + 1)

-- 二分搜索
def binary_search {α : Type} [LE α] [DecidableRel (· ≤ ·)] (x : α) (xs : List α) (h : IsSorted xs) : Option (Fin xs.length) :=
  let rec search (low high : ℕ) : Option (Fin xs.length) :=
    if low > high then none
    else
      let mid := (low + high) / 2
      let mid_val := xs.get ⟨mid, sorry⟩
      if x = mid_val then some ⟨mid, sorry⟩
      else if x < mid_val then search low (mid - 1)
      else search (mid + 1) high
  search 0 (xs.length - 1)
```

## 5. 数学示例 | Mathematical Examples

### 数论示例 | Number Theory Examples

```lean
-- 最大公约数
def gcd (a b : ℕ) : ℕ :=
  if a = 0 then b
  else if b = 0 then a
  else if a > b then gcd (a - b) b
  else gcd a (b - a)

-- 素数判断
def is_prime (n : ℕ) : Bool :=
  if n < 2 then false
  else (List.range n).drop 2 |>.all (· ∣ n)

-- 斐波那契数列
def fibonacci : ℕ → ℕ
  | 0 => 0
  | 1 => 1
  | n + 2 => fibonacci n + fibonacci (n + 1)

-- 阶乘
def factorial : ℕ → ℕ
  | 0 => 1
  | n + 1 => (n + 1) * factorial n
```

### 代数示例 | Algebra Examples

```lean
-- 群的定义
class Group (G : Type) extends Mul G, One G, Inv G where
  mul_assoc : ∀ a b c : G, (a * b) * c = a * (b * c)
  one_mul : ∀ a : G, 1 * a = a
  mul_one : ∀ a : G, a * 1 = a
  mul_left_inv : ∀ a : G, a⁻¹ * a = 1

-- 环的定义
class Ring (R : Type) extends Add R, Mul R, Neg R, Zero R, One R where
  add_assoc : ∀ a b c : R, (a + b) + c = a + (b + c)
  add_comm : ∀ a b : R, a + b = b + a
  add_zero : ∀ a : R, a + 0 = a
  add_left_neg : ∀ a : R, -a + a = 0
  mul_assoc : ∀ a b c : R, (a * b) * c = a * (b * c)
  mul_one : ∀ a : R, a * 1 = a
  one_mul : ∀ a : R, 1 * a = a
  left_distrib : ∀ a b c : R, a * (b + c) = a * b + a * c
  right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c
```

## 6. 形式化验证示例 | Formal Verification Examples

### 程序验证示例 | Program Verification Examples

```lean
-- 排序算法正确性
theorem insertion_sort_correct {α : Type} [LE α] [DecidableRel (· ≤ ·)] (xs : List α) :
  IsSorted (insertion_sort xs) ∧ IsPermutation xs (insertion_sort xs) := by
  sorry -- 需要完整证明

-- 搜索算法正确性
theorem binary_search_correct {α : Type} [LE α] [DecidableRel (· ≤ ·)] (x : α) (xs : List α) (h : IsSorted xs) :
  match binary_search x xs h with
  | some i => xs.get i = x
  | none => x ∉ xs := by
  sorry -- 需要完整证明

-- 循环不变量
theorem loop_invariant (n : ℕ) : n ≥ 0 → factorial n ≥ 1 := by
  intro hn
  induction n with
  | zero => simp [factorial]
  | succ n ih => 
    simp [factorial]
    exact Nat.mul_pos (Nat.succ_pos n) ih
```

### 系统验证示例 | System Verification Examples

```lean
-- 状态机验证
inductive State where
  | initial : State
  | running : State
  | finished : State

def transition : State → State
  | State.initial => State.running
  | State.running => State.finished
  | State.finished => State.finished

theorem state_machine_property (s : State) : 
  s = State.initial → ∃ n : ℕ, (transition^[n]) s = State.finished := by
  intro hs
  exists 2
  simp [hs, transition]

-- 并发系统验证
theorem concurrent_system_safety (s : ConcurrentState) : 
  SafeState s → NextState s → SafeState (NextState s) := by
  sorry -- 需要完整证明
```

## 7. 高级类型示例 | Advanced Type Examples

### 依赖类型示例 | Dependent Type Examples

```lean
-- 长度索引列表
def Vector (α : Type) : ℕ → Type :=
  fun n => { xs : List α // xs.length = n }

-- 安全数组访问
def safe_array_access {α : Type} (arr : Array α) (i : Fin arr.size) : α :=
  arr.get i

-- 形式化规范
def IsSorted {α : Type} [LE α] (xs : List α) : Prop :=
  ∀ i j : Fin xs.length, i.val < j.val → xs.get i ≤ xs.get j

-- 证明相关编程
def proof_relevant_function (n : ℕ) : n + 0 = n :=
  Nat.add_zero n
```

### 类型类示例 | Type Class Examples

```lean
-- 可比较类型类
class Comparable (α : Type) where
  compare : α → α → Ordering
  compare_refl : ∀ a : α, compare a a = Ordering.eq
  compare_symm : ∀ a b : α, compare a b = Ordering.gt ↔ compare b a = Ordering.lt

-- 实例定义
instance : Comparable ℕ where
  compare a b :=
    if a < b then Ordering.lt
    else if a = b then Ordering.eq
    else Ordering.gt
  compare_refl a := by simp [compare]
  compare_symm a b := by simp [compare]; cases Nat.lt_trichotomy a b <;> simp

-- 使用类型类
def sort_with_comparable {α : Type} [Comparable α] (xs : List α) : List α :=
  xs.sort (fun a b => Comparable.compare a b)
```

## 8. 实际应用示例 | Practical Application Examples

### 数据处理示例 | Data Processing Examples

```lean
-- 数据转换管道
def data_pipeline (data : List String) : List ℕ :=
  data
  |>.filter (·.length > 0)
  |>.map String.toNat
  |>.filter (·.isSome)
  |>.map (·.get)

-- 统计分析
def statistics (xs : List ℕ) : ℕ × ℕ × ℕ :=
  let sum := xs.sum
  let count := xs.length
  let average := if count = 0 then 0 else sum / count
  (sum, count, average)

-- 数据验证
def validate_data (xs : List ℕ) : Bool :=
  xs.all (· ≥ 0) && xs.length > 0
```

### 配置管理示例 | Configuration Management Examples

```lean
-- 配置结构
structure Config where
  host : String
  port : ℕ
  timeout : ℕ
  debug : Bool

-- 默认配置
def default_config : Config :=
  { host := "localhost", port := 8080, timeout := 30, debug := false }

-- 配置验证
def validate_config (config : Config) : Bool :=
  config.port > 0 && config.port < 65536 && config.timeout > 0

-- 配置更新
def update_config (config : Config) (updates : List (String × String)) : Config :=
  updates.foldl (fun cfg (key, value) =>
    match key with
    | "host" => { cfg with host := value }
    | "port" => { cfg with port := value.toNat }
    | "timeout" => { cfg with timeout := value.toNat }
    | "debug" => { cfg with debug := value.toBool }
    | _ => cfg
  ) config
```

---

*相关链接：*

- [快速参考手册](./04-快速参考手册.md)
- [学习路径指南](./01-学习路径指南.md)
- [基础语法与类型系统](../02-基础语法与类型系统/01-基础语法元素.md)
- [证明系统与策略](../03-证明系统与策略/01-交互式证明环境.md)
