# 项目模板与脚手架 | Project Templates and Scaffolding

> Lake/elan 最小模板与命令

```bash
# 安装 elan（参考官方：https://leanprover-community.github.io/get_started.html）
# 初始化项目
lake new my_project
cd my_project
lake build
```

> 必备文件（根目录）

```text
- lean-toolchain   # 固定工具链版本
- lakefile.lean    # Lake 项目定义
- MyProject.lean   # 入口（可选）
- MyProject/       # 源码
```

> lakefile.lean 最小示例

```lean
import Lake
open Lake DSL

package my_project

@[default_target]
lean_lib MyProject

require mathlib from git
  "https://github.com/leanprover-community/mathlib4" @ "master"
```

## 最小可运行示例仓库骨架 | Minimal Runnable Repo Skeleton

```text
lean-example/
  ├─ lean-toolchain
  ├─ lakefile.lean
  ├─ Main.lean
  └─ Example/
      └─ Hello.lean
```

```lean
-- Main.lean
import Std
import Mathlib
import Example.Hello

def main : IO Unit := do
  IO.println s!"Hello, Lean! 2 + 3 = {2 + 3}"
```

```lean
-- Example/Hello.lean
namespace Example

def hello : String := "hello"

theorem demo (a b : Nat) : a + b = b + a := by
  exact Nat.add_comm a b

end Example
```

## 多子项目示例 | Multi Subprojects

```text
lean-workspace/
  ├─ lean-toolchain
  ├─ lakefile.lean
  ├─ AppA/
  │   └─ Main.lean
  ├─ AppB/
  │   └─ Main.lean
  └─ LibX/
      └─ Core.lean
```

```lean
-- lakefile.lean（多目标）
import Lake
open Lake DSL

package lean_workspace

lean_lib LibX

@[default_target]
lean_exe AppA where
  root := `AppA.Main

lean_exe AppB where
  root := `AppB.Main

require mathlib from git
  "https://github.com/leanprover-community/mathlib4" @ "master"
```

```bash
# 创建多子项目骨架（示例命令）
mkdir -p AppA AppB LibX
echo "def main : IO Unit := IO.println \"Hello A\"" > AppA/Main.lean
echo "def main : IO Unit := IO.println \"Hello B\"" > AppB/Main.lean
echo "namespace LibX
def hello : String := \"hi\"
end LibX" > LibX/Core.lean
```

## 1. 基础项目模板 | Basic Project Templates

### 简单项目模板 | Simple Project Template

```lean
-- 项目结构
-- MyProject/
--   ├── MyProject.lean
--   ├── MyProject/
--   │   ├── Basic.lean
--   │   ├── Advanced.lean
--   │   └── Examples.lean
--   └── lakefile.lean

-- MyProject.lean (主文件)
import MyProject.Basic
import MyProject.Advanced
import MyProject.Examples

namespace MyProject

-- 项目主要定义
def version : String := "1.0.0"
def description : String := "我的Lean项目"

end MyProject

-- MyProject/Basic.lean
namespace MyProject.Basic

-- 基础定义
def hello : String := "Hello, Lean!"

-- 基础函数
def add (x y : ℕ) : ℕ := x + y

end MyProject.Basic

-- MyProject/Advanced.lean
namespace MyProject.Advanced

-- 高级定义
def complex_function {α : Type} (f : α → α) (x : α) : α := f (f x)

end MyProject.Advanced

-- MyProject/Examples.lean
namespace MyProject.Examples

-- 使用示例
open MyProject.Basic

#eval hello
#eval add 3 5

end MyProject.Examples
```

### 数学项目模板 | Mathematics Project Template

```lean
-- MathProject/
--   ├── MathProject.lean
--   ├── MathProject/
--   │   ├── Algebra.lean
--   │   ├── Analysis.lean
--   │   ├── Topology.lean
--   │   └── NumberTheory.lean
--   └── lakefile.lean

-- MathProject.lean
import MathProject.Algebra
import MathProject.Analysis
import MathProject.Topology
import MathProject.NumberTheory

namespace MathProject

-- 项目元数据
def version : String := "0.1.0"
def author : String := "数学研究者"
def description : String := "数学形式化项目"

end MathProject

-- MathProject/Algebra.lean
import Mathlib.Algebra.Group.Basic
import Mathlib.Algebra.Ring.Basic

namespace MathProject.Algebra

-- 群的定义
class MyGroup (G : Type) extends Mul G, One G, Inv G where
  mul_assoc : ∀ a b c : G, (a * b) * c = a * (b * c)
  one_mul : ∀ a : G, 1 * a = a
  mul_one : ∀ a : G, a * 1 = a
  mul_left_inv : ∀ a : G, a⁻¹ * a = 1

-- 环的定义
class MyRing (R : Type) extends Add R, Mul R, Neg R, Zero R, One R where
  add_assoc : ∀ a b c : R, (a + b) + c = a + (b + c)
  add_comm : ∀ a b : R, a + b = b + a
  add_zero : ∀ a : R, a + 0 = a
  add_left_neg : ∀ a : R, -a + a = 0
  mul_assoc : ∀ a b c : R, (a * b) * c = a * (b * c)
  mul_one : ∀ a : R, a * 1 = a
  one_mul : ∀ a : R, 1 * a = a
  left_distrib : ∀ a b c : R, a * (b + c) = a * b + a * c
  right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c

end MathProject.Algebra

-- MathProject/NumberTheory.lean
import Mathlib.Data.Nat.Basic
import Mathlib.Data.Nat.Prime

namespace MathProject.NumberTheory

-- 素数判断
def is_prime (n : ℕ) : Bool :=
  if n < 2 then false
  else (List.range n).drop 2 |>.all (· ∣ n)

-- 最大公约数
def gcd (a b : ℕ) : ℕ :=
  if a = 0 then b
  else if b = 0 then a
  else if a > b then gcd (a - b) b
  else gcd a (b - a)

-- 最小公倍数
def lcm (a b : ℕ) : ℕ :=
  if a = 0 ∨ b = 0 then 0
  else (a * b) / gcd a b

end MathProject.NumberTheory
```

## 2. 证明项目模板 | Proof Project Template

### 定理证明项目 | Theorem Proving Project

```lean
-- ProofProject/
--   ├── ProofProject.lean
--   ├── ProofProject/
--   │   ├── Basic.lean
--   │   ├── Intermediate.lean
--   │   ├── Advanced.lean
--   │   └── Applications.lean
--   └── lakefile.lean

-- ProofProject.lean
import ProofProject.Basic
import ProofProject.Intermediate
import ProofProject.Advanced
import ProofProject.Applications

namespace ProofProject

-- 项目信息
def version : String := "0.2.0"
def focus : String := "形式化数学证明"

end ProofProject

-- ProofProject/Basic.lean
import Mathlib.Data.Nat.Basic
import Mathlib.Logic.Basic

namespace ProofProject.Basic

-- 基础定理
theorem add_zero (n : ℕ) : n + 0 = n := by
  exact Nat.add_zero n

theorem add_comm (a b : ℕ) : a + b = b + a := by
  exact Nat.add_comm a b

theorem add_assoc (a b c : ℕ) : (a + b) + c = a + (b + c) := by
  exact Nat.add_assoc a b c

-- 基础引理
lemma succ_add (a b : ℕ) : (a + 1) + b = (a + b) + 1 := by
  rw [Nat.add_assoc, Nat.add_comm 1 b, ←Nat.add_assoc]

end ProofProject.Basic

-- ProofProject/Intermediate.lean
import ProofProject.Basic

namespace ProofProject.Intermediate

-- 中等难度定理
theorem mul_zero (n : ℕ) : n * 0 = 0 := by
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.mul_succ, ih]

theorem mul_one (n : ℕ) : n * 1 = n := by
  exact Nat.mul_one n

theorem mul_comm (a b : ℕ) : a * b = b * a := by
  exact Nat.mul_comm a b

-- 使用基础引理
theorem mul_succ (a b : ℕ) : a * (b + 1) = a * b + a := by
  rw [Nat.mul_add, mul_one]

end ProofProject.Intermediate
```

## 3. 库开发模板 | Library Development Template

### 可重用库模板 | Reusable Library Template

```lean
-- MyLibrary/
--   ├── MyLibrary.lean
--   ├── MyLibrary/
--   │   ├── Core.lean
--   │   ├── Extensions.lean
--   │   ├── Utilities.lean
--   │   └── Tests.lean
--   ├── lakefile.lean
--   └── README.md

-- MyLibrary.lean
import MyLibrary.Core
import MyLibrary.Extensions
import MyLibrary.Utilities

namespace MyLibrary

-- 库版本信息
def version : String := "1.0.0"
def lean_version : String := "4.0.0"

-- 库描述
def description : String := "可重用的Lean库"

-- 导出主要接口
export Core (main_function)
export Extensions (extended_function)
export Utilities (utility_function)

end MyLibrary

-- MyLibrary/Core.lean
namespace MyLibrary.Core

-- 核心功能
def main_function (x : ℕ) : ℕ := x * 2

-- 核心类型
inductive CoreType where
  | basic : CoreType
  | advanced : ℕ → CoreType

-- 核心操作
def process_core (ct : CoreType) : ℕ :=
  match ct with
  | CoreType.basic => 0
  | CoreType.advanced n => n

end MyLibrary.Core

-- MyLibrary/Extensions.lean
import MyLibrary.Core

namespace MyLibrary.Extensions

-- 扩展功能
def extended_function (x : ℕ) : ℕ :=
  Core.main_function x + 1

-- 扩展类型
inductive ExtendedType extends Core.CoreType where
  | special : ExtendedType

-- 扩展操作
def process_extended (et : ExtendedType) : ℕ :=
  match et with
  | ExtendedType.basic => 0
  | ExtendedType.advanced n => n
  | ExtendedType.special => 42

end MyLibrary.Extensions

-- MyLibrary/Utilities.lean
namespace MyLibrary.Utilities

-- 实用函数
def utility_function (xs : List ℕ) : ℕ :=
  xs.sum

-- 实用类型
def UtilityType := List ℕ

-- 实用操作
def process_utility (ut : UtilityType) : ℕ :=
  utility_function ut

end MyLibrary.Utilities

-- MyLibrary/Tests.lean
import MyLibrary

namespace MyLibrary.Tests

-- 测试用例
def test_basic : Bool :=
  Core.main_function 5 = 10

def test_extended : Bool :=
  Extensions.extended_function 5 = 11

def test_utility : Bool :=
  Utilities.utility_function [1, 2, 3] = 6

-- 运行测试
def run_tests : List Bool :=
  [test_basic, test_extended, test_utility]

end MyLibrary.Tests
```

## 4. 应用项目模板 | Application Project Template

### 命令行应用模板 | Command Line Application Template

```lean
-- CLIApp/
--   ├── CLIApp.lean
--   ├── CLIApp/
--   │   ├── Main.lean
--   │   ├── Commands.lean
--   │   ├── Parser.lean
--   │   └── Utils.lean
--   ├── lakefile.lean
--   └── README.md

-- CLIApp.lean
import CLIApp.Main
import CLIApp.Commands
import CLIApp.Parser
import CLIApp.Utils

namespace CLIApp

-- 应用信息
def app_name : String := "CLIApp"
def version : String := "1.0.0"
def description : String := "命令行应用程序"

end CLIApp

-- CLIApp/Main.lean
import CLIApp.Commands
import CLIApp.Parser

namespace CLIApp.Main

-- 主函数
def main (args : List String) : IO Unit := do
  let parsed_args ← Parser.parse_args args
  match parsed_args with
  | Parser.Command.help => Commands.show_help
  | Parser.Command.version => Commands.show_version
  | Parser.Command.process input => Commands.process_input input
  | Parser.Command.error msg => IO.println s!"错误: {msg}"

-- 应用入口点
def run : IO Unit := do
  let args ← IO.getArgs
  main args

end CLIApp.Main

-- CLIApp/Commands.lean
namespace CLIApp.Commands

-- 帮助命令
def show_help : IO Unit := do
  IO.println "CLIApp - 命令行应用程序"
  IO.println "用法: cliapp [选项] [参数]"
  IO.println "选项:"
  IO.println "  -h, --help     显示帮助信息"
  IO.println "  -v, --version  显示版本信息"
  IO.println "  -p, --process  处理输入"

-- 版本命令
def show_version : IO Unit := do
  IO.println s!"CLIApp 版本 {CLIApp.version}"

-- 处理命令
def process_input (input : String) : IO Unit := do
  IO.println s!"处理输入: {input}"
  -- 实际处理逻辑

end CLIApp.Commands

-- CLIApp/Parser.lean
namespace CLIApp.Parser

-- 命令类型
inductive Command where
  | help : Command
  | version : Command
  | process (input : String) : Command
  | error (message : String) : Command

-- 参数解析
def parse_args (args : List String) : IO Command := do
  match args with
  | [] => return Command.help
  | ["-h"] => return Command.help
  | ["--help"] => return Command.help
  | ["-v"] => return Command.version
  | ["--version"] => return Command.version
  | ["-p", input] => return Command.process input
  | ["--process", input] => return Command.process input
  | _ => return Command.error "未知参数"

end CLIApp.Parser
```

## 5. 测试项目模板 | Testing Project Template

### 测试驱动开发模板 | Test-Driven Development Template

```lean
-- TestProject/
--   ├── TestProject.lean
--   ├── TestProject/
--   │   ├── Implementation.lean
--   │   ├── Tests.lean
--   │   ├── Properties.lean
--   │   └── Benchmarks.lean
--   └── lakefile.lean

-- TestProject.lean
import TestProject.Implementation
import TestProject.Tests
import TestProject.Properties
import TestProject.Benchmarks

namespace TestProject

-- 项目信息
def version : String := "0.3.0"
def testing_framework : String := "Lean 4 内置测试"

end TestProject

-- TestProject/Implementation.lean
namespace TestProject.Implementation

-- 待测试的实现
def factorial : ℕ → ℕ
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

def fibonacci : ℕ → ℕ
  | 0 => 0
  | 1 => 1
  | n + 2 => fibonacci n + fibonacci (n + 1)

def is_prime (n : ℕ) : Bool :=
  if n < 2 then false
  else (List.range n).drop 2 |>.all (· ∣ n)

end TestProject.Implementation

-- TestProject/Tests.lean
import TestProject.Implementation

namespace TestProject.Tests

-- 单元测试
def test_factorial_zero : Bool :=
  Implementation.factorial 0 = 1

def test_factorial_one : Bool :=
  Implementation.factorial 1 = 1

def test_factorial_five : Bool :=
  Implementation.factorial 5 = 120

def test_fibonacci_zero : Bool :=
  Implementation.fibonacci 0 = 0

def test_fibonacci_one : Bool :=
  Implementation.fibonacci 1 = 1

def test_fibonacci_ten : Bool :=
  Implementation.fibonacci 10 = 55

def test_is_prime_two : Bool :=
  Implementation.is_prime 2 = true

def test_is_prime_four : Bool :=
  Implementation.is_prime 4 = false

def test_is_prime_seventeen : Bool :=
  Implementation.is_prime 17 = true

-- 测试套件
def test_suite : List (String × Bool) :=
  [("factorial 0", test_factorial_zero),
   ("factorial 1", test_factorial_one),
   ("factorial 5", test_factorial_five),
   ("fibonacci 0", test_fibonacci_zero),
   ("fibonacci 1", test_fibonacci_one),
   ("fibonacci 10", test_fibonacci_ten),
   ("is_prime 2", test_is_prime_two),
   ("is_prime 4", test_is_prime_four),
   ("is_prime 17", test_is_prime_seventeen)]

-- 运行测试
def run_tests : IO Unit := do
  for (name, result) in test_suite do
    if result then
      IO.println s!"✓ {name}"
    else
      IO.println s!"✗ {name}"

end TestProject.Tests

-- TestProject/Properties.lean
import TestProject.Implementation

namespace TestProject.Properties

-- 属性测试
theorem factorial_property (n : ℕ) : Implementation.factorial n ≥ 1 := by
  induction n with
  | zero => simp [Implementation.factorial]
  | succ n ih => 
    simp [Implementation.factorial]
    exact Nat.mul_pos (Nat.succ_pos n) ih

theorem fibonacci_property (n : ℕ) : Implementation.fibonacci n ≥ 0 := by
  induction n with
  | zero => simp [Implementation.fibonacci]
  | succ n ih => 
    cases n with
    | zero => simp [Implementation.fibonacci]
    | succ n => 
      simp [Implementation.fibonacci]
      exact Nat.add_nonneg ih (fibonacci_property n)

theorem prime_property (n : ℕ) : 
  Implementation.is_prime n = true → n ≥ 2 := by
  intro h
  simp [Implementation.is_prime] at h
  split_ifs at h with h1 h2
  · contradiction
  · exact Nat.le_of_lt h2

end TestProject.Properties
```

## 6. 文档项目模板 | Documentation Project Template

### 文档生成项目 | Documentation Generation Project

```lean
-- DocProject/
--   ├── DocProject.lean
--   ├── DocProject/
--   │   ├── API.lean
--   │   ├── Examples.lean
--   │   ├── Tutorials.lean
--   │   └── Reference.lean
--   ├── docs/
--   │   ├── README.md
--   │   ├── API.md
--   │   └── examples/
--   └── lakefile.lean

-- DocProject.lean
import DocProject.API
import DocProject.Examples
import DocProject.Tutorials
import DocProject.Reference

namespace DocProject

-- 文档信息
def version : String := "1.0.0"
def doc_version : String := "1.0.0"
def last_updated : String := "2024-01-01"

end DocProject

-- DocProject/API.lean
namespace DocProject.API

-- API文档注释
/-- 
计算两个自然数的和
- `a`: 第一个自然数
- `b`: 第二个自然数
- 返回: `a + b`
-/
def add (a b : ℕ) : ℕ := a + b

/--
计算自然数的阶乘
- `n`: 输入自然数
- 返回: `n!`
- 示例: `factorial 5 = 120`
-/
def factorial (n : ℕ) : ℕ :=
  match n with
  | 0 => 1
  | n + 1 => (n + 1) * factorial n

/--
检查自然数是否为素数
- `n`: 要检查的自然数
- 返回: 如果是素数则返回true，否则返回false
- 示例: `is_prime 17 = true`
-/
def is_prime (n : ℕ) : Bool :=
  if n < 2 then false
  else (List.range n).drop 2 |>.all (· ∣ n)

end DocProject.API

-- DocProject/Examples.lean
import DocProject.API

namespace DocProject.Examples

-- 使用示例
open DocProject.API

-- 基本使用
def example_basic : ℕ := add 3 5

-- 复杂使用
def example_complex (n : ℕ) : ℕ :=
  if is_prime n then factorial n else add n 1

-- 实际应用
def example_application (xs : List ℕ) : List ℕ :=
  xs.map (fun x => if is_prime x then factorial x else add x 1)

end DocProject.Examples
```

## 7. 脚手架生成器 | Scaffolding Generators

### 项目生成脚本 | Project Generation Script

```lean
-- 项目生成器
namespace ProjectGenerator

-- 项目类型
inductive ProjectType where
  | basic : ProjectType
  | math : ProjectType
  | proof : ProjectType
  | library : ProjectType
  | application : ProjectType
  | testing : ProjectType

-- 项目配置
structure ProjectConfig where
  name : String
  type : ProjectType
  version : String
  author : String
  description : String

-- 生成基础项目
def generate_basic_project (config : ProjectConfig) : String :=
  s!"-- {config.name}.lean
import {config.name}.Basic

namespace {config.name}

def version : String := \"{config.version}\"
def author : String := \"{config.author}\"
def description : String := \"{config.description}\"

end {config.name}"

-- 生成数学项目
def generate_math_project (config : ProjectConfig) : String :=
  s!"-- {config.name}.lean
import {config.name}.Algebra
import {config.name}.Analysis
import {config.name}.Topology

namespace {config.name}

def version : String := \"{config.version}\"
def focus : String := \"数学形式化\"

end {config.name}"

-- 生成项目文件
def generate_project (config : ProjectConfig) : String :=
  match config.type with
  | ProjectType.basic => generate_basic_project config
  | ProjectType.math => generate_math_project config
  | _ => "项目类型暂不支持"

end ProjectGenerator
```

## 8. 最佳实践模板 | Best Practices Templates

### 代码组织最佳实践 | Code Organization Best Practices

```lean
-- 模块化设计
namespace BestPractices

-- 1. 清晰的命名空间
namespace MyModule
  -- 模块内容
end MyModule

-- 2. 适当的抽象层次
class AbstractInterface (α : Type) where
  operation : α → α → α
  identity : α
  inverse : α → α

-- 3. 类型安全
def safe_operation {α : Type} [AbstractInterface α] (x y : α) : α :=
  AbstractInterface.operation x y

-- 4. 错误处理
inductive Result (α : Type) where
  | success (value : α) : Result α
  | error (message : String) : Result α

-- 5. 文档化
/--
这是一个示例函数，展示了最佳实践
- `x`: 输入参数
- 返回: 处理后的结果
- 示例: `example_function 42 = 84`
-/
def example_function (x : ℕ) : ℕ := x * 2

end BestPractices
```

---

*相关链接：*

- [学习路径指南](./01-学习路径指南.md)
- [常见问题解答](./02-常见问题解答.md)
- [性能优化指南](./03-性能优化指南.md)
- [快速参考手册](./04-快速参考手册.md)
- [示例库](./05-示例库.md)
