# 测试与验证指南 | Testing and Verification Guide

## 1. 测试基础 | Testing Fundamentals

### 测试类型 | Types of Testing

```lean
-- 单元测试
def test_basic_function : Bool :=
  factorial 5 = 120

-- 集成测试
def test_integration : Bool :=
  let result := process_data [1, 2, 3, 4, 5]
  result.sum = 15 && result.length = 5

-- 属性测试
theorem test_property (n : ℕ) : factorial n ≥ 1 := by
  induction n with
  | zero => simp [factorial]
  | succ n ih => 
    simp [factorial]
    exact Nat.mul_pos (Nat.succ_pos n) ih

-- 回归测试
def test_regression : Bool :=
  -- 确保之前修复的bug不会重现
  complex_algorithm [1, 2, 3] = expected_result
```

### 测试框架 | Testing Framework

```lean
-- 简单测试框架
namespace TestFramework

-- 测试结果类型
inductive TestResult where
  | passed : TestResult
  | failed (message : String) : TestResult
  | skipped : TestResult

-- 测试用例类型
structure TestCase where
  name : String
  test : IO TestResult
  description : String

-- 测试套件
structure TestSuite where
  name : String
  tests : List TestCase

-- 运行单个测试
def run_test (test : TestCase) : IO TestResult := do
  IO.println s!"运行测试: {test.name}"
  test.test

-- 运行测试套件
def run_suite (suite : TestSuite) : IO (List TestResult) := do
  IO.println s!"运行测试套件: {suite.name}"
  let results ← suite.tests.mapM run_test
  let passed := results.filter (· = TestResult.passed) |>.length
  let failed := results.filter (· ≠ TestResult.passed) |>.length
  IO.println s!"通过: {passed}, 失败: {failed}"
  return results

end TestFramework
```

## 2. 单元测试 | Unit Testing

### 基本单元测试 | Basic Unit Tests

```lean
namespace UnitTests

-- 测试简单函数
def test_add : Bool :=
  add 2 3 = 5

def test_multiply : Bool :=
  multiply 4 5 = 20

def test_factorial : Bool :=
  factorial 6 = 720

-- 测试边界条件
def test_factorial_zero : Bool :=
  factorial 0 = 1

def test_factorial_one : Bool :=
  factorial 1 = 1

-- 测试错误处理
def test_divide_by_zero : Bool :=
  try
    divide 5 0
    false
  catch
    _ => true

-- 测试列表操作
def test_list_operations : Bool :=
  let xs := [1, 2, 3, 4, 5]
  xs.length = 5 && xs.head? = some 1 && xs.tail?.isSome

-- 测试字符串操作
def test_string_operations : Bool :=
  let s := "Hello, World!"
  s.length = 13 && s.contains "World"

end UnitTests
```

### 高级单元测试 | Advanced Unit Tests

```lean
namespace AdvancedUnitTests

-- 测试依赖类型
def test_vector_operations : Bool :=
  let v1 : Vector ℕ 3 := Vector.cons 1 (Vector.cons 2 (Vector.cons 3 Vector.nil))
  let v2 : Vector ℕ 3 := Vector.cons 4 (Vector.cons 5 (Vector.cons 6 Vector.nil))
  let sum := vector_add v1 v2
  sum.get ⟨0, sorry⟩ = 5 && sum.get ⟨1, sorry⟩ = 7

-- 测试类型类实例
def test_typeclass_instances : Bool :=
  let add_result := (2 : ℕ) + (3 : ℕ)
  let mul_result := (2 : ℕ) * (3 : ℕ)
  add_result = 5 && mul_result = 6

-- 测试高阶函数
def test_higher_order_functions : Bool :=
  let xs := [1, 2, 3, 4, 5]
  let doubled := xs.map (· * 2)
  let filtered := doubled.filter (· > 5)
  filtered = [6, 8, 10]

-- 测试递归函数
def test_recursive_functions : Bool :=
  let tree := Tree.node (Tree.leaf 1) (Tree.node (Tree.leaf 2) (Tree.leaf 3))
  tree_size tree = 3 && tree_depth tree = 2

end AdvancedUnitTests
```

## 3. 属性测试 | Property Testing

### 基本属性测试 | Basic Property Testing

```lean
namespace PropertyTests

-- 交换律属性
theorem add_comm_property (a b : ℕ) : a + b = b + a := by
  exact Nat.add_comm a b

-- 结合律属性
theorem add_assoc_property (a b c : ℕ) : (a + b) + c = a + (b + c) := by
  exact Nat.add_assoc a b c

-- 单位元属性
theorem add_zero_property (a : ℕ) : a + 0 = a := by
  exact Nat.add_zero a

-- 幂等性属性
theorem idempotent_property (x : Bool) : x && x = x := by
  cases x <;> rfl

-- 单调性属性
theorem monotonic_property (a b c : ℕ) : a ≤ b → a + c ≤ b + c := by
  intro h
  exact Nat.add_le_add_right h c

end PropertyTests
```

### 高级属性测试 | Advanced Property Testing

```lean
namespace AdvancedPropertyTests

-- 排序属性
theorem sorting_property (xs : List ℕ) : 
  let sorted := insertion_sort xs
  is_sorted sorted ∧ is_permutation xs sorted := by
  sorry -- 需要完整证明

-- 搜索属性
theorem search_property (x : ℕ) (xs : List ℕ) (h : is_sorted xs) :
  match binary_search x xs h with
  | some i => xs.get i = x
  | none => x ∉ xs := by
  sorry -- 需要完整证明

-- 数据结构属性
theorem tree_property (t : Tree ℕ) : 
  tree_size t ≥ 0 ∧ tree_depth t ≥ 0 := by
  induction t with
  | leaf _ => simp [tree_size, tree_depth]
  | node l r ih_l ih_r => 
    simp [tree_size, tree_depth]
    constructor
    · exact Nat.add_nonneg ih_l.1 ih_r.1
    · exact Nat.succ_le_succ (max_le ih_l.2 ih_r.2)

-- 算法复杂度属性
theorem complexity_property (n : ℕ) : 
  let result := factorial n
  result ≥ 1 ∧ (n > 0 → result ≥ n) := by
  constructor
  · exact factorial_positive n
  · intro hn
    exact factorial_ge_n n hn

end AdvancedPropertyTests
```

## 4. 集成测试 | Integration Testing

### 模块集成测试 | Module Integration Tests

```lean
namespace IntegrationTests

-- 测试模块间交互
def test_module_integration : Bool :=
  let data := [1, 2, 3, 4, 5]
  let processed := DataProcessor.process data
  let validated := Validator.validate processed
  let result := Calculator.calculate validated
  result.isValid && result.value = 15

-- 测试数据流
def test_data_flow : Bool :=
  let input := "1,2,3,4,5"
  let parsed := Parser.parse input
  let transformed := Transformer.transform parsed
  let output := Formatter.format transformed
  output = "Sum: 15, Count: 5, Average: 3"

-- 测试错误传播
def test_error_propagation : Bool :=
  let invalid_input := "invalid,data"
  let parsed := Parser.parse invalid_input
  match parsed with
  | Parser.Result.success _ => false
  | Parser.Result.error _ => true

-- 测试状态管理
def test_state_management : Bool :=
  let state := StateManager.initial
  let state1 := StateManager.update state "key1" "value1"
  let state2 := StateManager.update state1 "key2" "value2"
  let value1 := StateManager.get state2 "key1"
  let value2 := StateManager.get state2 "key2"
  value1 = some "value1" && value2 = some "value2"

end IntegrationTests
```

### 系统集成测试 | System Integration Tests

```lean
namespace SystemIntegrationTests

-- 测试完整工作流
def test_complete_workflow : Bool :=
  let input_data := generate_test_data 100
  let processed_data := process_pipeline input_data
  let output_data := generate_output processed_data
  validate_output output_data

-- 测试性能要求
def test_performance_requirements : Bool :=
  let start_time := get_current_time
  let result := expensive_operation large_dataset
  let end_time := get_current_time
  let duration := end_time - start_time
  result.isSuccess && duration < max_allowed_time

-- 测试并发安全
def test_concurrency_safety : Bool :=
  let shared_resource := SharedResource.create
  let results := parallel_operations shared_resource
  all_results_valid results && no_race_conditions results

-- 测试资源管理
def test_resource_management : Bool :=
  let resource := acquire_resource
  let result := use_resource resource
  let cleanup_success := release_resource resource
  result.isSuccess && cleanup_success

end SystemIntegrationTests
```

## 5. 形式化验证 | Formal Verification

### 规范验证 | Specification Verification

```lean
namespace SpecificationVerification

-- 前置条件验证
theorem precondition_verification (x : ℕ) (h : x > 0) : 
  let result := safe_divide 10 x
  result.isSome := by
  simp [safe_divide]
  exact h

-- 后置条件验证
theorem postcondition_verification (x : ℕ) : 
  let result := factorial x
  result ≥ 1 := by
  exact factorial_positive x

-- 不变量验证
theorem invariant_verification (s : State) : 
  invariant s → next_state s → invariant (next_state s) := by
  sorry -- 需要完整证明

-- 终止性验证
theorem termination_verification (n : ℕ) : 
  let result := recursive_function n
  result.isSome := by
  sorry -- 需要完整证明

end SpecificationVerification
```

### 正确性验证 | Correctness Verification

```lean
namespace CorrectnessVerification

-- 算法正确性
theorem algorithm_correctness (input : InputType) : 
  let output := algorithm input
  specification input output := by
  sorry -- 需要完整证明

-- 数据结构正确性
theorem data_structure_correctness (ds : DataStructure) : 
  invariant ds → operation ds → invariant (operation ds) := by
  sorry -- 需要完整证明

-- 系统正确性
theorem system_correctness (system : System) : 
  system_property system := by
  sorry -- 需要完整证明

end CorrectnessVerification
```

## 6. 性能测试 | Performance Testing

### 基准测试 | Benchmarking

```lean
namespace Benchmarking

-- 时间基准测试
def benchmark_time (f : Unit → α) : IO (α × ℕ) := do
  let start_time := get_current_time_ns
  let result := f ()
  let end_time := get_current_time_ns
  let duration := end_time - start_time
  return (result, duration)

-- 内存基准测试
def benchmark_memory (f : Unit → α) : IO (α × ℕ) := do
  let start_memory := get_memory_usage
  let result := f ()
  let end_memory := get_memory_usage
  let memory_used := end_memory - start_memory
  return (result, memory_used)

-- 比较基准测试
def compare_benchmarks (f1 f2 : Unit → α) : IO (ComparisonResult α) := do
  let (result1, time1) ← benchmark_time f1
  let (result2, time2) ← benchmark_time f2
  return {
    result1 := result1,
    result2 := result2,
    time1 := time1,
    time2 := time2,
    speedup := time1.toFloat / time2.toFloat
  }

end Benchmarking
```

### 压力测试 | Stress Testing

```lean
namespace StressTesting

-- 大数据集测试
def stress_test_large_data : Bool :=
  let large_dataset := generate_large_dataset 1000000
  let result := process_large_dataset large_dataset
  result.isSuccess && result.performance_acceptable

-- 边界条件测试
def stress_test_boundary_conditions : Bool :=
  let max_value := max_int_value
  let min_value := min_int_value
  let result1 := process_value max_value
  let result2 := process_value min_value
  result1.isSuccess && result2.isSuccess

-- 并发压力测试
def stress_test_concurrency : Bool :=
  let concurrent_operations := generate_concurrent_operations 1000
  let results := execute_concurrent_operations concurrent_operations
  all_operations_successful results && no_deadlocks results

end StressTesting
```

## 7. 测试自动化 | Test Automation

### 自动化测试框架 | Automated Testing Framework

```lean
namespace AutomatedTesting

-- 测试发现
def discover_tests (module : Module) : List TestCase :=
  module.functions.filter (·.name.startsWith "test_")

-- 测试执行
def execute_tests (tests : List TestCase) : IO TestResults := do
  let results ← tests.mapM (fun test => do
    let result ← test.execute
    return (test.name, result))
  return TestResults.mk results

-- 测试报告生成
def generate_report (results : TestResults) : String :=
  let passed := results.passed_count
  let failed := results.failed_count
  let total := passed + failed
  s!"测试报告:\n通过: {passed}/{total}\n失败: {failed}/{total}\n成功率: {passed * 100 / total}%"

-- 持续集成支持
def ci_test_pipeline : IO Bool := do
  let tests ← discover_tests current_module
  let results ← execute_tests tests
  let report ← generate_report results
  IO.println report
  return results.all_passed

end AutomatedTesting
```

### 测试数据生成 | Test Data Generation

```lean
namespace TestDataGeneration

-- 随机数据生成
def generate_random_data (size : ℕ) : IO (List ℕ) := do
  let mut result := []
  for _ in [0:size] do
    let random_value ← IO.rand 0 1000
    result := random_value :: result
  return result

-- 边界数据生成
def generate_boundary_data : List ℕ :=
  [0, 1, max_int_value, min_int_value]

-- 特殊值生成
def generate_special_values : List ℕ :=
  [0, 1, 2, 10, 100, 1000, 10000]

-- 组合数据生成
def generate_combination_data : List (ℕ × ℕ) :=
  [(0, 0), (0, 1), (1, 0), (1, 1), (10, 5), (100, 50)]

end TestDataGeneration
```

## 8. 测试最佳实践 | Testing Best Practices

### 测试设计原则 | Test Design Principles

```lean
namespace TestDesignPrinciples

-- 1. 单一职责原则
def test_single_responsibility : Bool :=
  -- 每个测试只验证一个功能点
  factorial 5 = 120

-- 2. 独立性原则
def test_independence : Bool :=
  -- 测试之间不应该相互依赖
  let result1 := function_a 10
  let result2 := function_b 20
  result1.isSuccess && result2.isSuccess

-- 3. 可重复性原则
def test_repeatability : Bool :=
  -- 测试结果应该可重复
  let result1 := deterministic_function 42
  let result2 := deterministic_function 42
  result1 = result2

-- 4. 清晰性原则
def test_clarity : Bool :=
  -- 测试应该清晰易懂
  let input := [1, 2, 3, 4, 5]
  let expected := 15
  let actual := sum_list input
  actual = expected

end TestDesignPrinciples
```

### 测试维护策略 | Test Maintenance Strategies

```lean
namespace TestMaintenance

-- 测试重构
def refactor_test : Bool :=
  -- 保持测试代码的整洁和可维护性
  let old_test := complex_test_implementation
  let new_test := simplified_test_implementation
  old_test.result = new_test.result

-- 测试文档化
def document_test : Bool :=
  -- 为测试添加清晰的文档
  /-- 测试列表求和函数的正确性 -/
  let test_data := [1, 2, 3, 4, 5]
  let expected_sum := 15
  let actual_sum := sum_list test_data
  actual_sum = expected_sum

-- 测试版本控制
def version_control_test : Bool :=
  -- 测试应该与代码一起版本控制
  let test_version := "1.0.0"
  let code_version := "1.0.0"
  test_version = code_version

end TestMaintenance
```

---

*相关链接：*

- [学习路径指南](./01-学习路径指南.md)
- [常见问题解答](./02-常见问题解答.md)
- [性能优化指南](./03-性能优化指南.md)
- [快速参考手册](./04-快速参考手册.md)
- [示例库](./05-示例库.md)
- [项目模板与脚手架](./06-项目模板与脚手架.md)
