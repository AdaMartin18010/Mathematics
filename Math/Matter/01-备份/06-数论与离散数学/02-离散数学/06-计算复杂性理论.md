# 计算复杂性理论

## 目录

- [计算复杂性理论](#计算复杂性理论)
  - [目录](#目录)
  - [1. 引言](#1-引言)
  - [2. 历史背景](#2-历史背景)
  - [3. 计算模型](#3-计算模型)
    - [3.1 图灵机](#31-图灵机)
    - [3.2 λ演算](#32-λ演算)
    - [3.3 布尔电路](#33-布尔电路)
    - [3.4 随机存取机（RAM）](#34-随机存取机ram)
  - [4. 复杂性类](#4-复杂性类)
    - [4.1 时间复杂性](#41-时间复杂性)
    - [4.2 空间复杂性](#42-空间复杂性)
    - [4.3 重要复杂性类的关系](#43-重要复杂性类的关系)
  - [5. P与NP问题](#5-p与np问题)
    - [5.1 决策问题](#51-决策问题)
    - [5.2 P类问题](#52-p类问题)
    - [5.3 NP类问题](#53-np类问题)
    - [5.4 P vs NP猜想](#54-p-vs-np猜想)
  - [6. NP完全性](#6-np完全性)
    - [6.1 多项式时间规约](#61-多项式时间规约)
    - [6.2 Cook-Levin定理](#62-cook-levin定理)
    - [6.3 经典NP完全问题](#63-经典np完全问题)
  - [7. 其他复杂性类](#7-其他复杂性类)
    - [7.1 协议复杂性：IP与PCP](#71-协议复杂性ip与pcp)
    - [7.2 随机化复杂性：BPP、RP与ZPP](#72-随机化复杂性bpprp与zpp)
    - [7.3 量子复杂性：BQP](#73-量子复杂性bqp)
  - [8. 近似算法与复杂性](#8-近似算法与复杂性)
    - [8.1 近似比](#81-近似比)
    - [8.2 近似方案](#82-近似方案)
    - [8.3 不可近似性结果](#83-不可近似性结果)

---

## 1. 引言

计算复杂性理论是计算机科学的核心分支，研究计算问题的内在难度及其所需资源。作为一门介于数学和计算机科学交叉领域的学科，它不仅探讨"能否计算"的问题，更关注"以何种代价计算"的问题，为我们提供了理解计算极限的理论框架。

计算复杂性理论分类和量化不同计算任务的难度，使用数学工具严格定义和分析问题所需的计算资源（如时间、空间、随机性），并研究不同复杂性类之间的关系。这些理论结果不仅具有深远的理论意义，还对密码学、算法设计、人工智能等领域产生了实质性影响。

本文将系统地探讨计算复杂性理论的基础概念、主要复杂性类、经典理论问题以及前沿发展，同时结合具体的算法实现和哲学思考，提供一个全面而深入的理论概览。

## 2. 历史背景

计算复杂性理论的发展历程可追溯至20世纪初逻辑学和计算理论的基础研究，主要里程碑包括：

- **1936年**：阿兰·图灵（Alan Turing）提出图灵机模型，形式化定义了算法概念；同时，阿隆佐·丘奇（Alonzo Church）提出λ演算，两种模型后来被证明是计算等价的
- **1950年代**：研究者开始关注问题的计算效率而非仅仅可计算性，如最小化布尔函数、有限自动机的状态数等
- **1965年**：Juris Hartmanis和Richard Stearns发表开创性论文，正式奠定复杂性理论的基础，引入时间和空间复杂性的层次结构
- **1971年**：Stephen Cook发表《定理证明程序的复杂性》，提出NP完全性概念和第一个NP完全问题（SAT问题）
- **1972年**：Richard Karp扩展Cook的工作，证明21个经典问题的NP完全性，展示了NP完全性在各领域的普遍存在
- **1970-1980年代**：复杂性理论快速发展，各种复杂性类（如PSPACE、BPP、PH等）被定义和研究
- **1985年**：Shafi Goldwasser、Silvio Micali和Charles Rackoff引入交互式证明系统（IP）
- **1990年代**：概率可验证证明（PCP）定理的证明，为近似算法的不可近似性结果奠定基础
- **1994年**：Peter Shor提出量子多项式时间因式分解算法，引发量子计算复杂性理论研究热潮
- **2002年**：AKS素性检测算法证明素数判定在P类中，解决长期悬而未决的理论问题
- **2000年至今**：复杂性理论继续与密码学、量子计算、机器学习等领域深度融合，产生新的研究方向

整个发展历程中，P vs NP问题一直是该领域最著名的未解决问题，也是数学中七个千禧年问题之一。

## 3. 计算模型

计算复杂性的研究基于形式化的计算模型，这些模型为精确定义和分析算法性能提供了理论基础。

### 3.1 图灵机

图灵机是最经典、最基础的计算模型，由Alan Turing在1936年提出。

**定义 3.1.1**（确定性图灵机）：一个确定性图灵机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$，其中：

- $Q$ 是有限的状态集合
- $\Sigma$ 是输入字母表（不包含空白符号 $\sqcup$）
- $\Gamma$ 是带字母表（包含空白符号和 $\Sigma$ 中的所有符号）
- $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $q_{accept} \in Q$ 是接受状态
- $q_{reject} \in Q$ 是拒绝状态

图灵机的配置可表示为三元组 $(q, w, i)$，表示当前状态是 $q$，带上内容为 $w$，读写头位于第 $i$ 个符号上。

**定义 3.1.2**（非确定性图灵机）：非确定性图灵机的转移函数为 $\delta: Q \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma \times \{L, R\})$，即每步计算可能有多个选择。

图灵机的**时间复杂度**定义为图灵机从初始配置到停机状态所需的步数，**空间复杂度**定义为计算过程中使用的非空白带格数。

**示例**：下面是一个识别回文的图灵机的简化描述：

1. 将读写头移至最左端
2. 如果带为空，接受
3. 记住最左侧字符c，将其替换为空白符
4. 向右移动到最右侧非空白符
5. 检查该符号是否为c，若不是则拒绝
6. 将其替换为空白符，向左移动到最左侧非空白符
7. 重复步骤2

### 3.2 λ演算

λ演算是由Alonzo Church发展的形式系统，提供了一个表达计算的数学基础，特别适合函数式编程。

**定义 3.2.1**（λ项）：λ项是根据以下规则递归定义的表达式：

- 变量 $x$ 是λ项
- 如果 $M$ 是λ项，$x$ 是变量，则 $(\lambda x.M)$ 是λ项（抽象）
- 如果 $M$ 和 $N$ 是λ项，则 $(M\ N)$ 是λ项（应用）

λ演算的核心操作是β-归约：$(\lambda x.M)\ N \rightarrow M[x := N]$，表示将 $M$ 中的所有自由变量 $x$ 替换为 $N$。

**Church-Turing论题**指出λ演算和图灵机在计算能力上是等价的，即任何可被其中一个模型计算的函数都可以被另一个计算。

**示例**：在λ演算中表示自然数和基本运算：

- Church数：$0 := \lambda f.\lambda x.x$，$1 := \lambda f.\lambda x.f\ x$，$2 := \lambda f.\lambda x.f\ (f\ x)$，...
- 后继函数：$SUCC := \lambda n.\lambda f.\lambda x.f\ (n\ f\ x)$

### 3.3 布尔电路

布尔电路是另一种重要的计算模型，特别适合研究电路复杂性。

**定义 3.3.1**（布尔电路）：布尔电路是一个有向无环图，其中：

- 输入节点的入度为0
- 内部节点具有布尔门功能（AND、OR、NOT等）
- 有一个或多个输出节点

电路的**尺寸**是电路中门的数量，**深度**是从任意输入到输出的最长路径长度。

布尔电路的一个关键特性是，固定输入长度的每个布尔电路只能计算一个特定长度的函数。要计算一个语言，需要一个电路族（每个输入长度对应一个电路）。

**定义 3.3.2**（电路复杂性）：函数 $f: \{0,1\}^* \rightarrow \{0,1\}$ 的电路复杂性 $C(f)$ 是计算 $f$ 所需的最小电路尺寸。

### 3.4 随机存取机（RAM）

随机存取机（RAM）是一种更接近实际计算机的模型，允许在常数时间内访问任意内存位置。

**定义 3.4.1**（RAM模型）：RAM模型包含：

- 无限的内存单元序列，每个单元可存储一个整数
- 一组寄存器
- 一组可对寄存器和内存进行操作的指令

RAM模型中，算法复杂性通常用基本操作的数量来度量，这些操作包括算术运算、内存访问等。

**RAM与图灵机的时间复杂性比较**：

- RAM模型能够在 $O(1)$ 时间内随机访问任意内存位置
- 图灵机需要 $O(n)$ 时间移动到任意带位置
- 理论上，RAM能够在多项式时间内模拟图灵机，反之亦然

## 4. 复杂性类

复杂性类是具有相似计算资源需求的问题的集合，为我们提供了分类和理解算法效率的框架。

### 4.1 时间复杂性

时间复杂性关注的是算法执行所需的时间资源（通常以计算步骤数量度量）。

**定义 4.1.1**（时间复杂性类）：对于函数 $f: \mathbb{N} \rightarrow \mathbb{N}$，$\text{TIME}(f(n))$ 是所有能够由时间复杂度为 $O(f(n))$ 的确定性图灵机决定的语言的集合。

一些基本的时间复杂性类：

- $\text{P} = \bigcup_{k \geq 1} \text{TIME}(n^k)$：多项式时间可解决的问题
- $\text{EXPTIME} = \bigcup_{k \geq 1} \text{TIME}(2^{n^k})$：指数时间可解决的问题
- $\text{NTIME}(f(n))$：能由时间复杂度为 $O(f(n))$ 的非确定性图灵机决定的语言集合
- $\text{NP} = \bigcup_{k \geq 1} \text{NTIME}(n^k)$：非确定性多项式时间可解决的问题

**时间层次定理**：对于时间构造函数 $f$ 和 $g$，如果 $f(n) \log f(n) = o(g(n))$，则 $\text{TIME}(f(n)) \subsetneq \text{TIME}(g(n))$。

这表明更多的计算时间确实允许我们解决更多的问题，即时间资源与计算能力之间的真正层次关系。

### 4.2 空间复杂性

空间复杂性关注的是算法执行所需的内存资源。

**定义 4.2.1**（空间复杂性类）：对于函数 $f: \mathbb{N} \rightarrow \mathbb{N}$，$\text{SPACE}(f(n))$ 是所有能够由空间复杂度为 $O(f(n))$ 的确定性图灵机决定的语言的集合。

一些基本的空间复杂性类：

- $\text{L} = \text{SPACE}(\log n)$：对数空间可解决的问题
- $\text{PSPACE} = \bigcup_{k \geq 1} \text{SPACE}(n^k)$：多项式空间可解决的问题
- $\text{NSPACE}(f(n))$：能由空间复杂度为 $O(f(n))$ 的非确定性图灵机决定的语言集合
- $\text{NL} = \text{NSPACE}(\log n)$：非确定性对数空间可解决的问题

**萨维奇定理**：对于任意函数 $f(n) \geq \log n$，$\text{NSPACE}(f(n)) \subseteq \text{SPACE}(f(n)^2)$。

这一重要结果表明非确定性在空间复杂性中的能力有限，与时间复杂性的情况有显著不同。

**空间层次定理**：对于空间构造函数 $f$ 和 $g$，如果 $f(n) = o(g(n))$，则 $\text{SPACE}(f(n)) \subsetneq \text{SPACE}(g(n))$。

### 4.3 重要复杂性类的关系

复杂性类之间存在一系列包含关系，形成了复杂性理论的核心结构：

$$\text{L} \subseteq \text{NL} \subseteq \text{P} \subseteq \text{NP} \subseteq \text{PSPACE} \subseteq \text{EXPTIME}$$

已知的严格包含关系：

- $\text{L} \subsetneq \text{PSPACE}$（空间层次定理）
- $\text{P} \subsetneq \text{EXPTIME}$（时间层次定理）
- $\text{NP} \subsetneq \text{EXPTIME}$（结合前述结果）

未解决的重要关系：

- $\text{P} \stackrel{?}{=} \text{NP}$（千禧年难题之一）
- $\text{NP} \stackrel{?}{=} \text{PSPACE}$

**定理**（Immerman-Szelepcsényi）：对于任意函数 $f(n) \geq \log n$，$\text{NSPACE}(f(n)) = \text{coNSPACE}(f(n))$。

这表明非确定性空间复杂性类在补运算下是封闭的，特别是 $\text{NL} = \text{coNL}$。

## 5. P与NP问题

P vs NP问题是计算复杂性理论中最著名的未解问题，它探讨验证解的容易程度与找到解的难度之间的关系。

### 5.1 决策问题

**定义 5.1.1**（决策问题）：决策问题是只有"是"或"否"两种可能答案的问题。形式上，决策问题可以表示为语言 $L \subseteq \Sigma^*$，其中 $\Sigma$ 是有限字母表，$L$ 包含所有答案为"是"的实例。

许多优化问题和搜索问题可以转化为决策问题。例如：

- 优化问题：找到图中的最小顶点覆盖
- 对应决策问题：图 $G$ 是否存在大小不超过 $k$ 的顶点覆盖？

**定义 5.1.2**（语言的补）：语言 $L$ 的补定义为 $\overline{L} = \Sigma^* \setminus L$，即所有不属于 $L$ 的字符串的集合。

### 5.2 P类问题

**定义 5.2.1**（P类）：P（Polynomial Time）是所有可以由确定性图灵机在多项式时间内解决的决策问题的集合。形式上：

$$\text{P} = \bigcup_{k \geq 1} \text{TIME}(n^k)$$

P类包含了被认为是"高效可解"的问题。

**典型的P类问题**：

- 图的连通性判定
- 线性规划
- 最大流问题
- 最小生成树
- 2-SAT（2-可满足性问题）

**定理 5.2.2**：P类在并、交、补和多项式时间归约下封闭。

**证明**（补封闭性）：对于任何 $L \in \text{P}$，存在一个多项式时间图灵机 $M$ 判定 $L$。构造一个新的图灵机 $M'$，它在输入上模拟 $M$ 的运行，但交换接受和拒绝状态。显然，$M'$ 判定 $\overline{L}$，且时间复杂度与 $M$ 相同，因此 $\overline{L} \in \text{P}$。

### 5.3 NP类问题

**定义 5.3.1**（NP类）：NP（Nondeterministic Polynomial Time）是所有可以由非确定性图灵机在多项式时间内解决的决策问题的集合。形式上：

$$\text{NP} = \bigcup_{k \geq 1} \text{NTIME}(n^k)$$

NP类的一个等价定义：

**定义 5.3.2**（证书验证）：$L \in \text{NP}$ 当且仅当存在多项式 $p$ 和多项式时间确定性图灵机 $V$（验证器），使得对于所有 $x \in \Sigma^*$：
$$x \in L \iff \exists y \in \Sigma^* \text{ 满足 } |y| \leq p(|x|) \text{ 且 } V(x, y) = 1$$

这里 $y$ 被称为证书或见证，$V$ 被称为验证器。

**典型的NP类问题**：

- SAT（布尔可满足性问题）：给定布尔公式，是否存在一个变量赋值使其为真
- 哈密顿回路问题：给定图，是否存在经过所有顶点恰好一次的回路
- 顶点覆盖问题：给定图和整数 $k$，是否存在大小不超过 $k$ 的顶点覆盖
- 子集和问题：给定整数集合和目标值，是否存在子集和等于目标值

**定义 5.3.3**（coNP类）：coNP是所有NP问题的补问题的集合：
$$\text{coNP} = \{L | \overline{L} \in \text{NP}\}$$

**未解问题**：$\text{NP} \stackrel{?}{=} \text{coNP}$。大多数复杂性理论学者认为 $\text{NP} \neq \text{coNP}$。

### 5.4 P vs NP猜想

**P vs NP问题**：是否所有可以在多项式时间内验证解的问题都可以在多项式时间内找到解？形式上：$\text{P} \stackrel{?}{=} \text{NP}$

**已知结果**：

- $\text{P} \subseteq \text{NP}$（任何确定性算法都可以视为非确定性算法的特例）
- 如果 $\text{P} = \text{NP}$，则 $\text{NP} = \text{coNP}$

**意义**：

- 如果 $\text{P} = \text{NP}$，则所有NP问题都有多项式时间算法，包括许多基本密码学假设依赖的问题
- 这将革命性地改变计算机科学、数学和密码学
- 对于创造性活动，可能意味着"找到证明和验证证明一样容易"

**当前状态**：绝大多数理论计算机科学家相信 $\text{P} \neq \text{NP}$，但这个问题仍未解决。

## 6. NP完全性

NP完全问题是NP中最难的问题，它们在某种意义上"包含"了NP中所有问题的难度。

### 6.1 多项式时间规约

**定义 6.1.1**（多项式时间规约）：语言 $A$ 多项式时间规约到语言 $B$（记作 $A \leq_p B$）当且仅当存在一个多项式时间可计算的函数 $f: \Sigma^* \rightarrow \Sigma^*$，使得对于所有 $x \in \Sigma^*$：
$$x \in A \iff f(x) \in B$$

函数 $f$ 称为从 $A$ 到 $B$ 的规约。

**定理 6.1.2**：如果 $A \leq_p B$ 且 $B \in \text{P}$，则 $A \in \text{P}$。

**证明**：设 $f$ 是从 $A$ 到 $B$ 的多项式时间规约，$M_B$ 是判定 $B$ 的多项式时间图灵机。构造判定 $A$ 的图灵机 $M_A$：对于输入 $x$，先计算 $f(x)$，然后运行 $M_B$ 在 $f(x)$ 上，并返回其结果。由于 $f$ 和 $M_B$ 都在多项式时间内，所以 $M_A$ 也在多项式时间内。

**多项式时间规约的性质**：

- 自反性：$A \leq_p A$
- 传递性：如果 $A \leq_p B$ 且 $B \leq_p C$，则 $A \leq_p C$
- 如果 $A \leq_p B$ 且 $B \in \text{NP}$，则 $A \in \text{NP}$

### 6.2 Cook-Levin定理

**定义 6.2.1**（NP难问题）：如果对于每个 $L \in \text{NP}$，都有 $L \leq_p A$，则语言 $A$ 是NP难的。

**定义 6.2.2**（NP完全问题）：如果 $A \in \text{NP}$ 且 $A$ 是NP难的，则语言 $A$ 是NP完全的。记NP完全问题的集合为 $\text{NPC}$。

**定理 6.2.3**（Cook-Levin定理）：SAT问题是NP完全的。

**证明概述**：

1. SAT $\in$ NP：给定公式和变量赋值，可以在多项式时间内验证赋值是否使公式为真。
2. SAT是NP难的：对于任意 $L \in \text{NP}$，存在验证器 $V$ 和多项式 $p$，使得 $x \in L \iff \exists y, |y| \leq p(|x|), V(x,y) = 1$。
   构造规约 $f$，将 $x$ 映射到布尔公式 $\phi_x$，使得 $\phi_x$ 可满足当且仅当存在 $y$ 使得 $V(x,y) = 1$。
   这可以通过构造描述图灵机 $V$ 在输入 $(x,y)$ 上的计算历史的布尔公式来实现。

Cook-Levin定理的重要性：它为证明其他问题的NP完全性提供了基础。

### 6.3 经典NP完全问题

**定理 6.3.1**：如果 $A \in \text{NPC}$ 且 $A \leq_p B$ 且 $B \in \text{NP}$，则 $B \in \text{NPC}$。

这一定理为证明新问题的NP完全性提供了一个一般方法：将已知NP完全问题规约到新问题。

**经典NP完全问题**：

1. **3SAT**（3-可满足性问题）：
   - 实例：每个子句恰好包含3个文字的合取范式布尔公式
   - 问题：是否存在变量赋值使公式为真

2. **顶点覆盖**（Vertex Cover）：
   - 实例：无向图 $G = (V, E)$ 和整数 $k$
   - 问题：是否存在大小不超过 $k$ 的顶点子集，使得每条边至少有一个端点在该子集中

3. **独立集**（Independent Set）：
   - 实例：无向图 $G = (V, E)$ 和整数 $k$
   - 问题：是否存在大小至少为 $k$ 的顶点子集，使得子集中任意两个顶点间没有边

4. **团问题**（Clique）：
   - 实例：无向图 $G = (V, E)$ 和整数 $k$
   - 问题：是否存在大小至少为 $k$ 的顶点子集，使得子集中任意两个顶点间都有边

5. **哈密顿回路**（Hamiltonian Circuit）：
   - 实例：无向图 $G = (V, E)$
   - 问题：是否存在一条经过每个顶点恰好一次的回路

6. **旅行商问题**（TSP）：
   - 实例：完全加权图和整数 $k$
   - 问题：是否存在总长度不超过 $k$ 的哈密顿回路

7. **子集和**（Subset Sum）：
   - 实例：整数集合 $S$ 和目标值 $t$
   - 问题：是否存在 $S$ 的子集，其和等于 $t$

8. **划分问题**（Partition）：
   - 实例：整数集合 $S$
   - 问题：是否可以将 $S$ 划分为两个子集，使得两个子集的和相等

这些问题在各自领域中都有重要应用，但它们的NP完全性表明不太可能找到多项式时间算法来解决它们。

**定理 6.3.2**（Ladner定理）：如果 $\text{P} \neq \text{NP}$，则存在既不属于P也不是NP完全的NP问题。这类问题称为NP中间问题。

## 7. 其他复杂性类

### 7.1 协议复杂性：IP与PCP

**交互式证明系统（Interactive Proof System，IP）**允许证明者和验证者进行多轮交互，以证明某个陈述。

**定义 7.1.1**（IP复杂性类）：IP是所有具有交互式证明系统的语言的集合，其中：

- 证明者是计算能力无限的交互式图灵机
- 验证者是多项式时间概率图灵机
- 如果 $x \in L$，存在证明者策略使得验证者以概率至少 $\frac{2}{3}$ 接受
- 如果 $x \notin L$，对于任何证明者策略，验证者接受的概率最多为 $\frac{1}{3}$

**定理 7.1.2**（Shamir定理）：$\text{IP} = \text{PSPACE}$

这一惊人结果表明，交互式证明系统具有非常强大的能力，可以验证任何PSPACE问题。

**概率可验证证明（Probabilistically Checkable Proof，PCP）**是一种特殊形式的证明，验证者只需随机检查证明的少量位即可确定其正确性。

**定义 7.1.3**（PCP定理）：$\text{NP} = \text{PCP}(O(\log n), O(1))$

这意味着任何NP问题都有一个证明，验证者只需使用 $O(\log n)$ 个随机位并检查证明中常数个位，就能以高概率判断证明是否正确。

PCP定理对近似算法有重要影响，特别是为许多优化问题建立了强不可近似性结果。

### 7.2 随机化复杂性：BPP、RP与ZPP

随机化复杂性类考虑使用随机性可能提供的算法优势。

**定义 7.2.1**（BPP类）：BPP（Bounded-error Probabilistic Polynomial Time）是所有可以由多项式时间概率图灵机解决，且错误概率不超过 $\frac{1}{3}$ 的决策问题的集合。

**定义 7.2.2**（RP类）：RP（Randomized Polynomial Time）是所有可以由多项式时间概率图灵机解决，且满足：

- 如果 $x \in L$，机器接受的概率至少为 $\frac{1}{2}$
- 如果 $x \notin L$，机器接受的概率为 0

**定义 7.2.3**（ZPP类）：ZPP（Zero-error Probabilistic Polynomial Time）= RP ∩ coRP

ZPP类中的算法总是给出正确答案，但运行时间的期望是多项式的。

**关系**：$\text{P} \subseteq \text{ZPP} \subseteq \text{RP} \subseteq \text{BPP} \subseteq \text{NP}$

**主要开放问题**：$\text{BPP} \stackrel{?}{=} \text{P}$。许多研究者相信，在合理的计算复杂性假设下，随机性不会显著增加多项式时间计算的能力。

### 7.3 量子复杂性：BQP

量子计算引入了新的复杂性类，研究量子计算机可以高效解决的问题。

**定义 7.3.1**（BQP类）：BQP（Bounded-error Quantum Polynomial Time）是所有可以由多项式时间量子图灵机解决，且错误概率不超过 $\frac{1}{3}$ 的决策问题的集合。

**关系**：$\text{BPP} \subseteq \text{BQP} \subseteq \text{PSPACE}$

**量子计算的优势**：

- Shor算法可以在量子计算机上高效因式分解大整数，这意味着RSA等密码系统对量子计算机不安全
- Grover算法提供了搜索无序数据库的二次加速
- 量子计算在模拟量子系统方面可能有指数级加速

**开放问题**：$\text{BQP} \stackrel{?}{=} \text{P}$ 和 $\text{BQP} \stackrel{?}{=} \text{NP}$。大多数专家认为这些复杂性类都是不同的。

## 8. 近似算法与复杂性

对于许多NP难问题，寻找近似解是一种实用策略。近似算法复杂性理论研究这些近似解的质量界限。

### 8.1 近似比

**定义 8.1.1**（近似比）：对于最小化问题，算法 $A$ 的近似比 $\alpha$ 表示：对于所有实例 $x$，
$$\frac{A(x)}{OPT(x)} \leq \alpha$$

其中 $A(x)$ 是算法输出解的值，$OPT(x)$ 是最优解的值。对于最大化问题，分数需要倒置。

**定义 8.1.2**（近似方案）：问题的近似方案是一族算法 $\{A_\epsilon\}$，对于每个 $\epsilon > 0$，$A_\epsilon$ 是一个 $(1 + \epsilon)$-近似算法。

**定义 8.1.3**（PTAS）：如果近似方案中的每个算法 $A_\epsilon$ 的运行时间是关于输入大小的多项式，则称该方案为多项式时间近似方案（PTAS）。

**定义 8.1.4**（FPTAS）：如果近似方案中的每个算法 $A_\epsilon$ 的运行时间是关于输入大小和 $\frac{1}{\epsilon}$ 的多项式，则称该方案为完全多项式时间近似方案（FPTAS）。

### 8.2 近似方案

**例子**：背包问题的FPTAS

对于背包问题（给定物品价值和重量，以及背包容量，选择价值最大的物品子集使总重量不超过容量），存在一个FPTAS：

1. 将所有价值除以 $\frac{\epsilon \cdot v_{max}}{n}$ 并向下取整，其中 $v_{max}$ 是最大价值
2. 在新的价值体系下使用动态规划求解
3. 这给出了原问题的 $(1 + \epsilon)$ 近似解，且运行时间为 $O(\frac{n^2}{\epsilon})$

### 8.3 不可近似性结果

PCP定理导致了许多重要的不可近似性结果，表明某些问题即使近似也很难。

**定理 8.3.1**（最大团问题的不可近似性）：除非 $\text{P} = \text{NP}$，否则最大团问题不能在多项式时间内近似到任何常数因子。

**定理 8.3.2**（旅行商问题的不可近似性）：除非 $\text{P} = \text{NP}$，否则一般的旅行商问题不能在多项式时间内达到任何有限的近似比。

**定理 8.3.3**（顶点覆盖问题的不可近似性）：除非 $\text{P} = \text{NP}$，否则顶点覆盖问题不能在多项式时间内近似到优于 $1.3606$ 的比例。

这些结果表明，即使放宽到寻找近似解，许多NP难问题仍然很难处理，进一步支持了 $\text{P} \neq \text{NP}$ 的信念。
