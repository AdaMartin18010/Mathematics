# 03-证明论

## 目录

- [03-证明论](#03-证明论)
  - [目录](#目录)
  - [1. 证明论简介](#1-证明论简介)
  - [2. 核心概念](#2-核心概念)
    - [2.1 形式证明系统](#21-形式证明系统)
    - [2.2 推理规则与证明方法](#22-推理规则与证明方法)
  - [3. 主要证明系统](#3-主要证明系统)
    - [3.1 希尔伯特系统](#31-希尔伯特系统)
    - [3.2 自然演绎](#32-自然演绎)
    - [3.3 相继式演算](#33-相继式演算)
  - [4. 元理论成果](#4-元理论成果)
    - [4.1 一致性与完备性](#41-一致性与完备性)
    - [4.2 不完备性定理](#42-不完备性定理)
    - [4.3 切消定理](#43-切消定理)
  - [5. 现代发展与应用](#5-现代发展与应用)
  - [6. 本地跳转与引用](#6-本地跳转与引用)
  - [6. 代码实现示例](#6-代码实现示例)
    - [6.1 Rust实现：简单的自然演绎推理结构](#61-rust实现简单的自然演绎推理结构)
    - [6.2 Haskell实现：简单的证明树](#62-haskell实现简单的证明树)

---

## 1. 证明论简介

证明论是数理逻辑的一个分支，研究形式证明系统、推理规则、证明复杂性及其元理论性质。它分析不同证明系统的能力、结构和局限。

---

## 2. 核心概念

### 2.1 形式证明系统

- 形式语言、公理、推理规则、定理

**定义 2.1.1**（形式语言）
形式语言是一个三元组 $\mathcal{L} = (\mathcal{A}, \mathcal{F}, \mathcal{P})$，其中：

- $\mathcal{A}$ 是字母表（符号集合）
- $\mathcal{F}$ 是形成规则（合式公式的构造规则）
- $\mathcal{P}$ 是证明规则（从前提推导结论的规则）

**定义 2.1.2**（合式公式）
合式公式（well-formed formula, wff）是通过以下规则递归定义的：

1. 原子公式是合式公式
2. 如果 $\varphi$ 和 $\psi$ 是合式公式，则 $\neg\varphi$、$\varphi \land \psi$、$\varphi \lor \psi$、$\varphi \rightarrow \psi$ 是合式公式
3. 如果 $\varphi$ 是合式公式，$x$ 是变量，则 $\forall x \varphi$ 和 $\exists x \varphi$ 是合式公式

**定义 2.1.3**（形式证明）
形式证明是一个有限的公式序列 $\varphi_1, \varphi_2, \ldots, \varphi_n$，其中每个 $\varphi_i$ 要么是公理，要么是通过推理规则从前面的公式推导得出的。

### 2.2 推理规则与证明方法

- 自然演绎、归结、反证法、归纳法等

**自然演绎主要规则**：

- 合取引入/消除、析取引入/消除、蕴含引入/消除、否定引入/消除、量词引入/消除等

---

## 3. 主要证明系统

### 3.1 希尔伯特系统

- 基于公理和分离规则
- 公理模式、推理规则

### 3.2 自然演绎

- 基于引入和消除规则
- 形式化推理树结构
- 例：

**定理 3.2.1**：$\vdash A \rightarrow A$

**证明**：

1. [A]₁         假设
2. A             从1重复
3. A → A         从1-2使用→I，释放假设₁

### 3.3 相继式演算

- 基于序列和结构规则
- 结构规则、逻辑规则、切消定理

---

## 4. 元理论成果

### 4.1 一致性与完备性

- 证明系统的一致性、完备性
- 一致性证明、子公式性质

### 4.2 不完备性定理

- 哥德尔不完备性定理及其意义
- 形式系统的局限性

### 4.3 切消定理

- 相继式演算中的切消与规范化
- 子公式性质

---

## 5. 现代发展与应用

- 证明复杂性、自动定理证明、Curry-Howard同构、程序验证、证明助手等

**程序验证**：使用霍尔逻辑验证程序正确性
**类型系统**：基于逻辑的类型检查
**自动定理证明**：机器辅助证明

---

## 6. 本地跳转与引用

- 相关内容详见：[00-数理逻辑总览](00-数理逻辑总览.md)
- 交叉主题见：[04-元数学与元理论](04-元数学与元理论.md)

## 6. 代码实现示例

### 6.1 Rust实现：简单的自然演绎推理结构

```rust
// 伪代码示例：自然演绎推理树结构体
struct ProofNode {
    formula: String,
    children: Vec<ProofNode>,
    rule: String,
}

impl ProofNode {
    fn new(formula: &str, rule: &str) -> Self {
        ProofNode { formula: formula.to_string(), children: vec![], rule: rule.to_string() }
    }
    fn add_child(&mut self, child: ProofNode) {
        self.children.push(child);
    }
}
```

### 6.2 Haskell实现：简单的证明树

```haskell
-- 伪代码示例：证明树的数据结构
 data Proof = Leaf String | Node String [Proof]

-- 构造一个简单的证明树
 proofAtoA = Node "A -> A" [Leaf "A"]
```
