# 02-数理逻辑基础

## 目录

- [02-数理逻辑基础](#02-数理逻辑基础)
  - [目录](#目录)
  - [1. 引言](#1-引言)
  - [2. 形式语言](#2-形式语言)
  - [3. 语义理论](#3-语义理论)
  - [4. 证明系统](#4-证明系统)
  - [5. 完备性定理](#5-完备性定理)
  - [6. 不完备性定理](#6-不完备性定理)
  - [7. 模型论基础](#7-模型论基础)
  - [8. 递归论基础](#8-递归论基础)
  - [9. 证明论基础](#9-证明论基础)
  - [10. 应用与展望](#10-应用与展望)
  - [11. 代码实现](#11-代码实现)
  - [12. 总结](#12-总结)
  - [13. 参考文献](#13-参考文献)

---

## 1. 引言

数理逻辑是数学与逻辑的交叉学科，它使用数学方法来研究逻辑推理的有效性、数学理论的基础和数学证明的性质。数理逻辑通过建立精确的符号语言和严格的推演规则，将数学的严密性提升到新的高度。

### 1.1 数理逻辑的目标

数理逻辑的主要目标包括：

1. **精确化数学推理**：将直观的数学论证转化为无歧义的、可机械验证的形式推导
2. **研究数学基础**：探讨数学公理系统的性质，如一致性、完备性和独立性
3. **探索可计算的边界**：界定哪些问题是算法可解的，哪些是不可解的
4. **理解数学的局限性**：通过哥德尔不完备定理等深刻结果，揭示形式系统固有的局限

### 1.2 数理逻辑的方法

数理逻辑采用以下方法：

1. **形式语言**：构建包含逻辑符号和特定理论符号的精确语言
2. **形式系统**：定义公理集合和推理规则，用于从公理推导出定理
3. **语义解释**：为形式语言中的符号和公式提供明确的意义
4. **元数学**：以数学方法研究形式系统本身的性质

### 1.3 数理逻辑的主要分支

数理逻辑包含以下主要分支：

1. **模型论**：研究形式语言的语义，关注数学结构与形式语句之间的关系
2. **递归论**：研究算法的本质和极限，哪些函数是可计算的
3. **证明论**：研究形式证明的结构和性质，分析不同证明系统的能力
4. **集合论**：为整个数学提供基础框架，其公理系统本身也是数理逻辑的研究对象

## 2. 形式语言

### 2.1 命题逻辑的形式语言

**定义 2.1.1** 命题逻辑的字母表包含：
1. **命题变元**：$p, q, r, p_1, p_2, \ldots$
2. **逻辑联结词**：$\neg$（否定）、$\land$（合取）、$\lor$（析取）、$\rightarrow$（蕴含）、$\leftrightarrow$（等价）
3. **辅助符号**：左括号 $($ 和右括号 $)$

**定义 2.1.2** 命题逻辑的合式公式（wff）递归定义如下：
1. 每个命题变元都是合式公式
2. 如果 $\phi$ 是合式公式，那么 $\neg\phi$ 是合式公式
3. 如果 $\phi$ 和 $\psi$ 是合式公式，那么 $(\phi \land \psi)$、$(\phi \lor \psi)$、$(\phi \rightarrow \psi)$、$(\phi \leftrightarrow \psi)$ 都是合式公式
4. 只有通过上述规则得到的表达式才是合式公式

**示例**：
- $p$ 是合式公式
- $\neg p$ 是合式公式
- $(p \land q)$ 是合式公式
- $((p \rightarrow q) \lor \neg r)$ 是合式公式

### 2.2 一阶逻辑的形式语言

**定义 2.2.1** 一阶逻辑的字母表包含：
1. **个体变元**：$x, y, z, x_1, x_2, \ldots$
2. **个体常元**：$a, b, c, a_1, a_2, \ldots$
3. **函数符号**：$f, g, h, f_1, f_2, \ldots$
4. **谓词符号**：$P, Q, R, P_1, P_2, \ldots$
5. **逻辑联结词**：$\neg, \land, \lor, \rightarrow, \leftrightarrow$
6. **量词**：$\forall$（全称量词）、$\exists$（存在量词）
7. **等词**：$=$
8. **辅助符号**：$($ 和 $)$

**定义 2.2.2** 一阶逻辑的项递归定义如下：
1. 每个个体变元和个体常元都是项
2. 如果 $f$ 是 $n$ 元函数符号，$t_1, \ldots, t_n$ 是项，那么 $f(t_1, \ldots, t_n)$ 是项
3. 只有通过上述规则得到的表达式才是项

**定义 2.2.3** 一阶逻辑的合式公式递归定义如下：
1. 如果 $P$ 是 $n$ 元谓词符号，$t_1, \ldots, t_n$ 是项，那么 $P(t_1, \ldots, t_n)$ 是合式公式
2. 如果 $t_1$ 和 $t_2$ 是项，那么 $t_1 = t_2$ 是合式公式
3. 如果 $\phi$ 是合式公式，那么 $\neg\phi$ 是合式公式
4. 如果 $\phi$ 和 $\psi$ 是合式公式，那么 $(\phi \land \psi)$、$(\phi \lor \psi)$、$(\phi \rightarrow \psi)$、$(\phi \leftrightarrow \psi)$ 都是合式公式
5. 如果 $\phi$ 是合式公式，$x$ 是个体变元，那么 $\forall x \phi$ 和 $\exists x \phi$ 都是合式公式
6. 只有通过上述规则得到的表达式才是合式公式

**示例**：
- $P(x)$ 是合式公式
- $f(x) = y$ 是合式公式
- $\forall x (P(x) \rightarrow Q(x))$ 是合式公式
- $\exists x \forall y R(x, y)$ 是合式公式

## 3. 语义理论

### 3.1 命题逻辑的语义

**定义 3.1.1** 命题逻辑的解释是一个函数 $v: \text{Prop} \rightarrow \{0, 1\}$，其中 $\text{Prop}$ 是所有命题变元的集合。

**定义 3.1.2** 给定解释 $v$，公式 $\phi$ 的真值 $v(\phi)$ 递归定义如下：
1. 如果 $\phi$ 是命题变元 $p$，那么 $v(\phi) = v(p)$
2. $v(\neg\phi) = 1 - v(\phi)$
3. $v(\phi \land \psi) = \min(v(\phi), v(\psi))$
4. $v(\phi \lor \psi) = \max(v(\phi), v(\psi))$
5. $v(\phi \rightarrow \psi) = \max(1 - v(\phi), v(\psi))$
6. $v(\phi \leftrightarrow \psi) = 1$ 当且仅当 $v(\phi) = v(\psi)$

**定义 3.1.3** 公式 $\phi$ 是重言式（永真式），当且仅当对于所有解释 $v$，都有 $v(\phi) = 1$。

**定义 3.1.4** 公式 $\phi$ 是矛盾式（永假式），当且仅当对于所有解释 $v$，都有 $v(\phi) = 0$。

**示例**：
- $p \lor \neg p$ 是重言式
- $p \land \neg p$ 是矛盾式
- $p \rightarrow p$ 是重言式

### 3.2 一阶逻辑的语义

**定义 3.2.1** 一阶逻辑的结构 $\mathcal{A}$ 包含：
1. **论域** $A$：非空集合
2. **解释函数**：为每个常元、函数符号和谓词符号提供解释

**定义 3.2.2** 给定结构 $\mathcal{A}$ 和赋值 $s$，项 $t$ 的值 $t^{\mathcal{A}}[s]$ 递归定义如下：
1. 如果 $t$ 是变元 $x$，那么 $t^{\mathcal{A}}[s] = s(x)$
2. 如果 $t$ 是常元 $c$，那么 $t^{\mathcal{A}}[s] = c^{\mathcal{A}}$
3. 如果 $t = f(t_1, \ldots, t_n)$，那么 $t^{\mathcal{A}}[s] = f^{\mathcal{A}}(t_1^{\mathcal{A}}[s], \ldots, t_n^{\mathcal{A}}[s])$

**定义 3.2.3** 给定结构 $\mathcal{A}$ 和赋值 $s$，公式 $\phi$ 的满足关系 $\mathcal{A} \models \phi[s]$ 递归定义如下：
1. $\mathcal{A} \models P(t_1, \ldots, t_n)[s]$ 当且仅当 $(t_1^{\mathcal{A}}[s], \ldots, t_n^{\mathcal{A}}[s]) \in P^{\mathcal{A}}$
2. $\mathcal{A} \models t_1 = t_2[s]$ 当且仅当 $t_1^{\mathcal{A}}[s] = t_2^{\mathcal{A}}[s]$
3. $\mathcal{A} \models \neg\phi[s]$ 当且仅当 $\mathcal{A} \not\models \phi[s]$
4. $\mathcal{A} \models \phi \land \psi[s]$ 当且仅当 $\mathcal{A} \models \phi[s]$ 且 $\mathcal{A} \models \psi[s]$
5. $\mathcal{A} \models \phi \lor \psi[s]$ 当且仅当 $\mathcal{A} \models \phi[s]$ 或 $\mathcal{A} \models \psi[s]$
6. $\mathcal{A} \models \phi \rightarrow \psi[s]$ 当且仅当 $\mathcal{A} \not\models \phi[s]$ 或 $\mathcal{A} \models \psi[s]$
7. $\mathcal{A} \models \forall x \phi[s]$ 当且仅当对于所有 $a \in A$，$\mathcal{A} \models \phi[s(x/a)]$
8. $\mathcal{A} \models \exists x \phi[s]$ 当且仅当存在 $a \in A$，使得 $\mathcal{A} \models \phi[s(x/a)]$

**定义 3.2.4** 公式 $\phi$ 在结构 $\mathcal{A}$ 中有效，记作 $\mathcal{A} \models \phi$，当且仅当对于所有赋值 $s$，都有 $\mathcal{A} \models \phi[s]$。

## 4. 证明系统

### 4.1 自然演绎系统

**定义 4.1.1** 自然演绎系统包含以下推理规则：

**引入规则**：
- $\land I$：从 $\phi$ 和 $\psi$ 推出 $\phi \land \psi$
- $\lor I$：从 $\phi$ 推出 $\phi \lor \psi$ 或 $\psi \lor \phi$
- $\rightarrow I$：从假设 $\phi$ 推出 $\psi$ 后，可以推出 $\phi \rightarrow \psi$
- $\forall I$：从 $\phi$ 推出 $\forall x \phi$（$x$ 不在假设中自由出现）

**消去规则**：
- $\land E$：从 $\phi \land \psi$ 推出 $\phi$ 或 $\psi$
- $\lor E$：从 $\phi \lor \psi$、$\phi \rightarrow \chi$ 和 $\psi \rightarrow \chi$ 推出 $\chi$
- $\rightarrow E$：从 $\phi$ 和 $\phi \rightarrow \psi$ 推出 $\psi$
- $\forall E$：从 $\forall x \phi$ 推出 $\phi[t/x]$（$t$ 对 $x$ 在 $\phi$ 中可代入）

**示例**：
证明 $p \land q \rightarrow q \land p$：

1. 假设 $p \land q$
2. 从 1 推出 $p$（$\land E$）
3. 从 1 推出 $q$（$\land E$）
4. 从 2 和 3 推出 $q \land p$（$\land I$）
5. 从假设推出 $p \land q \rightarrow q \land p$（$\rightarrow I$）

### 4.2 希尔伯特系统

**定义 4.2.1** 希尔伯特系统包含以下公理模式：

1. $\phi \rightarrow (\psi \rightarrow \phi)$
2. $(\phi \rightarrow (\psi \rightarrow \chi)) \rightarrow ((\phi \rightarrow \psi) \rightarrow (\phi \rightarrow \chi))$
3. $(\neg\phi \rightarrow \neg\psi) \rightarrow (\psi \rightarrow \phi)$

**推理规则**：
- 分离规则：从 $\phi$ 和 $\phi \rightarrow \psi$ 推出 $\psi$

**示例**：
证明 $p \rightarrow p$：

1. $(p \rightarrow ((p \rightarrow p) \rightarrow p)) \rightarrow ((p \rightarrow (p \rightarrow p)) \rightarrow (p \rightarrow p))$（公理2）
2. $p \rightarrow ((p \rightarrow p) \rightarrow p)$（公理1）
3. $(p \rightarrow (p \rightarrow p)) \rightarrow (p \rightarrow p)$（分离规则）
4. $p \rightarrow (p \rightarrow p)$（公理1）
5. $p \rightarrow p$（分离规则）

## 5. 完备性定理

### 5.1 命题逻辑的完备性

**定理 5.1.1** 命题逻辑的完备性定理：
如果公式 $\phi$ 是重言式，那么 $\phi$ 在自然演绎系统中可证。

**证明思路**：
1. 使用真值表方法
2. 对每个赋值构造证明
3. 使用归纳法组合证明

### 5.2 一阶逻辑的完备性

**定理 5.2.1** 哥德尔完备性定理：
如果公式 $\phi$ 在语义上有效，那么 $\phi$ 在自然演绎系统中可证。

**证明思路**：
1. 构造极大一致集
2. 构造典范模型
3. 证明满足关系

**推论 5.2.1** 紧致性定理：
如果公式集 $\Gamma$ 的每个有限子集都有模型，那么 $\Gamma$ 本身也有模型。

## 6. 不完备性定理

### 6.1 第一不完备性定理

**定理 6.1.1** 哥德尔第一不完备性定理：
任何包含算术的一致形式系统都是不完备的，即存在在该系统中既不能证明也不能否定的命题。

**证明思路**：
1. 构造自指语句
2. 使用对角线方法
3. 证明该语句在系统中不可判定

### 6.2 第二不完备性定理

**定理 6.2.1** 哥德尔第二不完备性定理：
任何包含算术的一致形式系统都不能证明自身的一致性。

**证明思路**：
1. 将一致性陈述形式化
2. 使用第一不完备性定理的证明
3. 证明一致性陈述不可证

## 7. 模型论基础

### 7.1 基本概念

**定义 7.1.1** 理论 $T$ 的模型是满足 $T$ 中所有公理的结构。

**定义 7.1.2** 两个结构 $\mathcal{A}$ 和 $\mathcal{B}$ 初等等价，记作 $\mathcal{A} \equiv \mathcal{B}$，当且仅当它们满足相同的句子。

### 7.2 重要定理

**定理 7.2.1** 洛文海姆-斯科伦定理：
如果可数理论有无限模型，那么它有任何无限基数的模型。

**定理 7.2.2** 紧致性定理：
如果公式集 $\Gamma$ 的每个有限子集都有模型，那么 $\Gamma$ 本身也有模型。

## 8. 递归论基础

### 8.1 可计算性

**定义 8.1.1** 函数 $f: \mathbb{N} \rightarrow \mathbb{N}$ 是可计算的，当且仅当存在算法计算 $f$。

**定义 8.1.2** 集合 $A \subseteq \mathbb{N}$ 是可判定的，当且仅当其特征函数是可计算的。

### 8.2 图灵机

**定义 8.2.1** 图灵机包含：
1. 有限状态集
2. 有限字母表
3. 转移函数
4. 读写头
5. 无限带

**定理 8.2.1** 丘奇-图灵论题：
任何可计算的函数都可以由图灵机计算。

## 9. 证明论基础

### 9.1 切消定理

**定理 9.1.1** 切消定理：
在相继式演算中，任何证明都可以转换为无切消的证明。

### 9.2 一致性证明

**定理 9.2.1** 如果自然演绎系统是一致的，那么它不能证明矛盾。

## 10. 应用与展望

### 10.1 在数学中的应用

1. **集合论**：为数学提供基础
2. **代数**：研究代数结构
3. **分析**：研究函数和极限
4. **几何**：研究空间结构

### 10.2 在计算机科学中的应用

1. **程序验证**：证明程序的正确性
2. **人工智能**：知识表示和推理
3. **数据库**：查询语言和约束
4. **编译器**：类型检查和优化

### 10.3 在哲学中的应用

1. **数学哲学**：数学的本质和基础
2. **语言哲学**：意义和指称
3. **认知科学**：思维和推理
4. **逻辑哲学**：逻辑的本质

## 11. 代码实现

### 11.1 Rust实现

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub enum Formula {
    Atom(String),
    Not(Box<Formula>),
    And(Box<Formula>, Box<Formula>),
    Or(Box<Formula>, Box<Formula>),
    Implies(Box<Formula>, Box<Formula>),
}

impl Formula {
    pub fn evaluate(&self, interpretation: &HashMap<String, bool>) -> bool {
        match self {
            Formula::Atom(name) => *interpretation.get(name).unwrap_or(&false),
            Formula::Not(phi) => !phi.evaluate(interpretation),
            Formula::And(phi, psi) => phi.evaluate(interpretation) && psi.evaluate(interpretation),
            Formula::Or(phi, psi) => phi.evaluate(interpretation) || psi.evaluate(interpretation),
            Formula::Implies(phi, psi) => !phi.evaluate(interpretation) || psi.evaluate(interpretation),
        }
    }

    pub fn is_tautology(&self) -> bool {
        let vars = self.collect_variables();
        let mut interpretation = HashMap::new();
        self.check_all_interpretations(&vars, &mut interpretation, 0)
    }

    fn collect_variables(&self) -> Vec<String> {
        let mut vars = Vec::new();
        self.collect_vars_recursive(&mut vars);
        vars.sort();
        vars.dedup();
        vars
    }

    fn collect_vars_recursive(&self, vars: &mut Vec<String>) {
        match self {
            Formula::Atom(name) => {
                if !vars.contains(name) {
                    vars.push(name.clone());
                }
            }
            Formula::Not(phi) => phi.collect_vars_recursive(vars),
            Formula::And(phi, psi) => {
                phi.collect_vars_recursive(vars);
                psi.collect_vars_recursive(vars);
            }
            Formula::Or(phi, psi) => {
                phi.collect_vars_recursive(vars);
                psi.collect_vars_recursive(vars);
            }
            Formula::Implies(phi, psi) => {
                phi.collect_vars_recursive(vars);
                psi.collect_vars_recursive(vars);
            }
        }
    }

    fn check_all_interpretations(
        &self,
        vars: &[String],
        interpretation: &mut HashMap<String, bool>,
        index: usize,
    ) -> bool {
        if index >= vars.len() {
            return self.evaluate(interpretation);
        }

        interpretation.insert(vars[index].clone(), false);
        let result1 = self.check_all_interpretations(vars, interpretation, index + 1);
        interpretation.insert(vars[index].clone(), true);
        let result2 = self.check_all_interpretations(vars, interpretation, index + 1);

        result1 && result2
    }
}

// 示例使用
fn main() {
    // 构造公式 p -> p
    let formula = Formula::Implies(
        Box::new(Formula::Atom("p".to_string())),
        Box::new(Formula::Atom("p".to_string())),
    );

    println!("Formula: {:?}", formula);
    println!("Is tautology: {}", formula.is_tautology());

    // 构造公式 p -> q
    let formula2 = Formula::Implies(
        Box::new(Formula::Atom("p".to_string())),
        Box::new(Formula::Atom("q".to_string())),
    );

    println!("Formula2: {:?}", formula2);
    println!("Is tautology: {}", formula2.is_tautology());
}
```

### 11.2 Haskell实现

```haskell
module Logic where

import Data.Map (Map)
import qualified Data.Map as Map

-- 命题逻辑公式
data Formula = Atom String
             | Not Formula
             | And Formula Formula
             | Or Formula Formula
             | Implies Formula Formula
             deriving (Show, Eq)

-- 解释（赋值）
type Interpretation = Map String Bool

-- 求值函数
evaluate :: Formula -> Interpretation -> Bool
evaluate (Atom name) interp = Map.findWithDefault False name interp
evaluate (Not phi) interp = not (evaluate phi interp)
evaluate (And phi psi) interp = evaluate phi interp && evaluate psi interp
evaluate (Or phi psi) interp = evaluate phi interp || evaluate psi interp
evaluate (Implies phi psi) interp = not (evaluate phi interp) || evaluate psi interp

-- 收集变量
collectVariables :: Formula -> [String]
collectVariables = nub . sort . collectVars
  where
    collectVars (Atom name) = [name]
    collectVars (Not phi) = collectVars phi
    collectVars (And phi psi) = collectVars phi ++ collectVars psi
    collectVars (Or phi psi) = collectVars phi ++ collectVars psi
    collectVars (Implies phi psi) = collectVars phi ++ collectVars psi

-- 生成所有可能的解释
allInterpretations :: [String] -> [Interpretation]
allInterpretations [] = [Map.empty]
allInterpretations (var:vars) = 
  let rest = allInterpretations vars
  in [Map.insert var True interp | interp <- rest] ++
     [Map.insert var False interp | interp <- rest]

-- 检查是否为重言式
isTautology :: Formula -> Bool
isTautology phi = all (evaluate phi) (allInterpretations (collectVariables phi))

-- 检查是否为矛盾式
isContradiction :: Formula -> Bool
isContradiction phi = all (not . evaluate phi) (allInterpretations (collectVariables phi))

-- 检查是否可满足
isSatisfiable :: Formula -> Bool
isSatisfiable phi = any (evaluate phi) (allInterpretations (collectVariables phi))

-- 自然演绎系统的推理规则
data Proof = Assumption Formula
           | AndIntro Proof Proof
           | AndElim1 Proof
           | AndElim2 Proof
           | OrIntro1 Formula Proof
           | OrIntro2 Formula Proof
           | OrElim Proof Proof Proof
           | ImpliesIntro Formula Proof
           | ImpliesElim Proof Proof
           deriving (Show)

-- 证明的有效性检查
isValidProof :: Proof -> Bool
isValidProof (Assumption _) = True
isValidProof (AndIntro p1 p2) = isValidProof p1 && isValidProof p2
isValidProof (AndElim1 p) = isValidProof p
isValidProof (AndElim2 p) = isValidProof p
isValidProof (OrIntro1 _ p) = isValidProof p
isValidProof (OrIntro2 _ p) = isValidProof p
isValidProof (OrElim p1 p2 p3) = isValidProof p1 && isValidProof p2 && isValidProof p3
isValidProof (ImpliesIntro _ p) = isValidProof p
isValidProof (ImpliesElim p1 p2) = isValidProof p1 && isValidProof p2

-- 示例
example :: IO ()
example = do
  let phi = Implies (Atom "p") (Atom "p")
  putStrLn "Formula:"
  print phi
  putStrLn "Is tautology:"
  print $ isTautology phi
  
  let psi = Implies (Atom "p") (Atom "q")
  putStrLn "Formula2:"
  print psi
  putStrLn "Is tautology:"
  print $ isTautology psi
  putStrLn "Is satisfiable:"
  print $ isSatisfiable psi
```

## 12. 总结

数理逻辑作为现代数学的基础学科，为我们提供了研究数学推理和数学理论的强大工具。通过形式化方法，数理逻辑建立了严格的逻辑系统，为数学的严密性提供了保障。

**主要成就**：
1. **形式化数学推理**：建立了严格的逻辑系统
2. **数学基础研究**：为数学提供了坚实的基础
3. **可计算性理论**：界定了计算的边界
4. **不完备性发现**：揭示了形式系统的局限性

**核心概念**：
1. **形式语言**：精确的符号系统
2. **语义理论**：形式语言的意义解释
3. **证明系统**：形式推理的规则
4. **完备性定理**：语法与语义的对应
5. **不完备性定理**：形式系统的局限性

**应用领域**：
1. **数学基础**：为数学提供逻辑基础
2. **计算机科学**：程序验证、人工智能
3. **哲学研究**：数学哲学、逻辑哲学
4. **认知科学**：思维和推理研究

数理逻辑不仅是一个数学分支，更是一种思维方式，它教会我们如何用精确的语言表达思想，如何通过严格的推理建立理论，以及如何理解数学和逻辑的本质。

## 13. 参考文献

### 经典教材
1. Enderton, H. B. (2001). *A Mathematical Introduction to Logic*. Academic Press.
2. Shoenfield, J. R. (1967). *Mathematical Logic*. Addison-Wesley.
3. Boolos, G. S., Burgess, J. P., & Jeffrey, R. C. (2007). *Computability and Logic*. Cambridge University Press.

### 研究论文
1. Gödel, K. (1931). "Über formal unentscheidbare Sätze der Principia Mathematica und verwandter Systeme I". *Monatshefte für Mathematik und Physik*, 38(1), 173-198.
2. Tarski, A. (1936). "Der Wahrheitsbegriff in den formalisierten Sprachen". *Studia Philosophica*, 1, 261-405.
3. Church, A. (1936). "An Unsolvable Problem of Elementary Number Theory". *American Journal of Mathematics*, 58(2), 345-363.

### 在线资源
1. Stanford Encyclopedia of Philosophy: Mathematical Logic
2. Wolfram MathWorld: Mathematical Logic
3. Wikipedia: Mathematical Logic

### 软件工具
1. Coq: 形式化证明助手
2. Isabelle/HOL: 高阶逻辑证明助手
3. Lean: 数学证明助手

---

**相关链接**：
- [01-集合论基础](../01-集合论基础.md)
- [03-命题逻辑](../03-命题逻辑.md)
- [04-谓词逻辑](../04-谓词逻辑.md)
- [00-数学基础与逻辑总览](../00-数学基础与逻辑总览.md) 