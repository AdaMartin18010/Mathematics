<!-- 本地目录区块 -->
## 目录

- [1. 停机问题与不可计算性](#1-停机问题与不可计算性)
  - [1.1. 计算的极限](#11-计算的极限)
  - [1.2. 停机问题的定义](#12-停机问题的定义)
  - [1.3. 停机问题的不可计算性证明](#13-停机问题的不可计算性证明)
  - [1.4. 意义与启示](#14-意义与启示)

<!-- 本地知识图谱区块 -->
## 本地知识图谱

- [00-递归论总览](./00-递归论总览.md)
- [01-计算模型与丘奇-图灵论题](./01-计算模型与丘奇-图灵论题.md)
- [03-图灵度与算术层级](./03-图灵度与算术层级.md)
- [04-模型论总览](../04-模型论/00-模型论总览.md)
- [02-数学基础与逻辑总览](../00-数学基础与逻辑总览.md)

# 1. 停机问题与不可计算性

**版本**: 1.0
**日期**: 2025-07-02

---

## 1.1. 计算的极限

在确立了图灵机作为计算的通用模型之后，我们便可以提出并回答一个深刻的问题：是否存在一些定义清晰的问题，是图灵机（以及任何等价的计算模型）原则上无法解决的？

答案是肯定的。而其中最著名、最核心的例子，就是 **停机问题 (The Halting Problem)**。

## 1.2. 停机问题的定义

**问题陈述**:
> 是否存在一个通用的算法（一台图灵机）$H$，对于给定的 **任意** 一台图灵机 $M$ 的描述和 **任意** 一个输入字符串 $w$，能在有限时间内计算完成，并输出：
>
> - **"是"**: 如果 $M$ 在输入 $w$ 上运行最终会停机。
> - **"否"**: 如果 $M$ 在输入 $w$ 上运行会陷入无限循环。

**问题的编码**:
为了让一台图灵机 $H$ 能"分析"另一台图灵机 $M$，我们首先需要将 $M$ 的全部信息（状态集、符号集、转移函数等）用一个标准化的方式编码成一个有限长度的字符串，我们记这个编码为 $\langle M \rangle$。这样，$M$ 的程序本身就可以作为 $H$ 的输入数据。

因此，停机问题可以更形式化地写为：是否存在一个图灵机 $H$，能够计算函数 $h(\langle M \rangle, w)$：
\[
h(\langle M \rangle, w) =
\begin{cases}
1 & \text{如果 } M(w) \text{ 停机} \\
0 & \text{如果 } M(w) \text{ 不停机}
\end{cases}
\]

## 1.3. 停机问题的不可计算性证明

我们将使用图灵本人所用的经典 **反证法** 和 **对角线论证**。

**1. 核心假设**:
我们 **假设** 停机问题是可计算的。也就是说，存在这样一台万能的图灵机 $H$，它可以解决停机问题。

**2. 构造一个"悖论"机器**:
基于我们假设存在的 $H$，我们可以构造一台新的、行为有些"古怪"的图灵机 $D$。这台机器 $D$ 的工作流程如下：

- **输入**: $D$ 的输入是某台图灵机 $M$ 的编码 $\langle M \rangle$。
- **逻辑**:
    1. $D$ 内部调用我们假设存在的 $H$，去分析一个特殊情况：**$M$ 在以它自身的编码 $\langle M \rangle$ 为输入时，是否会停机**。即，$D$ 计算 $H(\langle M \rangle, \langle M \rangle)$。
    2. $D$ 的行为与 $H$ 的判断结果 **正好相反**：
        - 如果 $H$ 的输出是"是"（即 $M$ 在输入 $\langle M \rangle$ 时会停机），那么 $D$ 就 **故意进入一个无限循环**。
        - 如果 $H$ 的输出是"否"（即 $M$ 在输入 $\langle M \rangle$ 时会无限循环），那么 $D$ 就 **立刻停机并输出"完成"**。

**3. 导出逻辑矛盾**:
现在，最关键的一步来了。$D$ 本身也是一台图灵机，所以它也有一个编码 $\langle D \rangle$。我们将这个编码 $\langle D \rangle$ 作为输入，喂给 $D$ 自己。让我们来分析 $D(\langle D \rangle)$ 的运行情况：

- **情况一：假设 $D(\langle D \rangle)$ 最终停机了。**
  - 根据 $D$ 的构造规则（第二步的第二条），$D$ 会停机，**当且仅当** 它内部调用的 $H(\langle D \rangle, \langle D \rangle)$ 的结果是"否"（即 $D$ 在输入 $\langle D \rangle$ 时会无限循环）。
  - 这里出现了矛盾：我们假设 $D(\langle D \rangle)$ 停机，但这却要求 $D(\langle D \rangle)$ 必须是无限循环的。

- **情况二：假设 $D(\langle D \rangle)$ 陷入了无限循环。**
  - 根据 $D$ 的构造规则（第二步的第一条），$D$ 会无限循环，**当且仅当** 它内部调用的 $H(\langle D \rangle, \langle D \rangle)$ 的结果是"是"（即 $D$ 在输入 $\langle D \rangle$ 时会停机）。
  - 这里也出现了矛盾：我们假设 $D(\langle D \rangle)$ 无限循环，但这却要求 $D(\langle D \rangle)$ 必须是停机的。

**4. 最终结论**:
无论我们假设 $D(\langle D \rangle)$ 停机还是不停机，都会导出一个尖锐的逻辑矛盾。这意味着整个推理链条中，必然有一个环节是错误的。错误的根源只能是我们的 **第一步的核心假设**。

因此，那台万能的停机判定图灵机 $H$ **根本不可能存在**。停机问题是 **不可计算的 (Uncomputable)** 或 **不可判定的 (Undecidable)**。

## 1.4. 意义与启示

停机问题的不可计算性，是数学和计算机科学的一个里程碑式的发现。它首次为"算法能做什么"划下了一条清晰而不可逾越的理论边界。它告诉我们，存在一些逻辑上定义完美的问题，是任何计算设备，无论多么强大、运行多快，都永远无法解决的。

这一定理也衍生出了一系列其他不可计算问题的证明（例如，通过"归约"的方法），深刻地影响了计算理论、程序语言设计和软件工程等领域。

---
[前往下一节: 03-图灵度与算术层级.md](./03-图灵度与算术层级.md) | [返回总览](./00-递归论总览.md)
