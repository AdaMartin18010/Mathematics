# 递归论基础

## 目录

- [递归论基础](#递归论基础)
  - [目录](#目录)
  - [1. 引言](#1-引言)
  - [2. 基本概念](#2-基本概念)
    - [2.1 可计算性](#21-可计算性)
    - [2.2 算法](#22-算法)
    - [2.3 计算模型](#23-计算模型)
  - [3. 递归函数](#3-递归函数)
    - [3.1 原始递归函数](#31-原始递归函数)
    - [3.2 一般递归函数](#32-一般递归函数)
    - [3.3 μ递归函数](#33-μ递归函数)
  - [4. 图灵机](#4-图灵机)
    - [4.1 图灵机定义](#41-图灵机定义)
    - [4.2 图灵机计算](#42-图灵机计算)
    - [4.3 通用图灵机](#43-通用图灵机)
  - [5. λ演算](#5-λ演算)
    - [5.1 λ项](#51-λ项)
    - [5.2 β归约](#52-β归约)
    - [5.3 丘奇编码](#53-丘奇编码)
  - [6. 丘奇-图灵论题](#6-丘奇-图灵论题)
    - [6.1 论题内容](#61-论题内容)
    - [6.2 等价性证明](#62-等价性证明)
    - [6.3 哲学意义](#63-哲学意义)
  - [7. 不可判定性](#7-不可判定性)
    - [7.1 停机问题](#71-停机问题)
    - [7.2 对角线法](#72-对角线法)
    - [7.3 Rice定理](#73-rice定理)
  - [8. 递归可枚举性](#8-递归可枚举性)
    - [8.1 递归可枚举集](#81-递归可枚举集)
    - [8.2 递归集](#82-递归集)
    - [8.3 层次结构](#83-层次结构)
  - [9. 计算复杂性](#9-计算复杂性)
    - [9.1 时间复杂性](#91-时间复杂性)
    - [9.2 空间复杂性](#92-空间复杂性)
    - [9.3 复杂性类](#93-复杂性类)
  - [10. 应用](#10-应用)
    - [10.1 程序验证](#101-程序验证)
    - [10.2 人工智能](#102-人工智能)
    - [10.3 密码学](#103-密码学)
  - [11. 总结](#11-总结)

---

## 1. 引言

递归论（Recursion Theory），也称为可计算性理论（Computability Theory），是数理逻辑的一个重要分支，它研究算法的本质、可计算函数的性质以及计算的极限。

### 1.1 递归论的历史背景

递归论起源于20世纪30年代，由Alonzo Church、Alan Turing、Kurt Gödel等人发展。他们试图回答"什么是可计算的"这个基本问题。

**核心问题**：哪些函数是算法可计算的？哪些问题是算法可解的？

### 1.2 递归论的基本目标

1. **可计算性分析**：研究函数的可计算性
2. **算法极限**：确定计算的边界
3. **问题分类**：将问题按可解性分类
4. **计算模型**：建立等价的计算模型

## 2. 基本概念

### 2.1 可计算性

**定义 2.1.1**（可计算函数）
函数 $f: \mathbb{N}^n \rightarrow \mathbb{N}$ 是可计算的，如果存在一个算法，对于任意输入 $(x_1, \ldots, x_n)$，算法在有限步内输出 $f(x_1, \ldots, x_n)$。

**定义 2.1.2**（可判定问题）
问题 $P$ 是可判定的，如果存在算法，对于任意输入，算法在有限步内输出"是"或"否"。

**定义 2.1.3**（可枚举问题）
问题 $P$ 是可枚举的，如果存在算法，能够枚举所有答案为"是"的输入。

### 2.2 算法

**定义 2.2.1**（算法）
算法是一个有限、确定、机械的过程，它能够：
1. 接受输入
2. 执行有限步计算
3. 产生输出
4. 在有限时间内终止

**算法的性质**：
- **有限性**：算法由有限条指令组成
- **确定性**：每条指令的执行结果是唯一的
- **机械性**：算法可以机械地执行
- **终止性**：算法在有限步后终止

### 2.3 计算模型

**定义 2.3.1**（计算模型）
计算模型是描述计算过程的数学抽象，包括：
1. **图灵机**：基于状态转换的计算模型
2. **λ演算**：基于函数应用的计算模型
3. **递归函数**：基于函数递归的计算模型
4. **寄存器机**：基于寄存器操作的计算模型

## 3. 递归函数

### 3.1 原始递归函数

**定义 3.1.1**（基本函数）
基本函数包括：
1. **零函数**：$Z(x) = 0$
2. **后继函数**：$S(x) = x + 1$
3. **投影函数**：$P_i^n(x_1, \ldots, x_n) = x_i$

**定义 3.1.2**（复合）
如果 $g: \mathbb{N}^m \rightarrow \mathbb{N}$ 和 $h_1, \ldots, h_m: \mathbb{N}^n \rightarrow \mathbb{N}$ 是原始递归函数，则
$$f(x_1, \ldots, x_n) = g(h_1(x_1, \ldots, x_n), \ldots, h_m(x_1, \ldots, x_n))$$
也是原始递归函数。

**定义 3.1.3**（原始递归）
如果 $g: \mathbb{N}^n \rightarrow \mathbb{N}$ 和 $h: \mathbb{N}^{n+2} \rightarrow \mathbb{N}$ 是原始递归函数，则
$$f(x_1, \ldots, x_n, 0) = g(x_1, \ldots, x_n)$$
$$f(x_1, \ldots, x_n, y+1) = h(x_1, \ldots, x_n, y, f(x_1, \ldots, x_n, y))$$
定义的函数 $f$ 也是原始递归函数。

**示例 3.1.1**：加法函数
加法函数 $+$ 可以通过原始递归定义：
$$x + 0 = x$$
$$x + (y+1) = S(x + y)$$

**示例 3.1.2**：乘法函数
乘法函数 $\cdot$ 可以通过原始递归定义：
$$x \cdot 0 = 0$$
$$x \cdot (y+1) = x \cdot y + x$$

### 3.2 一般递归函数

**定义 3.2.1**（一般递归函数）
一般递归函数是包含原始递归函数和μ算子的函数类。

**定义 3.2.2**（μ算子）
如果 $g: \mathbb{N}^{n+1} \rightarrow \mathbb{N}$ 是函数，则μ算子定义为：
$$\mu y[g(x_1, \ldots, x_n, y) = 0] = \text{最小的} y \text{使得} g(x_1, \ldots, x_n, y) = 0$$
如果不存在这样的 $y$，则结果无定义。

**示例 3.2.1**：整数除法
整数除法可以通过μ算子定义：
$$\text{div}(x, y) = \mu z[(z+1) \cdot y > x]$$

### 3.3 μ递归函数

**定义 3.3.1**（μ递归函数）
μ递归函数是通过以下方式构造的函数：
1. 基本函数是μ递归函数
2. 复合保持μ递归性
3. 原始递归保持μ递归性
4. μ算子保持μ递归性

**定理 3.3.1**（μ递归函数的性质）
μ递归函数类在复合、原始递归和μ算子下封闭。

## 4. 图灵机

### 4.1 图灵机定义

**定义 4.1.1**（图灵机）
图灵机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, q_{\text{accept}}, q_{\text{reject}})$，其中：
- $Q$ 是有限状态集
- $\Sigma$ 是输入字母表
- $\Gamma$ 是磁带字母表，$\Sigma \subseteq \Gamma$
- $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $q_{\text{accept}} \in Q$ 是接受状态
- $q_{\text{reject}} \in Q$ 是拒绝状态

**定义 4.1.2**（图灵机配置）
图灵机的配置是一个三元组 $(q, w, i)$，其中：
- $q$ 是当前状态
- $w$ 是磁带内容
- $i$ 是读写头位置

### 4.2 图灵机计算

**定义 4.2.1**（一步计算）
配置 $(q, w, i)$ 一步计算到 $(q', w', i')$，记作 $(q, w, i) \vdash (q', w', i')$，如果：
1. $\delta(q, w_i) = (q', a, D)$
2. $w'_j = w_j$ 对于 $j \neq i$
3. $w'_i = a$
4. $i' = i + 1$ 如果 $D = R$，$i' = i - 1$ 如果 $D = L$

**定义 4.2.2**（计算）
配置序列 $C_0, C_1, \ldots$ 是计算，如果对于每个 $i$，$C_i \vdash C_{i+1}$。

**定义 4.2.3**（停机）
图灵机在配置 $(q, w, i)$ 停机，如果 $q \in \{q_{\text{accept}}, q_{\text{reject}}\}$。

### 4.3 通用图灵机

**定义 4.3.1**（通用图灵机）
通用图灵机 $U$ 是一个图灵机，它能够模拟任意图灵机的行为。

**定理 4.3.1**（通用图灵机存在性）
存在通用图灵机 $U$，对于任意图灵机 $M$ 和输入 $w$，$U$ 能够模拟 $M$ 在输入 $w$ 上的计算。

**证明思路**：
通过编码图灵机的描述和状态，构造一个能够解释和执行这些编码的图灵机。

## 5. λ演算

### 5.1 λ项

**定义 5.1.1**（λ项）
λ项递归定义如下：
1. 变量是λ项
2. 如果 $M$ 和 $N$ 是λ项，则 $(MN)$ 是λ项（应用）
3. 如果 $M$ 是λ项，$x$ 是变量，则 $(\lambda x.M)$ 是λ项（抽象）

**定义 5.1.2**（自由变量）
λ项 $M$ 的自由变量集合 $FV(M)$ 递归定义如下：
1. $FV(x) = \{x\}$
2. $FV(MN) = FV(M) \cup FV(N)$
3. $FV(\lambda x.M) = FV(M) \setminus \{x\}$

**定义 5.1.3**（替换）
$M[x := N]$ 表示将 $M$ 中所有自由出现的 $x$ 替换为 $N$。

### 5.2 β归约

**定义 5.2.1**（β归约）
β归约关系 $\rightarrow_\beta$ 定义如下：
$$(\lambda x.M)N \rightarrow_\beta M[x := N]$$

**定义 5.2.2**（β等价）
β等价关系 $=_\beta$ 是 $\rightarrow_\beta$ 的自反、对称、传递闭包。

**示例 5.2.1**：基本归约
$$(\lambda x.x)y \rightarrow_\beta y$$
$$(\lambda x.xx)(\lambda x.x) \rightarrow_\beta (\lambda x.x)(\lambda x.x) \rightarrow_\beta \lambda x.x$$

### 5.3 丘奇编码

**定义 5.3.1**（丘奇数字）
丘奇数字 $n$ 定义为：
$$n = \lambda f.\lambda x.f^n(x)$$
其中 $f^n(x)$ 表示 $f$ 应用 $n$ 次到 $x$。

**示例 5.3.1**：丘奇数字
$$0 = \lambda f.\lambda x.x$$
$$1 = \lambda f.\lambda x.fx$$
$$2 = \lambda f.\lambda x.f(fx)$$

**定义 5.3.2**（丘奇运算）
加法：$+ = \lambda m.\lambda n.\lambda f.\lambda x.mf(nfx)$
乘法：$\cdot = \lambda m.\lambda n.\lambda f.m(nf)$

## 6. 丘奇-图灵论题

### 6.1 论题内容

**丘奇-图灵论题**：
一个函数是可计算的，当且仅当它是图灵可计算的。

**等价表述**：
1. 一个函数是可计算的，当且仅当它是λ可定义的
2. 一个函数是可计算的，当且仅当它是μ递归的
3. 一个函数是可计算的，当且仅当它是寄存器机可计算的

### 6.2 等价性证明

**定理 6.2.1**（图灵机与λ演算等价）
图灵可计算函数类与λ可定义函数类相等。

**证明思路**：
1. 证明λ演算可以模拟图灵机
2. 证明图灵机可以模拟λ演算
3. 通过编码和解释建立对应关系

**定理 6.2.2**（图灵机与递归函数等价）
图灵可计算函数类与μ递归函数类相等。

**证明思路**：
1. 证明递归函数是图灵可计算的
2. 证明图灵可计算函数是递归的
3. 通过算术化建立对应关系

### 6.3 哲学意义

**丘奇-图灵论题的哲学意义**：
1. **算法概念的形式化**：为算法提供了数学定义
2. **计算极限的确定**：确定了可计算性的边界
3. **计算模型的统一**：建立了不同计算模型的等价性
4. **数学基础的深化**：为数学基础研究提供了工具

## 7. 不可判定性

### 7.1 停机问题

**定义 7.1.1**（停机问题）
停机问题是判断给定图灵机在给定输入上是否停机的问题。

**定理 7.1.1**（停机问题不可判定）
停机问题是不可判定的。

**证明**：
假设停机问题是可判定的，存在图灵机 $H$ 能够判定停机问题。构造图灵机 $D$：
1. $D$ 接受图灵机 $M$ 的编码作为输入
2. $D$ 运行 $H$ 判断 $M$ 在自身编码上是否停机
3. 如果 $H$ 输出"停机"，则 $D$ 进入无限循环
4. 如果 $H$ 输出"不停机"，则 $D$ 停机

这导致矛盾：$D$ 在自身编码上停机当且仅当 $D$ 在自身编码上不停机。

### 7.2 对角线法

**定义 7.2.1**（对角线法）
对角线法是一种证明不可判定性的技术，通过构造自指来产生矛盾。

**示例 7.2.1**：对角线法证明
考虑所有可计算函数的枚举 $f_0, f_1, f_2, \ldots$，构造函数：
$$g(n) = f_n(n) + 1$$
如果 $g$ 是可计算的，则存在 $k$ 使得 $g = f_k$，但 $g(k) = f_k(k) + 1 \neq f_k(k)$，矛盾。

### 7.3 Rice定理

**定理 7.3.1**（Rice定理）
对于任意非平凡的可计算函数性质 $P$，判断给定图灵机计算的函数是否具有性质 $P$ 的问题是不可判定的。

**证明**：
通过归约到停机问题证明。对于任意非平凡性质 $P$，可以构造归约将停机问题归约到性质 $P$ 的判定问题。

## 8. 递归可枚举性

### 8.1 递归可枚举集

**定义 8.1.1**（递归可枚举集）
集合 $A \subseteq \mathbb{N}$ 是递归可枚举的，如果存在图灵机 $M$，使得 $A = L(M)$，其中 $L(M)$ 是 $M$ 接受的语言。

**定义 8.1.2**（递归可枚举函数的图灵机）
图灵机 $M$ 计算函数 $f$，如果对于任意输入 $x$：
- 如果 $f(x)$ 有定义，则 $M$ 在输入 $x$ 上停机并输出 $f(x)$
- 如果 $f(x)$ 无定义，则 $M$ 在输入 $x$ 上不停机

### 8.2 递归集

**定义 8.2.1**（递归集）
集合 $A \subseteq \mathbb{N}$ 是递归的，如果 $A$ 和 $\mathbb{N} \setminus A$ 都是递归可枚举的。

**定理 8.2.1**（递归集的特征）
集合 $A$ 是递归的，当且仅当存在图灵机 $M$，对于任意输入 $x$：
- 如果 $x \in A$，则 $M$ 接受 $x$
- 如果 $x \notin A$，则 $M$ 拒绝 $x$

### 8.3 层次结构

**定义 8.3.1**（算术层次）
算术层次定义如下：
- $\Sigma_0^0 = \Pi_0^0 = \Delta_0^0$ 是递归集
- $\Sigma_{n+1}^0$ 是存在量词作用于 $\Pi_n^0$ 集得到的集类
- $\Pi_{n+1}^0$ 是全称量词作用于 $\Sigma_n^0$ 集得到的集类
- $\Delta_{n+1}^0 = \Sigma_{n+1}^0 \cap \Pi_{n+1}^0$

**定理 8.3.1**（层次结构的性质）
1. $\Sigma_n^0 \cup \Pi_n^0 \subseteq \Delta_{n+1}^0$
2. 对于每个 $n$，存在 $\Sigma_{n+1}^0$ 集不在 $\Pi_{n+1}^0$ 中
3. 层次结构是严格的

## 9. 计算复杂性

### 9.1 时间复杂性

**定义 9.1.1**（时间复杂性）
图灵机 $M$ 的时间复杂性函数 $T_M: \mathbb{N} \rightarrow \mathbb{N}$ 定义为：
$$T_M(n) = \max\{\text{步数} : M \text{在长度为} n \text{的输入上的计算步数}\}$$

**定义 9.1.2**（时间复杂性类）
时间复杂性类定义如下：
- $\text{TIME}(f(n))$ 是时间复杂性为 $O(f(n))$ 的问题类
- $\text{P} = \bigcup_{k \geq 1} \text{TIME}(n^k)$
- $\text{EXP} = \bigcup_{k \geq 1} \text{TIME}(2^{n^k})$

### 9.2 空间复杂性

**定义 9.2.1**（空间复杂性）
图灵机 $M$ 的空间复杂性函数 $S_M: \mathbb{N} \rightarrow \mathbb{N}$ 定义为：
$$S_M(n) = \max\{\text{使用的磁带格子数} : M \text{在长度为} n \text{的输入上的计算}\}$$

**定义 9.2.2**（空间复杂性类）
空间复杂性类定义如下：
- $\text{SPACE}(f(n))$ 是空间复杂性为 $O(f(n))$ 的问题类
- $\text{PSPACE} = \bigcup_{k \geq 1} \text{SPACE}(n^k)$
- $\text{L} = \text{SPACE}(\log n)$

### 9.3 复杂性类

**定义 9.3.1**（NP类）
$\text{NP}$ 是存在多项式时间验证器的问题类。

**定义 9.3.2**（NP完全性）
问题 $A$ 是NP完全的，如果：
1. $A \in \text{NP}$
2. 对于任意 $B \in \text{NP}$，$B \leq_p A$

**定理 9.3.1**（Cook-Levin定理）
SAT问题是NP完全的。

## 10. 应用

### 10.1 程序验证

**定义 10.1.1**（程序验证）
程序验证是证明程序满足其规约的过程。

**应用**：
递归论为程序验证提供了理论基础，特别是停机问题的不可判定性说明了程序验证的困难。

**Rust程序验证示例**：

```rust
// 使用递归论方法分析程序的可终止性
fn collatz(n: u32) -> u32 {
    if n == 1 {
        return 1;
    }
    if n % 2 == 0 {
        collatz(n / 2)
    } else {
        collatz(3 * n + 1)
    }
}

// Collatz猜想：对于所有正整数n，collatz(n)最终终止
// 这是一个未解决的数学问题，等价于停机问题的特例
```

**Haskell程序验证示例**：

```haskell
-- 使用递归论方法分析函数的可计算性
collatz :: Integer -> Integer
collatz 1 = 1
collatz n
  | even n = collatz (n `div` 2)
  | odd n  = collatz (3 * n + 1)

-- 分析：collatz函数的可终止性等价于Collatz猜想
-- 这是一个递归可枚举但可能不可判定的性质
```

### 10.2 人工智能

**定义 10.2.1**（计算智能）
计算智能是模拟人类智能的计算方法。

**应用**：
递归论为人工智能提供了理论基础，特别是：
1. **算法极限**：确定了AI能力的边界
2. **问题分类**：将AI问题按可解性分类
3. **计算模型**：为AI算法提供理论基础

### 10.3 密码学

**定义 10.3.1**（计算安全性）
密码系统的安全性基于计算复杂性假设。

**应用**：
递归论为密码学提供了理论基础，特别是：
1. **单向函数**：基于计算复杂性假设
2. **零知识证明**：基于交互式证明系统
3. **量子密码**：基于量子计算复杂性

## 11. 总结

递归论作为数理逻辑的重要分支，不仅为计算理论提供了基础，还在计算机科学、人工智能、密码学等领域有重要应用。

### 11.1 主要成就

1. **可计算性理论**：建立了可计算性的数学理论
2. **计算模型**：发展了多种等价的计算模型
3. **不可判定性**：确定了计算的极限
4. **复杂性理论**：建立了计算复杂性的理论框架

### 11.2 核心定理

1. **丘奇-图灵论题**：建立了可计算性的等价性
2. **停机问题不可判定**：确定了计算的极限
3. **Rice定理**：推广了不可判定性结果
4. **Cook-Levin定理**：建立了NP完全性理论

### 11.3 与其他分支的联系

- **与证明论**：通过可计算性研究证明的构造
- **与模型论**：通过可计算性研究模型的性质
- **与集合论**：通过可计算性研究集合的性质

### 11.4 未来发展方向

1. **量子计算**：研究量子可计算性
2. **生物计算**：研究生物计算模型
3. **量子复杂性**：研究量子计算复杂性
4. **算法博弈论**：研究计算与博弈的结合

---

**参考文献**：

1. Rogers, H. (1987). Theory of recursive functions and effective computability. MIT Press.
2. Soare, R. I. (2016). Turing computability: Theory and applications. Springer.
3. Odifreddi, P. (1989). Classical recursion theory. Elsevier.
4. Cooper, S. B. (2004). Computability theory. Chapman & Hall/CRC.

---

**相关链接**：
- [见 2.1 数理逻辑基础](../02-数理逻辑基础.md#21-基本概念)
- [见 6.1 证明论基础](../06-证明论基础.md#61-基本概念)
- [见 7.1 模型论基础](../07-模型论基础.md#71-基本概念)
- [见 3.1 命题逻辑](../03-命题逻辑.md#31-基本概念) 