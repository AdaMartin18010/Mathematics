# 递归论基础

## 目录

- [递归论基础](#递归论基础)
  - [目录](#目录)
  - [1. 引言](#1-引言)
    - [1.1 递归论的意义](#11-递归论的意义)
    - [1.2 理论框架](#12-理论框架)
  - [2. 可计算性基础](#2-可计算性基础)
    - [2.1 算法与可计算性](#21-算法与可计算性)
    - [2.2 可计算函数](#22-可计算函数)
    - [2.3 可判定性](#23-可判定性)
  - [3. 计算模型](#3-计算模型)
    - [3.1 图灵机](#31-图灵机)
    - [3.2 λ演算](#32-λ演算)
    - [3.3 递归函数](#33-递归函数)
  - [4. 丘奇-图灵论题](#4-丘奇-图灵论题)
    - [4.1 论题内容](#41-论题内容)
    - [4.2 等价性证明](#42-等价性证明)
    - [4.3 哲学意义](#43-哲学意义)
  - [5. 不可判定性](#5-不可判定性)
    - [5.1 停机问题](#51-停机问题)
    - [5.2 莱斯定理](#52-莱斯定理)
    - [5.3 其他不可判定问题](#53-其他不可判定问题)
  - [6. 递归可枚举性](#6-递归可枚举性)
    - [6.1 递归可枚举集](#61-递归可枚举集)
    - [6.2 递归集](#62-递归集)
    - [6.3 关系与性质](#63-关系与性质)
  - [7. 归约理论](#7-归约理论)
    - [7.1 图灵归约](#71-图灵归约)
    - [7.2 图灵度](#72-图灵度)
    - [7.3 度结构](#73-度结构)
  - [8. 算术层级](#8-算术层级)
    - [8.1 算术层级定义](#81-算术层级定义)
    - [8.2 层级性质](#82-层级性质)
    - [8.3 超算术层级](#83-超算术层级)
  - [9. 相对可计算性](#9-相对可计算性)
    - [9.1 神谕图灵机](#91-神谕图灵机)
    - [9.2 相对化结果](#92-相对化结果)
    - [9.3 应用](#93-应用)
  - [10. 计算复杂性基础](#10-计算复杂性基础)
    - [10.1 时间复杂性](#101-时间复杂性)
    - [10.2 空间复杂性](#102-空间复杂性)
    - [10.3 复杂性类](#103-复杂性类)
  - [11. 总结与展望](#11-总结与展望)
    - [11.1 理论总结](#111-理论总结)
    - [11.2 主要成果](#112-主要成果)
    - [11.3 未来发展方向](#113-未来发展方向)
  - [12. 参考文献](#12-参考文献)

## 1. 引言

递归论，也称为可计算性理论，是数理逻辑的核心分支之一，它研究算法的本质、范围和局限性。递归论通过建立精确的计算模型，为理解可计算性提供了理论基础。

### 1.1 递归论的意义

递归论具有以下重要意义：

1. **算法基础**：为算法概念提供精确的数学定义
2. **计算边界**：确定哪些问题是可计算的，哪些是不可计算的
3. **理论基石**：为计算机科学和人工智能提供理论基础
4. **哲学意义**：探讨计算的本质和局限性

### 1.2 理论框架

递归论建立在一个层次化的框架之上：

```text
递归论基础
├── 可计算性基础
│   ├── 算法与可计算性
│   ├── 可计算函数
│   └── 可判定性
├── 计算模型
│   ├── 图灵机
│   ├── λ演算
│   └── 递归函数
├── 丘奇-图灵论题
│   ├── 论题内容
│   ├── 等价性证明
│   └── 哲学意义
└── 不可判定性
    ├── 停机问题
    ├── 莱斯定理
    └── 其他不可判定问题
```

## 2. 可计算性基础

### 2.1 算法与可计算性

**定义 2.1.1** (算法)
算法是一个精确定义的、有限步骤的、确定性的操作序列，用于解决特定类型的问题或计算函数。

**定义 2.1.2** (机械可执行)
算法是"机械可执行的"，即可以由机器按照预定的规则自动执行。

**定义 2.1.3** (有限性)
算法必须在有限步骤内停止并给出结果。

### 2.2 可计算函数

**定义 2.2.1** (可计算函数)
函数 f: A → B 是可计算的，如果存在一个算法，对于 A 中的每个输入 a，该算法能在有限步骤内停止并输出 f(a)。

**定义 2.2.2** (部分可计算函数)
部分函数 f: A → B 是部分可计算的，如果存在一个算法，对于 A 中的每个输入 a：

- 如果 f(a) 有定义，则算法在有限步骤内停止并输出 f(a)
- 如果 f(a) 无定义，则算法不停止

**定义 2.2.3** (全函数)
如果部分可计算函数 f 对所有输入都有定义，则称 f 为全函数。

### 2.3 可判定性

**定义 2.3.1** (可判定性)
问题 P 是可判定的，如果存在一个算法，对于 P 的任何实例，该算法总能在有限步骤内停止并给出正确的"是"或"否"的答案。

**定义 2.3.2** (特征函数)
集合 A 的特征函数 χA 定义为：
χA(x) = 1 如果 x ∈ A
χA(x) = 0 如果 x ∉ A

**定理 2.3.1** (可判定性与特征函数)
集合 A 是可判定的当且仅当其特征函数 χA 是可计算的。

## 3. 计算模型

### 3.1 图灵机

**定义 3.1.1** (图灵机)
图灵机是一个七元组 M = (Q, Σ, Γ, δ, q₀, qaccept, qreject)，其中：

- Q 是有限状态集
- Σ 是输入字母表
- Γ 是纸带字母表，Σ ⊆ Γ
- δ: Q × Γ → Q × Γ × {L, R} 是转移函数
- q₀ ∈ Q 是初始状态
- qaccept ∈ Q 是接受状态
- qreject ∈ Q 是拒绝状态

**定义 3.1.2** (图灵机配置)
图灵机的配置是一个三元组 (q, w, i)，其中：

- q 是当前状态
- w 是纸带内容
- i 是读写头位置

**定义 3.1.3** (图灵机计算)
图灵机 M 在输入 w 上的计算是一个配置序列，从初始配置开始，按照转移函数 δ 进行转移，直到达到接受或拒绝状态。

**定义 3.1.4** (图灵可计算)
函数 f 是图灵可计算的，如果存在图灵机 M，使得对每个输入 x，M 在输入 x 上停机并输出 f(x)。

### 3.2 λ演算

**定义 3.2.1** (λ项)
λ项递归定义如下：

1. 变量 x 是 λ 项
2. 如果 M 和 N 是 λ 项，则 (MN) 是 λ 项（应用）
3. 如果 M 是 λ 项，x 是变量，则 (λx.M) 是 λ 项（抽象）

**定义 3.2.2** (β归约)
β归约规则：(λx.M)N → M[x := N]，其中 M[x := N] 表示将 M 中所有自由出现的 x 替换为 N。

**定义 3.2.3** (λ可定义)
函数 f 是 λ 可定义的，如果存在 λ 项 F，使得对每个输入 n，F n 归约到 f(n) 的丘奇数表示。

### 3.3 递归函数

**定义 3.3.1** (基本函数)
基本函数包括：

1. 零函数：Z(n) = 0
2. 后继函数：S(n) = n + 1
3. 投影函数：Pᵏᵢ(x₁, …, xₖ) = xᵢ

**定义 3.3.2** (复合)
如果 g: ℕᵐ → ℕ 和 h₁, …, hₘ: ℕⁿ → ℕ 是函数，则复合函数 f: ℕⁿ → ℕ 定义为：
f(x₁, …, xₙ) = g(h₁(x₁, …, xₙ), …, hₘ(x₁, …, xₙ))

**定义 3.3.3** (原始递归)
如果 g: ℕⁿ → ℕ 和 h: ℕⁿ⁺² → ℕ 是函数，则原始递归函数 f: ℕⁿ⁺¹ → ℕ 定义为：
f(0, x₁, …, xₙ) = g(x₁, …, xₙ)
f(n + 1, x₁, …, xₙ) = h(n, f(n, x₁, …, xₙ), x₁, …, xₙ)

**定义 3.3.4** (μ算子)
如果 g: ℕⁿ⁺¹ → ℕ 是函数，则 μ算子定义的函数 f: ℕⁿ → ℕ 为：
f(x₁, …, xₙ) = μy[g(y, x₁, …, xₙ) = 0] = min{y : g(y, x₁, …, xₙ) = 0}

**定义 3.3.5** (递归函数)
递归函数是从基本函数出发，通过有限次应用复合、原始递归和 μ算子得到的函数类。

## 4. 丘奇-图灵论题

### 4.1 论题内容

**论题 4.1.1** (丘奇-图灵论题)
任何直观上可被算法计算的函数都可以被图灵机计算。

**论题 4.1.2** (等价形式)
以下计算模型是等价的：

1. 图灵机
2. λ演算
3. 递归函数
4. 寄存器机
5. 其他合理的计算模型

### 4.2 等价性证明

**定理 4.2.1** (图灵机与λ演算等价)
图灵可计算函数类与λ可定义函数类相同。

**证明思路**：

1. 证明图灵机可以模拟λ演算
2. 证明λ演算可以模拟图灵机
3. 通过编码技术建立对应关系

**定理 4.2.2** (图灵机与递归函数等价)
图灵可计算函数类与递归函数类相同。

**证明思路**：

1. 证明图灵机可以计算所有递归函数
2. 证明递归函数可以模拟图灵机
3. 通过哥德尔编码建立对应关系

### 4.3 哲学意义

**观点 4.3.1** (计算本质)
丘奇-图灵论题为"计算"概念提供了精确的数学定义。

**观点 4.3.2** (经验支持)
所有已知的算法过程都已被证明是图灵可计算的。

**观点 4.3.3** (理论基石)
丘奇-图灵论题为计算机科学提供了理论基础。

## 5. 不可判定性

### 5.1 停机问题

**定义 5.1.1** (停机问题)
停机问题是判断给定图灵机 M 在给定输入 w 上是否会停机的问题。

**定理 5.1.1** (停机问题不可判定)
停机问题是不可判定的。

**证明**：

1. 假设存在图灵机 H 能解决停机问题
2. 构造图灵机 D，当输入为图灵机 M 的描述时：
   - 如果 H 判断 M(M) 停机，则 D 进入无限循环
   - 如果 H 判断 M(M) 不停机，则 D 停机
3. 考虑 D(D)：
   - 如果 D(D) 停机，则 H 判断 D(D) 不停机，矛盾
   - 如果 D(D) 不停机，则 H 判断 D(D) 停机，矛盾
4. 因此假设的 H 不存在

### 5.2 莱斯定理

**定理 5.2.1** (莱斯定理)
对于图灵机计算的函数类的任何非平凡性质，判断一个给定的图灵机是否具有该性质的问题都是不可判定的。

**定义 5.2.1** (非平凡性质)
性质 P 是非平凡的，如果有些图灵机具有该性质，有些则没有。

**证明思路**：
通过将停机问题归约到性质判定问题。

### 5.3 其他不可判定问题

**定理 5.3.1** (一阶逻辑有效性不可判定)
判断给定一阶逻辑语句是否普遍有效的问题是不可判定的。

**定理 5.3.2** (希尔伯特第十问题)
判断给定丢番图方程是否有整数解的问题是不可判定的。

## 6. 递归可枚举性

### 6.1 递归可枚举集

**定义 6.1.1** (递归可枚举集)
集合 A 是递归可枚举的，如果存在图灵机 M，使得 A = {x : M 在输入 x 上停机并接受}。

**定义 6.1.2** (部分可计算函数域)
集合 A 是递归可枚举的，如果存在部分可计算函数 f，使得 A = dom(f)。

**定理 6.1.1** (递归可枚举性等价性)
集合 A 是递归可枚举的当且仅当存在部分可计算函数 f，使得 A = dom(f)。

### 6.2 递归集

**定义 6.2.1** (递归集)
集合 A 是递归的，如果其特征函数 χA 是可计算的。

**定理 6.2.1** (递归集与递归可枚举集关系)
集合 A 是递归的当且仅当 A 和 A 的补集都是递归可枚举的。

**证明**：

1. 如果 A 是递归的，则 χA 和 χĀ 都是可计算的
2. 如果 A 和 Ā 都是递归可枚举的，则可以通过并行计算 χA 和 χĀ 来判定 x ∈ A

### 6.3 关系与性质

**定理 6.3.1** (递归可枚举集性质)

1. 递归集是递归可枚举的
2. 递归可枚举集在并集和交集下封闭
3. 递归可枚举集在投影下封闭

**定理 6.3.2** (递归集性质)

1. 递归集在补集、并集、交集下封闭
2. 递归集在布尔运算下封闭

## 7. 归约理论

### 7.1 图灵归约

**定义 7.1.1** (图灵归约)
集合 A 图灵归约到集合 B，记作 A ≤T B，如果存在神谕图灵机 M，使得 A = L(Mᴮ)。

**定义 7.1.2** (图灵等价)
集合 A 和 B 是图灵等价的，记作 A ≡T B，如果 A ≤T B 且 B ≤T A。

**定义 7.1.3** (图灵度)
集合 A 的图灵度是 [A]T = {B : B ≡T A}。

### 7.2 图灵度

**定义 7.2.1** (图灵度偏序)
图灵度上的偏序关系定义为：[A]T ≤ [B]T 当且仅当 A ≤T B。

**定义 7.2.2** (0度)
0度是可判定问题的图灵度。

**定义 7.2.3** (0'度)
0'度是停机问题的图灵度。

### 7.3 度结构

**定理 7.3.1** (度结构性质)
图灵度形成一个上格，具有：

1. 最小元素 0
2. 可数无限性
3. 稠密性
4. 具有最小上界

**定理 7.3.2** (度结构复杂性)
图灵度结构非常复杂，包含：

1. 无限反链
2. 无限链
3. 各种嵌入模式

## 8. 算术层级

### 8.1 算术层级定义

**定义 8.1.1** (Σ⁰₁集)
集合 A 是 Σ⁰₁ 的，如果存在递归关系 R，使得：
A = {x : ∃y R(x, y)}

**定义 8.1.2** (Π⁰₁集)
集合 A 是 Π⁰₁ 的，如果存在递归关系 R，使得：
A = {x : ∀y R(x, y)}

**定义 8.1.3** (Δ⁰₁集)
集合 A 是 Δ⁰₁ 的，如果 A 既是 Σ⁰₁ 又是 Π⁰₁。

**定义 8.1.4** (算术层级)
递归定义 Σ⁰ₙ₊₁、Π⁰ₙ₊₁ 和 Δ⁰ₙ₊₁：

- Σ⁰ₙ₊₁ = {A : ∃B ∈ Π⁰ₙ, A = {x : ∃y (x, y) ∈ B}}
- Π⁰ₙ₊₁ = {A : ∃B ∈ Σ⁰ₙ, A = {x : ∀y (x, y) ∈ B}}
- Δ⁰ₙ₊₁ = Σ⁰ₙ₊₁ ∩ Π⁰ₙ₊₁

### 8.2 层级性质

**定理 8.2.1** (层级包含关系)
对于所有 n ≥ 1：

1. Δ⁰ₙ ⊆ Σ⁰ₙ ⊆ Δ⁰ₙ₊₁
2. Δ⁰ₙ ⊆ Π⁰ₙ ⊆ Δ⁰ₙ₊₁
3. Σ⁰ₙ ∪ Π⁰ₙ ⊆ Δ⁰ₙ₊₁

**定理 8.2.2** (层级严格性)
对于所有 n ≥ 1：

1. Σ⁰ₙ ⊊ Δ⁰ₙ₊₁
2. Π⁰ₙ ⊊ Δ⁰ₙ₊₁
3. Δ⁰ₙ ⊊ Σ⁰ₙ 和 Δ⁰ₙ ⊊ Π⁰ₙ

### 8.3 超算术层级

**定义 8.3.1** (超算术层级)
超算术层级是算术层级的推广，使用序数作为下标。

**定义 8.3.2** (超算术集)
集合 A 是超算术的，如果存在序数 α，使得 A ∈ Σ⁰α 或 A ∈ Π⁰α。

## 9. 相对可计算性

### 9.1 神谕图灵机

**定义 9.1.1** (神谕图灵机)
神谕图灵机是具有额外查询能力的图灵机，可以询问某个集合的成员资格。

**定义 9.1.2** (神谕查询)
神谕图灵机 Mᴬ 可以询问"x ∈ A?"，并在一步内得到答案。

**定义 9.1.3** (相对可计算性)
函数 f 相对于集合 A 是可计算的，如果存在神谕图灵机 Mᴬ 计算 f。

### 9.2 相对化结果

**定理 9.2.1** (相对化不完备性)
哥德尔不完备定理可以相对化到任意神谕。

**定理 9.2.2** (相对化停机问题)
对于任意集合 A，存在相对于 A 不可判定的问题。

### 9.3 应用

**应用 9.3.1** (相对一致性)
相对可计算性用于证明理论的一致性。

**应用 9.3.2** (复杂度理论)
相对可计算性是计算复杂性理论的基础。

## 10. 计算复杂性基础

### 10.1 时间复杂性

**定义 10.1.1** (时间复杂性)
图灵机 M 的时间复杂性是函数 t: ℕ → ℕ，其中 t(n) 是 M 在所有长度为 n 的输入上的最大步数。

**定义 10.1.2** (时间复杂性类)
TIME(t(n)) = {L : 存在图灵机 M，在时间 O(t(n)) 内判定 L}

**定义 10.1.3** (P类)
P = ∪ₖ TIME(nᵏ)

### 10.2 空间复杂性

**定义 10.2.1** (空间复杂性)
图灵机 M 的空间复杂性是函数 s: ℕ → ℕ，其中 s(n) 是 M 在所有长度为 n 的输入上使用的最大工作带格子数。

**定义 10.2.2** (空间复杂性类)
SPACE(s(n)) = {L : 存在图灵机 M，在空间 O(s(n)) 内判定 L}

**定义 10.2.3** (PSPACE类)
PSPACE = ∪ₖ SPACE(nᵏ)

### 10.3 复杂性类

**定义 10.3.1** (NP类)
NP = {L : 存在多项式时间验证器 V，使得 L = {x : ∃y, |y| ≤ p(|x|), V(x, y) = 1}}

**定义 10.3.2** (NP完全)
语言 L 是 NP 完全的，如果：

1. L ∈ NP
2. 对所有 A ∈ NP，A ≤p L

**定理 10.3.1** (库克-列文定理)
SAT 是 NP 完全的。

## 11. 总结与展望

### 11.1 理论总结

递归论为计算提供了严格的数学基础，通过研究可计算性、不可判定性和计算复杂性，建立了完整的计算理论框架。

### 11.2 主要成果

1. **计算模型**：建立了多种等价的计算模型
2. **不可判定性**：证明了重要的不可判定结果
3. **归约理论**：建立了问题复杂性的比较框架
4. **复杂性理论**：为算法分析提供了理论基础

### 11.3 未来发展方向

1. **量子计算**：研究量子计算模型和复杂性
2. **生物计算**：探索生物计算的可能性
3. **超计算**：研究超越图灵机的计算模型
4. **应用扩展**：在其他学科中的应用

## 12. 参考文献

1. Rogers, H. (1987). *Theory of Recursive Functions and Effective Computability*. MIT Press.
2. Soare, R. I. (2016). *Turing Computability: Theory and Applications*. Springer.
3. Odifreddi, P. (1989). *Classical Recursion Theory*. North-Holland.
4. Cooper, S. B. (2004). *Computability Theory*. Chapman & Hall.
5. Davis, M. (1958). *Computability and Unsolvability*. McGraw-Hill.

---

**相关链接**：

- [数学基础与逻辑总览](./数学基础与逻辑总览.md)
- [模型论基础](./模型论基础.md)
- [证明论基础](./证明论基础.md)
- [形式化系统理论](../09-元数学与形式化/形式化系统理论.md)
- [可计算性理论](../09-元数学与形式化/可计算性理论.md)
