# 01-群论基础

## 目录

1. [群的基本定义](#1-群的基本定义)
2. [群的基本性质](#2-群的基本性质)
3. [子群](#3-子群)
4. [陪集与拉格朗日定理](#4-陪集与拉格朗日定理)
5. [正规子群与商群](#5-正规子群与商群)
6. [群同态](#6-群同态)
7. [群同构](#7-群同构)
8. [循环群](#8-循环群)
9. [群作用](#9-群作用)
10. [西罗定理](#10-西罗定理)
11. [有限群的结构](#11-有限群的结构)
12. [代码实现](#12-代码实现)

## 1. 群的基本定义

### 1.1 群的定义

**定义 1.1.1** (群)
一个**群**是一个有序对 $(G, *)$，其中 $G$ 是一个非空集合，$*$ 是 $G$ 上的一个二元运算，满足以下四个公理：

1. **封闭性 (Closure)**：对所有 $a, b \in G$，$a * b \in G$
2. **结合律 (Associativity)**：对所有 $a, b, c \in G$，$(a * b) * c = a * (b * c)$
3. **单位元 (Identity Element)**：存在一个元素 $e \in G$，使得对所有 $a \in G$，$a * e = e * a = a$
4. **逆元 (Inverse Element)**：对每个 $a \in G$，存在一个元素 $a^{-1} \in G$，使得 $a * a^{-1} = a^{-1} * a = e$

### 1.2 群的基本概念

**定义 1.2.1** (群的阶)

- **群的阶**：群 $G$ 中元素的个数，记作 $|G|$
- **元素的阶**：对于元素 $a \in G$，使其 $a^k = e$ 的最小正整数 $k$ 称为 $a$ 的阶，记作 $|a|$

**定义 1.2.2** (阿贝尔群)
如果一个群 $(G, *)$ 还满足交换律：对所有 $a, b \in G$，$a * b = b * a$，则称该群为**阿贝尔群**或**交换群**。

### 1.3 群的例子

**例子 1.3.1** (整数加法群)
整数集 $\mathbb{Z}$ 关于加法 $+$ 构成一个阿贝尔群 $(\mathbb{Z}, +)$：

- 单位元：$0$
- 元素 $n$ 的逆元：$-n$

**例子 1.3.2** (非零有理数乘法群)
非零有理数集 $\mathbb{Q}^*$ 关于乘法 $\times$ 构成一个阿贝尔群 $(\mathbb{Q}^*, \times)$：

- 单位元：$1$
- 元素 $\frac{p}{q}$ 的逆元：$\frac{q}{p}$

**例子 1.3.3** (对称群)
集合 $X = \{1, 2, \ldots, n\}$ 上的所有双射（置换）关于函数复合构成一个群，称为**对称群**，记作 $S_n$：

- 单位元：恒等置换 $id$
- 元素 $\sigma$ 的逆元：$\sigma^{-1}$

## 2. 群的基本性质

### 2.1 基本定理

**定理 2.1.1** (单位元的唯一性)
群中的单位元是唯一的。

**证明**：
设 $e$ 和 $e'$ 都是群 $G$ 的单位元。则：
$$e = e * e' = e'$$
因此 $e = e'$。

**定理 2.1.2** (逆元的唯一性)
群中每个元素的逆元是唯一的。

**证明**：
设 $a \in G$，$b$ 和 $c$ 都是 $a$ 的逆元。则：
$$b = b * e = b * (a * c) = (b * a) * c = e * c = c$$
因此 $b = c$。

**定理 2.1.3** (消去律)
在群中，消去律成立：

- 左消去律：若 $a * b = a * c$，则 $b = c$
- 右消去律：若 $b * a = c * a$，则 $b = c$

**证明**：
若 $a * b = a * c$，则：
$$a^{-1} * (a * b) = a^{-1} * (a * c)$$
$$(a^{-1} * a) * b = (a^{-1} * a) * c$$
$$e * b = e * c$$
$$b = c$$

右消去律的证明类似。

### 2.2 幂运算

**定义 2.2.1** (元素的幂)
对于 $a \in G$ 和 $n \in \mathbb{Z}$，定义：

- $a^0 = e$
- $a^n = a * a * \cdots * a$ ($n$ 个 $a$ 相乘)，当 $n > 0$
- $a^n = (a^{-1})^{-n}$，当 $n < 0$

**定理 2.2.2** (幂运算的性质)
对于 $a \in G$ 和 $m, n \in \mathbb{Z}$：

1. $a^m * a^n = a^{m+n}$
2. $(a^m)^n = a^{mn}$
3. $(a * b)^n = a^n * b^n$（当 $G$ 是阿贝尔群时）

## 3. 子群

### 3.1 子群的定义

**定义 3.1.1** (子群)
群 $(G, *)$ 的一个非空子集 $H$ 如果关于运算 $*$ 也构成一个群，则称 $H$ 是 $G$ 的一个**子群**，记作 $H \leq G$。

**定理 3.1.2** (子群判别法)
非空子集 $H \subseteq G$ 是 $G$ 的子群当且仅当：

1. 对所有 $a, b \in H$，$a * b \in H$（封闭性）
2. 对所有 $a \in H$，$a^{-1} \in H$（逆元封闭性）

**证明**：
必要性：显然。
充分性：

- 结合律在 $G$ 中成立，故在 $H$ 中也成立
- 设 $a \in H$，则 $a^{-1} \in H$，故 $e = a * a^{-1} \in H$
- 因此 $H$ 满足群的所有公理。

**推论 3.1.3** (简化子群判别法)
非空子集 $H \subseteq G$ 是 $G$ 的子群当且仅当对所有 $a, b \in H$，$a * b^{-1} \in H$。

### 3.2 子群的例子

**例子 3.2.1** (平凡子群)
对于任何群 $G$，$\{e\}$ 和 $G$ 本身都是 $G$ 的子群，称为**平凡子群**。

**例子 3.2.2** (整数加法群的子群)
在整数加法群 $(\mathbb{Z}, +)$ 中，所有形如 $n\mathbb{Z} = \{nk \mid k \in \mathbb{Z}\}$ 的子集都是子群。

**例子 3.2.3** (中心)
群 $G$ 的**中心**定义为：
$$Z(G) = \{x \in G \mid gx = xg \text{ 对所有 } g \in G\}$$
$Z(G)$ 是 $G$ 的一个阿贝尔子群。

## 4. 陪集与拉格朗日定理

### 4.1 陪集的定义

**定义 4.1.1** (陪集)
设 $H$ 是群 $G$ 的一个子群，$a \in G$。

- **左陪集**：$aH = \{ah \mid h \in H\}$
- **右陪集**：$Ha = \{ha \mid h \in H\}$

**定理 4.1.2** (陪集的性质)

1. $a \in aH$ 且 $a \in Ha$
2. $aH = H$ 当且仅当 $a \in H$
3. 两个左（或右）陪集要么相等，要么不相交
4. 所有左（或右）陪集与 $H$ 具有相同的基数

**证明**：

1. 因为 $e \in H$，所以 $a = ae \in aH$
2. 若 $aH = H$，则 $a = ae \in aH = H$。反之，若 $a \in H$，则对任意 $h \in H$，$ah \in H$，故 $aH \subseteq H$；对任意 $h \in H$，$h = a(a^{-1}h) \in aH$，故 $H \subseteq aH$
3. 设 $aH \cap bH \neq \emptyset$，则存在 $h_1, h_2 \in H$ 使得 $ah_1 = bh_2$，因此 $a = bh_2h_1^{-1}$，故 $aH = bh_2h_1^{-1}H = bH$
4. 映射 $H \to aH$ 定义为 $h \mapsto ah$ 是一个双射

### 4.2 拉格朗日定理

**定理 4.2.1** (拉格朗日定理)
如果 $G$ 是一个有限群，$H$ 是 $G$ 的一个子群，则 $|H|$ 整除 $|G|$。

**证明**：
$G$ 可以分解为 $H$ 的不相交左陪集的并：
$$G = \bigcup_{a \in G} aH$$
由于陪集要么相等要么不相交，且所有陪集与 $H$ 具有相同的基数，设 $[G:H]$ 表示不同左陪集的个数，则：
$$|G| = [G:H] \cdot |H|$$
因此 $|H|$ 整除 $|G|$。

**定义 4.2.2** (指数)
子群 $H$ 在 $G$ 中的左（或右）陪集的个数称为 $H$ 在 $G$ 中的**指数**，记作 $[G:H]$。

**推论 4.2.3**:

1. 有限群中任何元素的阶都整除群的阶
2. 阶为素数 $p$ 的群一定是循环群

## 5. 正规子群与商群

### 5.1 正规子群的定义

**定义 5.1.1** (正规子群)
群 $G$ 的子群 $N$ 称为**正规子群**，如果对所有 $g \in G$，$gN = Ng$，记作 $N \triangleleft G$。

**定理 5.1.2** (正规子群的等价条件)
子群 $N$ 是正规子群当且仅当对所有 $g \in G$，$gNg^{-1} \subseteq N$。

**证明**：
若 $N \triangleleft G$，则 $gN = Ng$，故 $gNg^{-1} = Ngg^{-1} = N$。
反之，若 $gNg^{-1} \subseteq N$，则 $gN \subseteq Ng$，同理 $Ng \subseteq gN$，故 $gN = Ng$。

### 5.2 商群

**定义 5.2.1** (商群)
设 $N$ 是群 $G$ 的正规子群。以 $N$ 的所有左陪集为元素构成的集合 $G/N = \{gN \mid g \in G\}$，在运算 $(aN)(bN) = (ab)N$ 下构成一个群，称为**商群**。

**定理 5.2.2** (商群的良定义性)
商群运算 $(aN)(bN) = (ab)N$ 是良定义的。

**证明**：
设 $aN = a'N$ 且 $bN = b'N$，则存在 $n_1, n_2 \in N$ 使得 $a' = an_1$，$b' = bn_2$。
由于 $N$ 是正规子群，存在 $n_3 \in N$ 使得 $n_1b = bn_3$。
因此：
$$a'b' = an_1bn_2 = abn_3n_2 \in (ab)N$$
故 $(a'b')N = (ab)N$。

**定理 5.2.3** (商群的性质)

1. $(G/N, \cdot)$ 构成一个群
2. 单位元是 $N$
3. $(aN)^{-1} = a^{-1}N$
4. 如果 $G$ 是有限群，则 $|G/N| = [G:N] = |G|/|N|$

## 6. 群同态

### 6.1 群同态的定义

**定义 6.1.1** (群同态)
设 $(G, *)$ 和 $(H, \cdot)$ 是两个群。一个映射 $\phi: G \to H$ 称为**群同态**，如果对所有 $a, b \in G$：
$$\phi(a * b) = \phi(a) \cdot \phi(b)$$

**定理 6.1.2** (群同态的基本性质)
设 $\phi: G \to H$ 是群同态，$e_G$ 和 $e_H$ 分别是 $G$ 和 $H$ 的单位元：

1. $\phi(e_G) = e_H$
2. 对所有 $a \in G$，$\phi(a^{-1}) = \phi(a)^{-1}$

**证明**：

1. $\phi(e_G) = \phi(e_G * e_G) = \phi(e_G) \cdot \phi(e_G)$，在 $H$ 中消去 $\phi(e_G)$ 得 $\phi(e_G) = e_H$
2. $e_H = \phi(e_G) = \phi(a * a^{-1}) = \phi(a) \cdot \phi(a^{-1})$，因此 $\phi(a^{-1}) = \phi(a)^{-1}$

### 6.2 核与像

**定义 6.2.1** (核与像)
设 $\phi: G \to H$ 是群同态：

- **核**：$\ker(\phi) = \{g \in G \mid \phi(g) = e_H\}$
- **像**：$\operatorname{im}(\phi) = \{\phi(g) \mid g \in G\}$

**定理 6.2.2** (核与像的性质)

1. $\ker(\phi)$ 是 $G$ 的正规子群
2. $\operatorname{im}(\phi)$ 是 $H$ 的子群

**证明**：

1. 设 $a, b \in \ker(\phi)$，则 $\phi(a * b^{-1}) = \phi(a) \cdot \phi(b)^{-1} = e_H \cdot e_H^{-1} = e_H$，故 $a * b^{-1} \in \ker(\phi)$
   对任意 $g \in G$ 和 $k \in \ker(\phi)$，$\phi(gkg^{-1}) = \phi(g) \cdot \phi(k) \cdot \phi(g)^{-1} = \phi(g) \cdot e_H \cdot \phi(g)^{-1} = e_H$，故 $gkg^{-1} \in \ker(\phi)$
2. 设 $\phi(a), \phi(b) \in \operatorname{im}(\phi)$，则 $\phi(a) \cdot \phi(b)^{-1} = \phi(a * b^{-1}) \in \operatorname{im}(\phi)$

## 7. 群同构

### 7.1 群同构的定义

**定义 7.1.1** (群同构)
一个群同态 $\phi: G \to H$ 如果是双射，则称为**群同构**。如果存在从 $G$ 到 $H$ 的同构，则称群 $G$ 与群 $H$ **同构**，记作 $G \cong H$。

**定理 7.1.2** (同构的等价条件)
群同态 $\phi: G \to H$ 是同构当且仅当：

1. $\phi$ 是群同态
2. $\ker(\phi) = \{e_G\}$（单射）
3. $\operatorname{im}(\phi) = H$（满射）

### 7.2 同构的例子

**例子 7.2.1** (指数函数同构)
指数函数 $\exp: (\mathbb{R}, +) \to (\mathbb{R}^+, \times)$ 定义为 $\exp(x) = e^x$ 是一个群同构：

- 同态性：$\exp(x + y) = e^{x+y} = e^x \cdot e^y = \exp(x) \cdot \exp(y)$
- 单射性：若 $e^x = e^y$，则 $x = y$
- 满射性：对任意 $z \in \mathbb{R}^+$，存在 $x = \ln(z) \in \mathbb{R}$ 使得 $e^x = z$

**例子 7.2.2** (循环群同构)
任何 $n$ 阶循环群都同构于 $(\mathbb{Z}_n, +)$，任何无限循环群都同构于 $(\mathbb{Z}, +)$。

## 8. 循环群

### 8.1 循环群的定义

**定义 8.1.1** (循环群)
如果一个群 $G$ 可以由其某个元素 $a$ 生成，即 $G = \{a^n \mid n \in \mathbb{Z}\}$，则称 $G$ 是一个**循环群**，$a$ 称为**生成元**。

**定理 8.1.2** (循环群的结构)

1. 任何循环群都是阿贝尔群
2. 任何 $n$ 阶循环群同构于 $(\mathbb{Z}_n, +)$
3. 任何无限循环群同构于 $(\mathbb{Z}, +)$

**证明**：

1. 对任意 $a^m, a^n \in G$，$a^m \cdot a^n = a^{m+n} = a^{n+m} = a^n \cdot a^m$
2. 设 $G = \langle a \rangle$ 且 $|G| = n$，则映射 $\phi: \mathbb{Z}_n \to G$ 定义为 $\phi(k) = a^k$ 是同构
3. 映射 $\phi: \mathbb{Z} \to G$ 定义为 $\phi(k) = a^k$ 是同构

### 8.2 循环群的子群

**定理 8.2.1** (循环群的子群)
循环群的任何子群都是循环群。

**证明**：
设 $G = \langle a \rangle$ 是循环群，$H$ 是 $G$ 的子群。
如果 $H = \{e\}$，则 $H = \langle e \rangle$。
否则，设 $m$ 是使得 $a^m \in H$ 的最小正整数，则 $H = \langle a^m \rangle$。

## 9. 群作用

### 9.1 群作用的定义

**定义 9.1.1** (群作用)
群 $G$ 在集合 $X$ 上的一个**左作用**是一个映射 $\cdot: G \times X \to X$，记作 $(g, x) \mapsto g \cdot x$，满足：

1. $e \cdot x = x$ 对所有 $x \in X$
2. $(gh) \cdot x = g \cdot (h \cdot x)$ 对所有 $g, h \in G, x \in X$

**定义 9.1.2** (轨道与稳定集)
设 $G$ 作用在集合 $X$ 上：

- **轨道**：元素 $x \in X$ 的轨道是 $\operatorname{Orb}_G(x) = G \cdot x = \{g \cdot x \mid g \in G\}$
- **稳定集**：元素 $x \in X$ 的稳定集是 $\operatorname{Stab}_G(x) = \{g \in G \mid g \cdot x = x\}$

**定理 9.1.3** (轨道-稳定集定理)
对于群 $G$ 在集合 $X$ 上的任一作用和任一 $x \in X$：
$$|\operatorname{Orb}_G(x)| = [G : \operatorname{Stab}_G(x)]$$

### 9.2 群作用的例子

**例子 9.2.1** (左乘作用)
群 $G$ 通过左乘作用在自身元素集合上：$g \cdot h = gh$。

**例子 9.2.2** (共轭作用)
群 $G$ 通过共轭作用在自身元素集合上：$g \cdot h = ghg^{-1}$。

**例子 9.2.3** (凯莱定理)
任何群 $G$ 都同构于其自身上的某个置换群。

## 10. 西罗定理

### 10.1 西罗定理的陈述

**定理 10.1.1** (西罗第一定理)
设 $G$ 是一个有限群，$|G| = p^n m$，其中 $p$ 是素数，$n \geq 1$ 且 $p$ 不整除 $m$。则 $G$ 至少有一个阶为 $p^n$ 的子群。

**定理 10.1.2** (西罗第二定理)
$G$ 的所有西罗 $p$-子群都是相互共轭的。

**定理 10.1.3** (西罗第三定理)
设 $n_p$ 是 $G$ 中西罗 $p$-子群的个数，则：

1. $n_p$ 整除 $m$
2. $n_p \equiv 1 \pmod{p}$

### 10.2 西罗定理的应用

**例子 10.2.1**
阶为 $pq$ 的群（其中 $p, q$ 是不同的素数）要么是循环群，要么是西罗 $p$-子群和西罗 $q$-子群的半直积。

## 11. 有限群的结构

### 11.1 单群

**定义 11.1.1** (单群)
一个非平凡群，其正规子群只有它自身和平凡子群 $\{e\}$，称为**单群**。

**定理 11.1.2** (有限单群分类)
所有有限单群包括：

1. 循环素数阶群 $\mathbb{Z}_p$
2. 阶 $n \geq 5$ 的交错群 $A_n$
3. 16族李型单群
4. 26个散在单群

### 11.2 可解群

**定义 11.2.1** (可解群)
如果群 $G$ 有一个正规列，使得所有商群都是阿贝尔群，则称 $G$ 是**可解群**。

**定理 11.2.2** (伽罗瓦理论)
一个多项式方程能用根式解当且仅当其伽罗瓦群是可解群。

## 12. 代码实现

### 12.1 Rust实现

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub struct Group {
    elements: Vec<String>,
    operation: HashMap<(String, String), String>,
    identity: String,
}

impl Group {
    pub fn new(elements: Vec<String>, operation: HashMap<(String, String), String>, identity: String) -> Self {
        Group { elements, operation, identity }
    }
    
    pub fn order(&self) -> usize {
        self.elements.len()
    }
    
    pub fn identity(&self) -> &String {
        &self.identity
    }
    
    pub fn multiply(&self, a: &str, b: &str) -> Option<&String> {
        self.operation.get(&(a.to_string(), b.to_string()))
    }
    
    pub fn inverse(&self, a: &str) -> Option<&String> {
        for element in &self.elements {
            if self.multiply(a, element) == Some(&self.identity) {
                return Some(element);
            }
        }
        None
    }
    
    pub fn is_abelian(&self) -> bool {
        for a in &self.elements {
            for b in &self.elements {
                if self.multiply(a, b) != self.multiply(b, a) {
                    return false;
                }
            }
        }
        true
    }
    
    pub fn subgroup(&self, elements: Vec<String>) -> Option<Group> {
        // 检查子群条件
        for a in &elements {
            for b in &elements {
                if let Some(ab) = self.multiply(a, b) {
                    if !elements.contains(ab) {
                        return None;
                    }
                } else {
                    return None;
                }
            }
        }
        
        // 构造子群的运算表
        let mut sub_operation = HashMap::new();
        for a in &elements {
            for b in &elements {
                if let Some(ab) = self.multiply(a, b) {
                    sub_operation.insert((a.clone(), b.clone()), ab.clone());
                }
            }
        }
        
        Some(Group::new(elements, sub_operation, self.identity.clone()))
    }
}

// 循环群构造
pub fn cyclic_group(n: usize) -> Group {
    let mut elements = Vec::new();
    let mut operation = HashMap::new();
    
    for i in 0..n {
        elements.push(i.to_string());
    }
    
    for i in 0..n {
        for j in 0..n {
            let result = (i + j) % n;
            operation.insert((i.to_string(), j.to_string()), result.to_string());
        }
    }
    
    Group::new(elements, operation, "0".to_string())
}

// 对称群构造
pub fn symmetric_group(n: usize) -> Group {
    // 这里简化实现，实际需要生成所有置换
    let mut elements = Vec::new();
    let mut operation = HashMap::new();
    
    // 生成所有置换（简化版本）
    for i in 0..n {
        elements.push(i.to_string());
    }
    
    // 构造运算表（简化）
    for i in 0..n {
        for j in 0..n {
            operation.insert((i.to_string(), j.to_string()), ((i + j) % n).to_string());
        }
    }
    
    Group::new(elements, operation, "0".to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_cyclic_group() {
        let g = cyclic_group(4);
        assert_eq!(g.order(), 4);
        assert_eq!(g.identity(), "0");
        assert!(g.is_abelian());
        
        assert_eq!(g.multiply("1", "2"), Some(&"3".to_string()));
        assert_eq!(g.multiply("2", "3"), Some(&"1".to_string()));
    }
    
    #[test]
    fn test_subgroup() {
        let g = cyclic_group(6);
        let h = g.subgroup(vec!["0".to_string(), "2".to_string(), "4".to_string()]);
        assert!(h.is_some());
        
        let h = h.unwrap();
        assert_eq!(h.order(), 3);
        assert!(h.is_abelian());
    }
}
```

### 12.2 Haskell实现

```haskell
import Data.Map (Map)
import qualified Data.Map as Map
import Data.List (nub, sort)

-- 群的定义
data Group a = Group {
    elements :: [a],
    operation :: Map (a, a) a,
    identity :: a
} deriving (Show, Eq)

-- 群的基本操作
order :: Group a -> Int
order = length . elements

isElement :: (Eq a) => Group a -> a -> Bool
isElement g x = x `elem` elements g

multiply :: (Ord a) => Group a -> a -> a -> Maybe a
multiply g a b = Map.lookup (a, b) (operation g)

inverse :: (Eq a, Ord a) => Group a -> a -> Maybe a
inverse g a = find (\x -> multiply g a x == Just (identity g)) (elements g)
  where
    find _ [] = Nothing
    find p (x:xs) = if p x then Just x else find p xs

isAbelian :: (Ord a) => Group a -> Bool
isAbelian g = all (\a -> all (\b -> multiply g a b == multiply g b a) (elements g)) (elements g)

-- 子群检查
isSubgroup :: (Eq a, Ord a) => Group a -> [a] -> Bool
isSubgroup g subset = 
    all (`elem` subset) subset &&  -- 封闭性
    all (\a -> maybe False (`elem` subset) (inverse g a)) subset  -- 逆元封闭性

-- 陪集计算
leftCoset :: (Ord a) => Group a -> [a] -> a -> [a]
leftCoset g h a = nub [fromJust (multiply g a h) | h <- h]
  where
    fromJust (Just x) = x
    fromJust Nothing = error "Invalid operation"

rightCoset :: (Ord a) => Group a -> [a] -> a -> [a]
rightCoset g h a = nub [fromJust (multiply g h a) | h <- h]
  where
    fromJust (Just x) = x
    fromJust Nothing = error "Invalid operation"

-- 循环群构造
cyclicGroup :: Int -> Group Int
cyclicGroup n = Group {
    elements = [0..n-1],
    operation = Map.fromList [((i, j), (i + j) `mod` n) | i <- [0..n-1], j <- [0..n-1]],
    identity = 0
}

-- 群同态
data GroupHomomorphism a b = GroupHomomorphism {
    domain :: Group a,
    codomain :: Group b,
    mapping :: a -> b
}

isHomomorphism :: (Ord a, Ord b) => GroupHomomorphism a b -> Bool
isHomomorphism hom = all (\a -> all (\b -> 
    let f = mapping hom
    in multiply (codomain hom) (f a) (f b) == fmap f (multiply (domain hom) a b)
    ) (elements (domain hom))) (elements (domain hom))

-- 群作用
type GroupAction g x = g -> x -> x

isGroupAction :: (Eq g, Eq x) => Group g -> GroupAction g x -> [x] -> Bool
isGroupAction g act xs = 
    all (\x -> act (identity g) x == x) xs &&  -- 单位元作用
    all (\g1 -> all (\g2 -> all (\x -> 
        act (fromJust (multiply g g1 g2)) x == act g1 (act g2 x)
        ) xs) (elements g)) (elements g)
  where
    fromJust (Just x) = x
    fromJust Nothing = error "Invalid operation"

-- 轨道计算
orbit :: (Eq g, Eq x) => Group g -> GroupAction g x -> x -> [x]
orbit g act x = nub [act g' x | g' <- elements g]

-- 稳定集计算
stabilizer :: (Eq g, Eq x) => Group g -> GroupAction g x -> x -> [g]
stabilizer g act x = [g' | g' <- elements g, act g' x == x]

-- 测试函数
testCyclicGroup :: IO ()
testCyclicGroup = do
    let g = cyclicGroup 4
    putStrLn $ "Cyclic group of order 4: " ++ show g
    putStrLn $ "Order: " ++ show (order g)
    putStrLn $ "Is abelian: " ++ show (isAbelian g)
    putStrLn $ "2 * 3 = " ++ show (multiply g 2 3)
    putStrLn $ "Inverse of 2: " ++ show (inverse g 2)

testSubgroup :: IO ()
testSubgroup = do
    let g = cyclicGroup 6
    let h = [0, 2, 4]
    putStrLn $ "Is {0,2,4} a subgroup of Z6: " ++ show (isSubgroup g h)
    
    let coset = leftCoset g h 1
    putStrLn $ "Left coset of 1: " ++ show coset

main :: IO ()
main = do
    testCyclicGroup
    putStrLn ""
    testSubgroup
```

## 总结

群论是抽象代数的核心分支，它研究对称性和变换的数学结构。本章介绍了群的基本概念、性质和各种重要定理，包括：

1. **基本概念**：群的定义、阿贝尔群、群的阶
2. **基本性质**：单位元和逆元的唯一性、消去律、幂运算
3. **子群理论**：子群的定义、判别法、陪集、拉格朗日定理
4. **正规子群与商群**：正规子群的定义、商群的构造
5. **同态理论**：群同态、核与像、群同构
6. **特殊群**：循环群、群作用、西罗定理
7. **结构理论**：有限群的结构、单群、可解群

群论不仅在纯数学中有重要应用，在物理学、化学、计算机科学等领域也有广泛应用。通过代码实现，我们可以更好地理解和验证群论中的各种概念和定理。
