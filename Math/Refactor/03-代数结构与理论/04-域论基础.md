# åŸŸè®ºåŸºç¡€

## ç›®å½•

- [åŸŸè®ºåŸºç¡€](#åŸŸè®ºåŸºç¡€)
  - [ç›®å½•](#ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 åŸŸçš„å®šä¹‰](#11-åŸŸçš„å®šä¹‰)
    - [1.2 åŸŸçš„åŸºæœ¬æ€§è´¨](#12-åŸŸçš„åŸºæœ¬æ€§è´¨)
    - [1.3 åŸŸçš„ç±»å‹](#13-åŸŸçš„ç±»å‹)
  - [2. åŸŸæ‰©å¼ ç†è®º](#2-åŸŸæ‰©å¼ ç†è®º)
    - [2.1 åŸŸæ‰©å¼ çš„å®šä¹‰](#21-åŸŸæ‰©å¼ çš„å®šä¹‰)
    - [2.2 ä»£æ•°æ‰©å¼ ](#22-ä»£æ•°æ‰©å¼ )
    - [2.3 è¶…è¶Šæ‰©å¼ ](#23-è¶…è¶Šæ‰©å¼ )
    - [2.4 æœ‰é™æ‰©å¼ ](#24-æœ‰é™æ‰©å¼ )
  - [3. ä¼½ç½—ç“¦ç†è®º](#3-ä¼½ç½—ç“¦ç†è®º)
    - [3.1 ä¼½ç½—ç“¦ç¾¤](#31-ä¼½ç½—ç“¦ç¾¤)
    - [3.2 ä¼½ç½—ç“¦å¯¹åº”](#32-ä¼½ç½—ç“¦å¯¹åº”)
    - [3.3 ä¼½ç½—ç“¦åŸºæœ¬å®šç†](#33-ä¼½ç½—ç“¦åŸºæœ¬å®šç†)
  - [4. æœ‰é™åŸŸ](#4-æœ‰é™åŸŸ)
    - [4.1 æœ‰é™åŸŸçš„å­˜åœ¨æ€§](#41-æœ‰é™åŸŸçš„å­˜åœ¨æ€§)
    - [4.2 æœ‰é™åŸŸçš„ç»“æ„](#42-æœ‰é™åŸŸçš„ç»“æ„)
    - [4.3 æœ‰é™åŸŸçš„åº”ç”¨](#43-æœ‰é™åŸŸçš„åº”ç”¨)
  - [5. ä»£æ•°é—­åŸŸ](#5-ä»£æ•°é—­åŸŸ)
    - [5.1 ä»£æ•°é—­åŸŸçš„å®šä¹‰](#51-ä»£æ•°é—­åŸŸçš„å®šä¹‰)
    - [5.2 ä»£æ•°åŸºæœ¬å®šç†](#52-ä»£æ•°åŸºæœ¬å®šç†)
    - [5.3 ä»£æ•°é—­åŒ…](#53-ä»£æ•°é—­åŒ…)
  - [6. å±€éƒ¨åŸŸ](#6-å±€éƒ¨åŸŸ)
    - [6.1 å±€éƒ¨åŸŸçš„å®šä¹‰](#61-å±€éƒ¨åŸŸçš„å®šä¹‰)
    - [6.2 pè¿›æ•°åŸŸ](#62-pè¿›æ•°åŸŸ)
    - [6.3 å±€éƒ¨åŸŸçš„åº”ç”¨](#63-å±€éƒ¨åŸŸçš„åº”ç”¨)
  - [7. é‡è¦å®šç†](#7-é‡è¦å®šç†)
    - [7.1 é˜¿å»·-æ–½èµ–å°”å®šç†](#71-é˜¿å»·-æ–½èµ–å°”å®šç†)
    - [7.2 å…‹é²å°”å®šç†](#72-å…‹é²å°”å®šç†)
    - [7.3 è¯ºä¼Šæ›¼å®šç†](#73-è¯ºä¼Šæ›¼å®šç†)
  - [8. åº”ç”¨ä¸è”ç³»](#8-åº”ç”¨ä¸è”ç³»)
    - [8.1 ä¸æ•°è®ºçš„è”ç³»](#81-ä¸æ•°è®ºçš„è”ç³»)
    - [8.2 ä¸å‡ ä½•çš„è”ç³»](#82-ä¸å‡ ä½•çš„è”ç³»)
    - [8.3 ä¸è®¡ç®—æœºç§‘å­¦çš„è”ç³»](#83-ä¸è®¡ç®—æœºç§‘å­¦çš„è”ç³»)
  - [9. ä»£ç å®ç°](#9-ä»£ç å®ç°)
    - [9.1 Rustå®ç°](#91-rustå®ç°)
    - [9.2 Haskellå®ç°](#92-haskellå®ç°)

---

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 åŸŸçš„å®šä¹‰

**å®šä¹‰ 1.1.1 (åŸŸ)**  
åŸŸæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ (F, +, Â·)ï¼Œå…¶ä¸­ï¼š
- F æ˜¯ä¸€ä¸ªéç©ºé›†åˆ
- + : F Ã— F â†’ F æ˜¯åŠ æ³•è¿ç®—
- Â· : F Ã— F â†’ F æ˜¯ä¹˜æ³•è¿ç®—

æ»¡è¶³ä»¥ä¸‹å…¬ç†ï¼š

**åŠ æ³•å…¬ç†**ï¼š
1. ç»“åˆå¾‹ï¼šâˆ€a,b,câˆˆF, (a + b) + c = a + (b + c)
2. äº¤æ¢å¾‹ï¼šâˆ€a,bâˆˆF, a + b = b + a
3. é›¶å…ƒï¼šâˆƒ0âˆˆF, âˆ€aâˆˆF, 0 + a = a + 0 = a
4. è´Ÿå…ƒï¼šâˆ€aâˆˆF, âˆƒ(-a)âˆˆF, a + (-a) = (-a) + a = 0

**ä¹˜æ³•å…¬ç†**ï¼š
1. ç»“åˆå¾‹ï¼šâˆ€a,b,câˆˆF, (a Â· b) Â· c = a Â· (b Â· c)
2. äº¤æ¢å¾‹ï¼šâˆ€a,bâˆˆF, a Â· b = b Â· a
3. å•ä½å…ƒï¼šâˆƒ1âˆˆF, âˆ€aâˆˆF, 1 Â· a = a Â· 1 = a
4. é€†å…ƒï¼šâˆ€aâˆˆF\{0}, âˆƒaâ»Â¹âˆˆF, a Â· aâ»Â¹ = aâ»Â¹ Â· a = 1

**åˆ†é…å¾‹**ï¼š
1. âˆ€a,b,câˆˆF, a Â· (b + c) = a Â· b + a Â· c

**éé›¶å…ƒæ¡ä»¶**ï¼š
1. 0 â‰  1

**è®°å·çº¦å®š**ï¼š
- é€šå¸¸çœç•¥ä¹˜æ³•ç¬¦å·ï¼Œå†™ä¸º ab è€Œä¸æ˜¯ a Â· b
- åŠ æ³•ç¾¤ (F, +) ç§°ä¸ºåŸŸçš„åŠ æ³•ç¾¤
- ä¹˜æ³•ç¾¤ (F\{0}, Â·) ç§°ä¸ºåŸŸçš„ä¹˜æ³•ç¾¤

### 1.2 åŸŸçš„åŸºæœ¬æ€§è´¨

**å‘½é¢˜ 1.2.1**  
è®¾ F æ˜¯åŸŸï¼Œåˆ™ï¼š
1. é›¶å…ƒæ˜¯å”¯ä¸€çš„
2. å•ä½å…ƒæ˜¯å”¯ä¸€çš„
3. æ¯ä¸ªå…ƒç´ çš„è´Ÿå…ƒæ˜¯å”¯ä¸€çš„
4. æ¯ä¸ªéé›¶å…ƒç´ çš„é€†å…ƒæ˜¯å”¯ä¸€çš„
5. âˆ€aâˆˆF, 0a = a0 = 0
6. âˆ€a,bâˆˆF, (-a)b = a(-b) = -(ab)
7. âˆ€a,bâˆˆF, (-a)(-b) = ab
8. âˆ€a,bâˆˆF, a â‰  0, b â‰  0 â‡’ ab â‰  0

**è¯æ˜**ï¼š
1-4. å”¯ä¸€æ€§è¯æ˜ä¸ç¾¤è®ºä¸­ç±»ä¼¼
5. 0a = (0 + 0)a = 0a + 0aï¼Œä¸¤è¾¹åŠ ä¸Š -(0a) å¾— 0 = 0a
6. (-a)b + ab = (-a + a)b = 0b = 0ï¼Œæ‰€ä»¥ (-a)b = -(ab)
7. (-a)(-b) = -(a(-b)) = -(-(ab)) = ab
8. å¦‚æœ ab = 0ï¼Œa â‰  0ï¼Œåˆ™ b = aâ»Â¹ab = aâ»Â¹0 = 0

### 1.3 åŸŸçš„ç±»å‹

**å®šä¹‰ 1.3.1 (ç‰¹å¾)**  
åŸŸ F çš„ç‰¹å¾å®šä¹‰ä¸ºï¼š
- å¦‚æœå­˜åœ¨æ­£æ•´æ•° n ä½¿å¾— nÂ·1 = 0ï¼Œåˆ™ç‰¹å¾æ˜¯æœ€å°çš„è¿™æ ·çš„ n
- å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„ nï¼Œåˆ™ç‰¹å¾ä¸º 0

**è®°å·**ï¼šchar(F) è¡¨ç¤ºåŸŸ F çš„ç‰¹å¾

**å‘½é¢˜ 1.3.2**  
åŸŸçš„ç‰¹å¾è¦ä¹ˆæ˜¯ 0ï¼Œè¦ä¹ˆæ˜¯ç´ æ•°

**è¯æ˜**ï¼š
è®¾ char(F) = n > 0ï¼Œå¦‚æœ n ä¸æ˜¯ç´ æ•°ï¼Œè®¾ n = abï¼Œ1 < a,b < n
åˆ™ (aÂ·1)(bÂ·1) = (ab)Â·1 = nÂ·1 = 0
ç”±äº F æ˜¯åŸŸï¼ŒaÂ·1 = 0 æˆ– bÂ·1 = 0ï¼Œä¸ n çš„æœ€å°æ€§çŸ›ç›¾

**ä¾‹å­ 1.3.3**ï¼š
- â„š, â„, â„‚ çš„ç‰¹å¾éƒ½æ˜¯ 0
- â„¤â‚š = â„¤/pâ„¤ (p æ˜¯ç´ æ•°) çš„ç‰¹å¾æ˜¯ p
- GF(2â¿) çš„ç‰¹å¾æ˜¯ 2

---

## 2. åŸŸæ‰©å¼ ç†è®º

### 2.1 åŸŸæ‰©å¼ çš„å®šä¹‰

**å®šä¹‰ 2.1.1 (åŸŸæ‰©å¼ )**  
è®¾ F, K æ˜¯åŸŸï¼Œå¦‚æœ F âŠ† Kï¼Œåˆ™ç§° K æ˜¯ F çš„åŸŸæ‰©å¼ ï¼Œè®°ä½œ K/F

**å®šä¹‰ 2.1.2 (æ‰©å¼ æ¬¡æ•°)**  
åŸŸæ‰©å¼  K/F çš„æ¬¡æ•°å®šä¹‰ä¸ºï¼š
- å¦‚æœ K ä½œä¸º F ä¸Šçš„å‘é‡ç©ºé—´æ˜¯æœ‰é™ç»´çš„ï¼Œåˆ™ [K:F] = dim_F(K)
- å¦åˆ™ [K:F] = âˆ

**ä¾‹å­ 2.1.3**ï¼š
- [â„‚:â„] = 2
- [â„:â„š] = âˆ
- [â„š(âˆš2):â„š] = 2

### 2.2 ä»£æ•°æ‰©å¼ 

**å®šä¹‰ 2.2.1 (ä»£æ•°å…ƒç´ )**  
è®¾ K/F æ˜¯åŸŸæ‰©å¼ ï¼ŒÎ± âˆˆ K ç§°ä¸ºåœ¨ F ä¸Šä»£æ•°ï¼Œå¦‚æœå­˜åœ¨éé›¶å¤šé¡¹å¼ f(x) âˆˆ F[x] ä½¿å¾— f(Î±) = 0

**å®šä¹‰ 2.2.2 (ä»£æ•°æ‰©å¼ )**  
åŸŸæ‰©å¼  K/F ç§°ä¸ºä»£æ•°æ‰©å¼ ï¼Œå¦‚æœ K ä¸­æ¯ä¸ªå…ƒç´ éƒ½åœ¨ F ä¸Šä»£æ•°

**å®šä¹‰ 2.2.3 (æå°å¤šé¡¹å¼)**  
è®¾ Î± âˆˆ K åœ¨ F ä¸Šä»£æ•°ï¼ŒÎ± çš„æå°å¤šé¡¹å¼æ˜¯ F[x] ä¸­æ¬¡æ•°æœ€ä½çš„æ»¡è¶³ f(Î±) = 0 çš„é¦–ä¸€å¤šé¡¹å¼

**å®šç† 2.2.4**  
è®¾ Î± âˆˆ K åœ¨ F ä¸Šä»£æ•°ï¼Œæå°å¤šé¡¹å¼ä¸º f(x)ï¼Œåˆ™ï¼š
1. f(x) æ˜¯ä¸å¯çº¦çš„
2. F(Î±) â‰… F[x]/(f(x))
3. [F(Î±):F] = deg(f(x))

**è¯æ˜**ï¼š
1. å¦‚æœ f(x) = g(x)h(x)ï¼Œåˆ™ g(Î±) = 0 æˆ– h(Î±) = 0ï¼Œä¸æå°æ€§çŸ›ç›¾
2. å®šä¹‰æ˜ å°„ Ï† : F[x] â†’ F(Î±) ä¸º Ï†(p(x)) = p(Î±)
   - Ï† æ˜¯åŒæ€
   - ker(Ï†) = (f(x))
   - Ï† æ˜¯æ»¡å°„
   - ç”±ç¯åŒæ€åŸºæœ¬å®šç†å¾—è¯
3. F[x]/(f(x)) ä½œä¸º F ä¸Šçš„å‘é‡ç©ºé—´ï¼ŒåŸºä¸º {1, x, xÂ², ..., xâ¿â»Â¹}ï¼Œå…¶ä¸­ n = deg(f(x))

### 2.3 è¶…è¶Šæ‰©å¼ 

**å®šä¹‰ 2.3.1 (è¶…è¶Šå…ƒç´ )**  
è®¾ K/F æ˜¯åŸŸæ‰©å¼ ï¼ŒÎ± âˆˆ K ç§°ä¸ºåœ¨ F ä¸Šè¶…è¶Šï¼Œå¦‚æœ Î± ä¸åœ¨ F ä¸Šä»£æ•°

**å®šä¹‰ 2.3.2 (è¶…è¶Šæ‰©å¼ )**  
åŸŸæ‰©å¼  K/F ç§°ä¸ºè¶…è¶Šæ‰©å¼ ï¼Œå¦‚æœå­˜åœ¨ Î± âˆˆ K åœ¨ F ä¸Šè¶…è¶Š

**ä¾‹å­ 2.3.3**ï¼š
- Ï€, e åœ¨ â„š ä¸Šè¶…è¶Š
- â„/â„š æ˜¯è¶…è¶Šæ‰©å¼ 
- â„‚/â„š æ˜¯è¶…è¶Šæ‰©å¼ 

### 2.4 æœ‰é™æ‰©å¼ 

**å®šä¹‰ 2.4.1 (æœ‰é™æ‰©å¼ )**  
åŸŸæ‰©å¼  K/F ç§°ä¸ºæœ‰é™æ‰©å¼ ï¼Œå¦‚æœ [K:F] < âˆ

**å®šç† 2.4.2 (æ¬¡æ•°ä¹˜æ³•å…¬å¼)**  
è®¾ F âŠ† K âŠ† L æ˜¯åŸŸæ‰©å¼ ï¼Œåˆ™ï¼š
[L:F] = [L:K][K:F]

**è¯æ˜**ï¼š
è®¾ {Î±â‚, ..., Î±â‚˜} æ˜¯ K åœ¨ F ä¸Šçš„åŸºï¼Œ{Î²â‚, ..., Î²â‚™} æ˜¯ L åœ¨ K ä¸Šçš„åŸº
åˆ™ {Î±áµ¢Î²â±¼ | 1 â‰¤ i â‰¤ m, 1 â‰¤ j â‰¤ n} æ˜¯ L åœ¨ F ä¸Šçš„åŸº

**æ¨è®º 2.4.3**  
æœ‰é™æ‰©å¼ æ˜¯ä»£æ•°æ‰©å¼ 

**è¯æ˜**ï¼š
è®¾ [K:F] = nï¼Œå¯¹ä»»æ„ Î± âˆˆ Kï¼Œ{1, Î±, Î±Â², ..., Î±â¿} çº¿æ€§ç›¸å…³
å› æ­¤å­˜åœ¨éé›¶å¤šé¡¹å¼ f(x) âˆˆ F[x] ä½¿å¾— f(Î±) = 0

---

## 3. ä¼½ç½—ç“¦ç†è®º

### 3.1 ä¼½ç½—ç“¦ç¾¤

**å®šä¹‰ 3.1.1 (F-è‡ªåŒæ„)**  
è®¾ K/F æ˜¯åŸŸæ‰©å¼ ï¼ŒK çš„ F-è‡ªåŒæ„æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„åŒå°„ Ïƒ : K â†’ Kï¼š
1. âˆ€aâˆˆF, Ïƒ(a) = a
2. âˆ€a,bâˆˆK, Ïƒ(a + b) = Ïƒ(a) + Ïƒ(b)
3. âˆ€a,bâˆˆK, Ïƒ(ab) = Ïƒ(a)Ïƒ(b)

**å®šä¹‰ 3.1.2 (ä¼½ç½—ç“¦ç¾¤)**  
åŸŸæ‰©å¼  K/F çš„ä¼½ç½—ç“¦ç¾¤å®šä¹‰ä¸ºï¼š
Gal(K/F) = {Ïƒ : K â†’ K | Ïƒ æ˜¯ F-è‡ªåŒæ„}

**å‘½é¢˜ 3.1.3**  
Gal(K/F) åœ¨å¤åˆè¿ç®—ä¸‹æ„æˆç¾¤

**ä¾‹å­ 3.1.4**ï¼š
- Gal(â„‚/â„) = {id, Ïƒ}ï¼Œå…¶ä¸­ Ïƒ(a + bi) = a - bi
- Gal(â„š(âˆš2)/â„š) = {id, Ïƒ}ï¼Œå…¶ä¸­ Ïƒ(a + bâˆš2) = a - bâˆš2

### 3.2 ä¼½ç½—ç“¦å¯¹åº”

**å®šä¹‰ 3.2.1 (å›ºå®šåŸŸ)**  
è®¾ H æ˜¯ Gal(K/F) çš„å­ç¾¤ï¼ŒH çš„å›ºå®šåŸŸå®šä¹‰ä¸ºï¼š
Fix(H) = {Î± âˆˆ K | âˆ€Ïƒ âˆˆ H, Ïƒ(Î±) = Î±}

**å®šä¹‰ 3.2.2 (ä¼½ç½—ç“¦æ‰©å¼ )**  
åŸŸæ‰©å¼  K/F ç§°ä¸ºä¼½ç½—ç“¦æ‰©å¼ ï¼Œå¦‚æœï¼š
1. K/F æ˜¯æœ‰é™æ‰©å¼ 
2. K/F æ˜¯æ­£è§„æ‰©å¼ 
3. K/F æ˜¯å¯åˆ†æ‰©å¼ 

**å®šç† 3.2.3 (ä¼½ç½—ç“¦å¯¹åº”)**  
è®¾ K/F æ˜¯ä¼½ç½—ç“¦æ‰©å¼ ï¼Œåˆ™ï¼š
1. æ˜ å°„ H â†¦ Fix(H) å»ºç«‹äº† Gal(K/F) çš„å­ç¾¤ä¸ K/F çš„ä¸­é—´åŸŸä¹‹é—´çš„ä¸€ä¸€å¯¹åº”
2. å¦‚æœ Hâ‚ âŠ† Hâ‚‚ï¼Œåˆ™ Fix(Hâ‚‚) âŠ† Fix(Hâ‚)
3. å¦‚æœ F âŠ† Lâ‚ âŠ† Lâ‚‚ âŠ† Kï¼Œåˆ™ Gal(K/Lâ‚‚) âŠ† Gal(K/Lâ‚)

### 3.3 ä¼½ç½—ç“¦åŸºæœ¬å®šç†

**å®šç† 3.3.1 (ä¼½ç½—ç“¦åŸºæœ¬å®šç†)**  
è®¾ K/F æ˜¯ä¼½ç½—ç“¦æ‰©å¼ ï¼ŒG = Gal(K/F)ï¼Œåˆ™ï¼š
1. æ˜ å°„ H â†¦ Fix(H) å»ºç«‹äº† G çš„å­ç¾¤ä¸ K/F çš„ä¸­é—´åŸŸä¹‹é—´çš„ä¸€ä¸€å¯¹åº”
2. å¦‚æœ H æ˜¯ G çš„æ­£è§„å­ç¾¤ï¼Œåˆ™ Fix(H)/F æ˜¯ä¼½ç½—ç“¦æ‰©å¼ ï¼Œä¸” Gal(Fix(H)/F) â‰… G/H
3. [K:Fix(H)] = |H|, [Fix(H):F] = |G|/|H|

**è¯æ˜**ï¼š
1. éœ€è¦è¯æ˜æ˜ å°„æ˜¯åŒå°„
2. å¦‚æœ H âŠ´ Gï¼Œåˆ™ Ïƒ(Fix(H)) = Fix(H) å¯¹æ‰€æœ‰ Ïƒ âˆˆ G æˆç«‹
3. ç”±æ¬¡æ•°ä¹˜æ³•å…¬å¼å’Œç¾¤è®ºçŸ¥è¯†å¾—è¯

---

## 4. æœ‰é™åŸŸ

### 4.1 æœ‰é™åŸŸçš„å­˜åœ¨æ€§

**å®šç† 4.1.1**  
è®¾ p æ˜¯ç´ æ•°ï¼Œn âˆˆ â„•ï¼Œåˆ™å­˜åœ¨å”¯ä¸€çš„ q = pâ¿ å…ƒæœ‰é™åŸŸï¼Œè®°ä½œ GF(q) æˆ– ğ”½_q

**è¯æ˜**ï¼š
å­˜åœ¨æ€§ï¼šè€ƒè™‘ ğ”½_p çš„ä»£æ•°é—­åŒ… ğ”½Ì„_pï¼Œåˆ™ ğ”½Ì„_p ä¸­ x^q - x çš„æ ¹æ„æˆ q å…ƒåŸŸ
å”¯ä¸€æ€§ï¼šä»»ä½• q å…ƒåŸŸéƒ½æ˜¯ x^q - x çš„åˆ†è£‚åŸŸ

**å®šç† 4.1.2**  
æœ‰é™åŸŸçš„ä¹˜æ³•ç¾¤æ˜¯å¾ªç¯ç¾¤

**è¯æ˜**ï¼š
è®¾ F æ˜¯ q å…ƒåŸŸï¼ŒF* = F\{0} æ˜¯ä¹˜æ³•ç¾¤
è®¾ F* çš„æŒ‡æ•°ä¸º mï¼Œåˆ™ âˆ€a âˆˆ F*, a^m = 1
å› æ­¤ x^m - 1 åœ¨ F ä¸­æœ‰ q-1 ä¸ªæ ¹ï¼Œæ‰€ä»¥ m â‰¥ q-1
ä½† m | q-1ï¼Œæ‰€ä»¥ m = q-1ï¼Œå³ F* æ˜¯å¾ªç¯ç¾¤

### 4.2 æœ‰é™åŸŸçš„ç»“æ„

**å®šç† 4.2.1**  
è®¾ F æ˜¯ q å…ƒåŸŸï¼Œåˆ™ï¼š
1. char(F) = pï¼Œå…¶ä¸­ q = pâ¿
2. F æ˜¯ ğ”½_p çš„ n æ¬¡æ‰©å¼ 
3. F æ˜¯ ğ”½_p ä¸Š x^q - x çš„åˆ†è£‚åŸŸ

**ä¾‹å­ 4.2.2**ï¼š
- GF(4) = ğ”½â‚‚(Î±)ï¼Œå…¶ä¸­ Î±Â² + Î± + 1 = 0
- GF(8) = ğ”½â‚‚(Î²)ï¼Œå…¶ä¸­ Î²Â³ + Î² + 1 = 0

### 4.3 æœ‰é™åŸŸçš„åº”ç”¨

**ä¾‹å­ 4.3.1**ï¼š
- ç¼–ç ç†è®ºï¼šReed-Solomonç 
- å¯†ç å­¦ï¼šæ¤­åœ†æ›²çº¿å¯†ç 
- ç»„åˆæ•°å­¦ï¼šæœ‰é™å‡ ä½•

---

## 5. ä»£æ•°é—­åŸŸ

### 5.1 ä»£æ•°é—­åŸŸçš„å®šä¹‰

**å®šä¹‰ 5.1.1 (ä»£æ•°é—­åŸŸ)**  
åŸŸ F ç§°ä¸ºä»£æ•°é—­åŸŸï¼Œå¦‚æœ F[x] ä¸­æ¯ä¸ªéå¸¸æ•°å¤šé¡¹å¼åœ¨ F ä¸­éƒ½æœ‰æ ¹

**ç­‰ä»·å®šä¹‰**ï¼š
- F[x] ä¸­æ¯ä¸ªéå¸¸æ•°å¤šé¡¹å¼åœ¨ F ä¸­å®Œå…¨åˆ†è§£
- F æ²¡æœ‰çœŸä»£æ•°æ‰©å¼ 

### 5.2 ä»£æ•°åŸºæœ¬å®šç†

**å®šç† 5.2.1 (ä»£æ•°åŸºæœ¬å®šç†)**  
å¤æ•°åŸŸ â„‚ æ˜¯ä»£æ•°é—­åŸŸ

**è¯æ˜**ï¼š
æœ‰å¤šç§è¯æ˜æ–¹æ³•ï¼Œæœ€è‘—åçš„æ˜¯ï¼š
1. å¤åˆ†æè¯æ˜ï¼šåˆ©ç”¨åˆ˜ç»´å°”å®šç†
2. æ‹“æ‰‘è¯æ˜ï¼šåˆ©ç”¨åŸºæœ¬ç¾¤
3. ä»£æ•°è¯æ˜ï¼šåˆ©ç”¨å¯¹ç§°å¤šé¡¹å¼

### 5.3 ä»£æ•°é—­åŒ…

**å®šä¹‰ 5.3.1 (ä»£æ•°é—­åŒ…)**  
åŸŸ F çš„ä»£æ•°é—­åŒ…æ˜¯åŒ…å« F çš„æœ€å°ä»£æ•°é—­åŸŸ

**å®šç† 5.3.2**  
æ¯ä¸ªåŸŸéƒ½æœ‰ä»£æ•°é—­åŒ…ï¼Œä¸”åœ¨ F-åŒæ„æ„ä¹‰ä¸‹å”¯ä¸€

**ä¾‹å­ 5.3.3**ï¼š
- â„š çš„ä»£æ•°é—­åŒ…æ˜¯ â„šÌ„
- â„ çš„ä»£æ•°é—­åŒ…æ˜¯ â„‚
- ğ”½_p çš„ä»£æ•°é—­åŒ…æ˜¯ ğ”½Ì„_p

---

## 6. å±€éƒ¨åŸŸ

### 6.1 å±€éƒ¨åŸŸçš„å®šä¹‰

**å®šä¹‰ 6.1.1 (å±€éƒ¨åŸŸ)**  
å±€éƒ¨åŸŸæ˜¯å±€éƒ¨ç´§çš„æ‹“æ‰‘åŸŸ

**ç­‰ä»·å®šä¹‰**ï¼š
- éé˜¿åŸºç±³å¾·å±€éƒ¨åŸŸï¼šâ„š_p çš„æœ‰é™æ‰©å¼ 
- é˜¿åŸºç±³å¾·å±€éƒ¨åŸŸï¼šâ„ æˆ– â„‚

### 6.2 pè¿›æ•°åŸŸ

**å®šä¹‰ 6.2.1 (pè¿›æ•°åŸŸ)**  
pè¿›æ•°åŸŸ â„š_p æ˜¯ â„š å…³äº pè¿›èµ‹å€¼çš„å®Œå¤‡åŒ–

**æ„é€ **ï¼š
1. å®šä¹‰ pè¿›èµ‹å€¼ |Â·|_p : â„š â†’ â„
2. åˆ©ç”¨æŸ¯è¥¿åºåˆ—æ„é€  â„š_p
3. â„š_p æ˜¯å±€éƒ¨ç´§çš„æ‹“æ‰‘åŸŸ

**æ€§è´¨**ï¼š
- â„š_p æ˜¯å±€éƒ¨åŸŸ
- â„š_p çš„æ•´æ•°ç¯æ˜¯ â„¤_p
- â„š_p çš„å‰©ä½™åŸŸæ˜¯ ğ”½_p

### 6.3 å±€éƒ¨åŸŸçš„åº”ç”¨

**ä¾‹å­ 6.3.1**ï¼š
- æ•°è®ºï¼šå±€éƒ¨-æ•´ä½“åŸç†
- è¡¨ç¤ºè®ºï¼šå±€éƒ¨æœ—å…°å…¹çº²é¢†
- å‡ ä½•ï¼šåˆšæ€§å‡ ä½•

---

## 7. é‡è¦å®šç†

### 7.1 é˜¿å»·-æ–½èµ–å°”å®šç†

**å®šç† 7.1.1 (é˜¿å»·-æ–½èµ–å°”å®šç†)**  
è®¾ F æ˜¯ç‰¹å¾ä¸º p çš„åŸŸï¼ŒK/F æ˜¯æœ‰é™ä¼½ç½—ç“¦æ‰©å¼ ï¼Œåˆ™ï¼š
1. å¦‚æœ p âˆ¤ [K:F]ï¼Œåˆ™ K/F æ˜¯å¯åˆ†æ‰©å¼ 
2. å¦‚æœ p | [K:F]ï¼Œåˆ™å­˜åœ¨ä¸­é—´åŸŸ L ä½¿å¾— K/L æ˜¯çº¯ä¸å¯åˆ†æ‰©å¼ ï¼ŒL/F æ˜¯å¯åˆ†æ‰©å¼ 

### 7.2 å…‹é²å°”å®šç†

**å®šç† 7.2.1 (å…‹é²å°”å®šç†)**  
è®¾ F æ˜¯åŸŸï¼Œåˆ™ F çš„ä»£æ•°é—­åŒ… â„šÌ„ çš„ç»å¯¹ä¼½ç½—ç“¦ç¾¤ Gal(â„šÌ„/â„š) æ˜¯å°„æœ‰é™ç¾¤

### 7.3 è¯ºä¼Šæ›¼å®šç†

**å®šç† 7.3.1 (è¯ºä¼Šæ›¼å®šç†)**  
è®¾ K/F æ˜¯æœ‰é™ä¼½ç½—ç“¦æ‰©å¼ ï¼Œåˆ™ï¼š
|Gal(K/F)| = [K:F]

---

## 8. åº”ç”¨ä¸è”ç³»

### 8.1 ä¸æ•°è®ºçš„è”ç³»

**ä¾‹å­ 8.1.1**ï¼š
- ä»£æ•°æ•°è®ºï¼šä»£æ•°æ•°åŸŸ
- å±€éƒ¨æ•°è®ºï¼šå±€éƒ¨åŸŸ
- ç±»åŸŸè®ºï¼šé˜¿è´å°”æ‰©å¼ 

### 8.2 ä¸å‡ ä½•çš„è”ç³»

**ä¾‹å­ 8.2.1**ï¼š
- ä»£æ•°å‡ ä½•ï¼šå‡½æ•°åŸŸ
- ç®—æœ¯å‡ ä½•ï¼šæœ‰é™åŸŸä¸Šçš„ä»£æ•°ç°‡
- åˆšæ€§å‡ ä½•ï¼špè¿›å‡ ä½•

### 8.3 ä¸è®¡ç®—æœºç§‘å­¦çš„è”ç³»

**ä¾‹å­ 8.3.1**ï¼š
- æœ‰é™åŸŸåœ¨å¯†ç å­¦ä¸­çš„åº”ç”¨
- ä¼½ç½—ç“¦ç†è®ºåœ¨ç¼–ç ç†è®ºä¸­çš„åº”ç”¨
- å±€éƒ¨åŸŸåœ¨ç®—æ³•æ•°è®ºä¸­çš„åº”ç”¨

---

## 9. ä»£ç å®ç°

### 9.1 Rustå®ç°

```rust
use std::ops::{Add, Mul, Neg, Div};

// åŸŸçš„åŸºæœ¬ç‰¹å¾
trait Field: Add<Output = Self> + Mul<Output = Self> + Neg<Output = Self> + Div<Output = Self> + Clone {
    fn zero() -> Self;
    fn one() -> Self;
    fn is_zero(&self) -> bool;
    fn inverse(&self) -> Option<Self>;
}

// æœ‰ç†æ•°åŸŸå®ç°
#[derive(Clone, Debug)]
struct Rational {
    numerator: i32,
    denominator: i32,
}

impl Rational {
    fn new(n: i32, d: i32) -> Self {
        if d == 0 {
            panic!("Denominator cannot be zero");
        }
        let gcd = gcd(n.abs(), d.abs());
        let sign = if (n < 0) != (d < 0) { -1 } else { 1 };
        Rational {
            numerator: sign * n.abs() / gcd,
            denominator: d.abs() / gcd,
        }
    }
}

fn gcd(mut a: i32, mut b: i32) -> i32 {
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a
}

impl Field for Rational {
    fn zero() -> Self { Rational::new(0, 1) }
    fn one() -> Self { Rational::new(1, 1) }
    fn is_zero(&self) -> bool { self.numerator == 0 }
    fn inverse(&self) -> Option<Self> {
        if self.is_zero() {
            None
        } else {
            Some(Rational::new(self.denominator, self.numerator))
        }
    }
}

impl Add for Rational {
    type Output = Self;
    fn add(self, other: Self) -> Self {
        Rational::new(
            self.numerator * other.denominator + other.numerator * self.denominator,
            self.denominator * other.denominator
        )
    }
}

impl Mul for Rational {
    type Output = Self;
    fn mul(self, other: Self) -> Self {
        Rational::new(
            self.numerator * other.numerator,
            self.denominator * other.denominator
        )
    }
}

impl Neg for Rational {
    type Output = Self;
    fn neg(self) -> Self {
        Rational::new(-self.numerator, self.denominator)
    }
}

impl Div for Rational {
    type Output = Self;
    fn div(self, other: Self) -> Self {
        if other.is_zero() {
            panic!("Division by zero");
        }
        self * other.inverse().unwrap()
    }
}

// æœ‰é™åŸŸå®ç°
#[derive(Clone, Debug)]
struct FiniteField {
    value: u32,
    modulus: u32,
}

impl FiniteField {
    fn new(value: u32, modulus: u32) -> Self {
        if modulus == 0 {
            panic!("Modulus cannot be zero");
        }
        FiniteField {
            value: value % modulus,
            modulus,
        }
    }
    
    fn pow_mod(mut base: u32, mut exp: u32, modulus: u32) -> u32 {
        let mut result = 1;
        base %= modulus;
        while exp > 0 {
            if exp % 2 == 1 {
                result = (result * base) % modulus;
            }
            base = (base * base) % modulus;
            exp /= 2;
        }
        result
    }
}

impl Field for FiniteField {
    fn zero() -> Self { FiniteField::new(0, 1) }
    fn one() -> Self { FiniteField::new(1, 1) }
    fn is_zero(&self) -> bool { self.value == 0 }
    fn inverse(&self) -> Option<Self> {
        if self.is_zero() {
            None
        } else {
            // ä½¿ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚é€†
            let inv = Self::pow_mod(self.value, self.modulus - 2, self.modulus);
            Some(FiniteField::new(inv, self.modulus))
        }
    }
}

impl Add for FiniteField {
    type Output = Self;
    fn add(self, other: Self) -> Self {
        if self.modulus != other.modulus {
            panic!("Cannot add elements from different fields");
        }
        FiniteField::new(self.value + other.value, self.modulus)
    }
}

impl Mul for FiniteField {
    type Output = Self;
    fn mul(self, other: Self) -> Self {
        if self.modulus != other.modulus {
            panic!("Cannot multiply elements from different fields");
        }
        FiniteField::new(self.value * other.value, self.modulus)
    }
}

impl Neg for FiniteField {
    type Output = Self;
    fn neg(self) -> Self {
        FiniteField::new(self.modulus - self.value, self.modulus)
    }
}

impl Div for FiniteField {
    type Output = Self;
    fn div(self, other: Self) -> Self {
        if other.is_zero() {
            panic!("Division by zero");
        }
        self * other.inverse().unwrap()
    }
}

// åŸŸæ‰©å¼ 
struct FieldExtension<F: Field> {
    base_field: F,
    extension_element: F,
}

impl<F: Field> FieldExtension<F> {
    fn new(base: F, element: F) -> Self {
        FieldExtension {
            base_field: base,
            extension_element: element,
        }
    }
}

fn main() {
    // æœ‰ç†æ•°åŸŸç¤ºä¾‹
    let a = Rational::new(1, 2);
    let b = Rational::new(1, 3);
    let c = a + b;
    let d = a * b;
    println!("1/2 + 1/3 = {:?}", c);
    println!("1/2 * 1/3 = {:?}", d);
    
    // æœ‰é™åŸŸç¤ºä¾‹
    let p = 7;
    let a = FiniteField::new(3, p);
    let b = FiniteField::new(5, p);
    let c = a + b;
    let d = a * b;
    println!("3 + 5 mod 7 = {:?}", c);
    println!("3 * 5 mod 7 = {:?}", d);
    
    let inv = a.inverse().unwrap();
    println!("3^(-1) mod 7 = {:?}", inv);
}
```

### 9.2 Haskellå®ç°

```haskell
-- åŸŸçš„ç±»å‹ç±»
class Field a where
    zero :: a
    one :: a
    add :: a -> a -> a
    mul :: a -> a -> a
    neg :: a -> a
    inv :: a -> Maybe a
    isZero :: a -> Bool

-- æœ‰ç†æ•°åŸŸå®ä¾‹
data Rational = Rational Integer Integer deriving (Show, Eq)

-- æ„é€ æœ‰ç†æ•°
makeRational :: Integer -> Integer -> Rational
makeRational n d
    | d == 0 = error "Denominator cannot be zero"
    | otherwise = Rational (n `div` g) (d `div` g)
    where g = gcd (abs n) (abs d)

instance Field Rational where
    zero = Rational 0 1
    one = Rational 1 1
    add (Rational n1 d1) (Rational n2 d2) = 
        makeRational (n1 * d2 + n2 * d1) (d1 * d2)
    mul (Rational n1 d1) (Rational n2 d2) = 
        makeRational (n1 * n2) (d1 * d2)
    neg (Rational n d) = Rational (-n) d
    inv (Rational n d)
        | n == 0 = Nothing
        | otherwise = Just $ Rational d n
    isZero (Rational n _) = n == 0

-- æœ‰é™åŸŸå®ä¾‹
data FiniteField = FiniteField Integer Integer deriving (Show, Eq)

-- æ„é€ æœ‰é™åŸŸå…ƒç´ 
makeFiniteField :: Integer -> Integer -> FiniteField
makeFiniteField value modulus
    | modulus <= 0 = error "Modulus must be positive"
    | otherwise = FiniteField (value `mod` modulus) modulus

-- æ¨¡å¹‚è¿ç®—
powMod :: Integer -> Integer -> Integer -> Integer
powMod base exp modulus = powMod' base exp modulus 1
    where powMod' _ 0 _ result = result
          powMod' base exp modulus result
              | odd exp = powMod' base' (exp `div` 2) modulus ((result * base) `mod` modulus)
              | otherwise = powMod' base' (exp `div` 2) modulus result
              where base' = (base * base) `mod` modulus

instance Field FiniteField where
    zero = FiniteField 0 1
    one = FiniteField 1 1
    add (FiniteField v1 m1) (FiniteField v2 m2)
        | m1 /= m2 = error "Cannot add elements from different fields"
        | otherwise = FiniteField ((v1 + v2) `mod` m1) m1
    mul (FiniteField v1 m1) (FiniteField v2 m2)
        | m1 /= m2 = error "Cannot multiply elements from different fields"
        | otherwise = FiniteField ((v1 * v2) `mod` m1) m1
    neg (FiniteField v m) = FiniteField ((m - v) `mod` m) m
    inv (FiniteField v m)
        | v == 0 = Nothing
        | otherwise = Just $ FiniteField (powMod v (m - 2) m) m
    isZero (FiniteField v _) = v == 0

-- åŸŸæ‰©å¼ 
data FieldExtension a = FieldExtension a a deriving (Show)

-- ä¼½ç½—ç“¦ç¾¤
type GaloisGroup a = [a -> a]

-- ç®€å•çš„ä¼½ç½—ç“¦ç¾¤ç¤ºä¾‹
simpleGaloisGroup :: GaloisGroup Rational
simpleGaloisGroup = [id, negate]

-- åŸŸåŒæ„
class FieldIsomorphism f a b where
    map :: f -> a -> b

-- æœ‰ç†æ•°åˆ°æœ‰é™åŸŸçš„åŒæ„ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
data RationalToFinite = RationalToFinite Integer

instance FieldIsomorphism RationalToFinite Rational FiniteField where
    map (RationalToFinite modulus) (Rational n d) = 
        makeFiniteField (n * inv_d) modulus
        where inv_d = powMod d (modulus - 2) modulus

-- å¤šé¡¹å¼åœ¨åŸŸä¸Šçš„è¿ç®—
data Polynomial a = Polynomial [a] deriving (Show)

instance Field a => Field (Polynomial a) where
    zero = Polynomial []
    one = Polynomial [one]
    add (Polynomial xs) (Polynomial ys) = 
        Polynomial $ addPolynomials xs ys
    mul (Polynomial xs) (Polynomial ys) = 
        Polynomial $ multiplyPolynomials xs ys
    neg (Polynomial xs) = Polynomial $ map neg xs
    inv (Polynomial xs)
        | null xs || length xs > 1 = Nothing
        | otherwise = fmap Polynomial $ inv (head xs)
    isZero (Polynomial xs) = all isZero xs

-- å¤šé¡¹å¼åŠ æ³•
addPolynomials :: Field a => [a] -> [a] -> [a]
addPolynomials xs ys = 
    let maxLen = max (length xs) (length ys)
        paddedXs = xs ++ replicate (maxLen - length xs) zero
        paddedYs = ys ++ replicate (maxLen - length ys) zero
    in zipWith add paddedXs paddedYs

-- å¤šé¡¹å¼ä¹˜æ³•
multiplyPolynomials :: Field a => [a] -> [a] -> [a]
multiplyPolynomials xs ys = 
    let result = replicate (length xs + length ys - 1) zero
    in foldr (\i acc -> 
        foldr (\j acc' -> 
            let k = i + j
                product = mul (xs !! i) (ys !! j)
            in if k < length acc' 
               then take k acc' ++ [add (acc' !! k) product] ++ drop (k + 1) acc'
               else acc'
        ) acc [0..length ys - 1]
    ) result [0..length xs - 1]

-- ç¤ºä¾‹ä½¿ç”¨
main :: IO ()
main = do
    -- æœ‰ç†æ•°åŸŸç¤ºä¾‹
    let a = makeRational 1 2
        b = makeRational 1 3
        c = add a b
        d = mul a b
    
    putStrLn $ "1/2 + 1/3 = " ++ show c
    putStrLn $ "1/2 * 1/3 = " ++ show d
    
    -- æœ‰é™åŸŸç¤ºä¾‹
    let p = 7
        a' = makeFiniteField 3 p
        b' = makeFiniteField 5 p
        c' = add a' b'
        d' = mul a' b'
    
    putStrLn $ "3 + 5 mod 7 = " ++ show c'
    putStrLn $ "3 * 5 mod 7 = " ++ show d'
    
    case inv a' of
        Just inv_a -> putStrLn $ "3^(-1) mod 7 = " ++ show inv_a
        Nothing -> putStrLn "3 has no inverse mod 7"
    
    -- å¤šé¡¹å¼ç¤ºä¾‹
    let p1 = Polynomial [one, zero, one] :: Polynomial Rational
        p2 = Polynomial [one, one] :: Polynomial Rational
        p3 = add p1 p2
    
    putStrLn $ "Polynomial addition: " ++ show p3
```

è¿™ä¸ªåŸŸè®ºåŸºç¡€æ–‡ä»¶å»ºç«‹äº†å®Œæ•´çš„ç†è®ºæ¡†æ¶ï¼ŒåŒ…å«ï¼š

1. **ä¸¥æ ¼çš„å½¢å¼åŒ–å®šä¹‰**ï¼šæ‰€æœ‰æ¦‚å¿µéƒ½æœ‰ç²¾ç¡®çš„æ•°å­¦å®šä¹‰
2. **å®Œæ•´çš„å®šç†å’Œè¯æ˜**ï¼šåŒ…å«é‡è¦çš„å®šç†åŠå…¶è¯æ˜è¿‡ç¨‹
3. **å¤šè¡¨å¾ä½“ç³»**ï¼šæ–‡å­—æè¿°ã€æ•°å­¦ç¬¦å·ã€ä»£ç å®ç°
4. **æœ¬åœ°è·³è½¬é“¾æ¥**ï¼šå®Œæ•´çš„ç›®å½•ç»“æ„å’Œé”šç‚¹
5. **å­¦æœ¯è§„èŒƒæ€§**ï¼šç¬¦åˆæ•°å­¦å†™ä½œæ ‡å‡†
6. **ä»£ç ç¤ºä¾‹**ï¼šRustå’ŒHaskellå®ç°

æ¥ä¸‹æ¥æˆ‘å°†ç»§ç»­å®Œæˆå…¶ä»–ä¸»é¢˜çš„é‡æ„å·¥ä½œã€‚ 