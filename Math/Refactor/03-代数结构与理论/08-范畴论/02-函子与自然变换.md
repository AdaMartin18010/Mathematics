# 02-函子与自然变换

## 1. 函子：范畴间的桥梁

如果说范畴论的核心思想是关注态射（关系），那么**函子 (Functor)** 就是"态射的态射"——它是在范畴之间保持结构的映射。函子让我们能够系统地比较和关联不同的数学领域。

### 1.1 协变函子 (Covariant Functor)

**定义**：设 $\mathcal{C}$ 和 $\mathcal{D}$ 是两个范畴，一个（协变）函子 $F: \mathcal{C} \to \mathcal{D}$ 是一个映射，它包含：

1. **对象映射**：将 $\mathcal{C}$ 中的每个对象 $A$ 映射为 $\mathcal{D}$ 中的一个对象 $F(A)$。
2. **态射映射**：将 $\mathcal{C}$ 中的每个态射 $f: A \to B$ 映射为 $\mathcal{D}$ 中的一个态射 $F(f): F(A) \to F(B)$。

这个映射必须满足两个条件，以"保持结构"：

1. **保持恒等态射**：对于 $\mathcal{C}$ 中的任意对象 $A$，$F(\text{id}_A) = \text{id}_{F(A)}$。
2. **保持复合**：对于 $\mathcal{C}$ 中的任意可复合态射 $f: A \to B$ 和 $g: B \to C$，$F(g \circ f) = F(g) \circ F(f)$。

简而言之，函子将一个范畴的图表（对象和箭头）原封不动地"复制"到另一个范畴中。

### 1.2 逆变函子 (Contravariant Functor)

逆变函子与协变函子类似，但它会**反转态射的方向**。

**定义**：一个逆变函子 $F: \mathcal{C} \to \mathcal{D}$ 将态射 $f: A \to B$ 映射为 $F(f): F(B) \to F(A)$。
因此，它在保持结构时需要"反转"复合的顺序：$F(g \circ f) = F(f) \circ F(g)$。

**另一种视角**：一个从 $\mathcal{C}$ 到 $\mathcal{D}$ 的逆变函子，等价于一个从其对偶范畴 $\mathcal{C}^{op}$ 到 $\mathcal{D}$ 的协变函子。

### 1.3 函子的关键示例

1. **忘却函子 (Forgetful Functor)**：这类函子通过"忘记"部分结构来简化范畴。
    - $U: \textbf{Grp} \to \textbf{Set}$：将每个群映射到其底层的集合，将每个群同态映射到其对应的函数。它"忘记"了群的运算结构。
    - $U: \textbf{Ring} \to \textbf{Ab}$：将每个环映射到其加法阿贝尔群。它"忘记"了乘法结构。

2. **自由函子 (Free Functor)**：它与忘却函子方向相反，可以被看作是"创造"结构。
    - $F: \textbf{Set} \to \textbf{Grp}$：将一个集合 $S$ 映射到由 $S$ 生成的**自由群**。自由函子和忘却函子通常以**伴随函子 (Adjoint Functors)** 的形式成对出现，这是范畴论中一个更深层的概念。

3. **Hom 函子**：这是范畴论内生的、极其重要的函子。
    - **协变 Hom 函子** $\text{Hom}(A, -): \mathcal{C} \to \textbf{Set}$ (固定源对象 $A$)：
        - 对象映射：将对象 $X$ 映射到集合 $\text{Hom}(A, X)$。
        - 态射映射：将态射 $f: X \to Y$ 映射到函数 $f_*:\text{Hom}(A, X) \to \text{Hom}(A, Y)$，其定义为 $f_*(g) = f \circ g$ (前复合)。
    - **逆变 Hom 函子** $\text{Hom}(-, A): \mathcal{C} \to \textbf{Set}$ (固定目标对象 $A$)：
        - 对象映射：将对象 $X$ 映射到集合 $\text{Hom}(X, A)$。
        - 态射映射：将态射 $f: X \to Y$ 映射到函数 $f^*:\text{Hom}(Y, A) \to \text{Hom}(X, A)$，其定义为 $f^*(g) = g \circ f$ (后复合)。

## 2. 函子与编程

在现代函数式编程中，函子是一个核心的设计模式，它抽象了对"容器"或"上下文"中的值进行操作的能力。

### 2.1 Haskell 中的函子

Haskell 的 `Functor` 类型类直接对应于协变函子的概念。

```haskell
-- Functor 类型类定义了 fmap 操作，它就是范畴论中的态射映射 F(f)
class Functor f where
  -- fmap 接收一个函数 (a -> b) 和一个容器 f a，返回一个新的容器 f b
  fmap :: (a -> b) -> f a -> f b

-- List (列表) 是一个函子
instance Functor [] where
  fmap f [] = []
  fmap f (x:xs) = f x : fmap f xs

-- Maybe (可能) 也是一个函子
instance Functor Maybe where
  fmap f Nothing = Nothing
  fmap f (Just x) = Just (f x)

-- 使用示例：
-- fmap (+1) [1, 2, 3]  -- 结果: [2, 3, 4]
-- fmap (*2) (Just 5) -- 结果: Just 10
```

### 2.2 Rust 中的函子

虽然 Rust 的类型系统不如 Haskell 灵活，但我们依然可以用 trait 来模拟函子的思想。

```rust
// 一个简化的 Functor trait
pub trait Functor<A, B> {
    type Output;
    fn map<F>(self, f: F) -> Self::Output
    where
        F: Fn(A) -> B;
}

// 为 Option<T> (即 Maybe) 实现 Functor
impl<T, U> Functor<T, U> for Option<T> {
    type Output = Option<U>;
    fn map<F>(self, f: F) -> Self::Output
    where
        F: Fn(T) -> U,
    {
        self.map(f) // Option 类型内置了 map 方法
    }
}

// 使用示例
// let just_five = Some(5);
// let just_ten = just_five.map(|x| x * 2); // 结果: Some(10)
```

## 3. 自然变换：函子间的映射

如果函子是范畴间的态射，那么**自然变换 (Natural Transformation)** 就是函子间的态射。它提供了一种比较两个函子输出的一致性方式。

### 3.1 定义与自然性条件

设 $F, G: \mathcal{C} \to \mathcal{D}$ 是两个（协变）函子。一个从 $F$ 到 $G$ 的自然变换 $\eta: F \Rightarrow G$ 是一族态射，它为 $\mathcal{C}$ 中的**每个**对象 $A$ 提供一个 $\mathcal{D}$ 中的态射 $\eta_A: F(A) \to G(A)$，这个态射被称为 $\eta$ 在 $A$ 处的**分量 (component)**。

这族态射必须满足**自然性条件 (Naturality Condition)**，即对于 $\mathcal{C}$ 中的**任意**态射 $f: A \to B$，下面的交换图必须成立：

```text
      F(f)
F(A) --------> F(B)
  |              |
η_A |            | η_B
  V              V
G(A) --------> G(B)
      G(f)
```

这个图表表达的思想是：先对容器内的值做变换再改变容器结构，等价于先改变容器结构再对容器内的值做变换。用公式表达就是：$\eta_B \circ F(f) = G(f) \circ \eta_A$。

如果每个分量 $\eta_A$ 都是一个同构，那么 $\eta$ 就是一个**自然同构 (Natural Isomorphism)**，表示函子 $F$ 和 $G$ 在本质上是相同的。

### 3.2 编程中的自然变换

自然变换在编程中表现为一种通用的、与具体类型无关的函数，用于转换参数化的类型（函子）。

```haskell
-- 一个将列表转换为 Maybe 的函数
-- 它返回列表的第一个元素（如果存在）
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:_) = Just x

-- safeHead 就是一个从 List 函子到 Maybe 函子的自然变换。
-- `forall a.` 体现了其通用性/自然性。
-- type NaturalTransformation f g = forall a. f a -> g a
-- safeHead :: NaturalTransformation [] Maybe
```

这个函数对于所有类型 `a` 的行为都是一致的，它不关心 `a` 是什么，只操作容器的结构。这就是自然性的体现。

## 4. 函子范畴与米田引理

### 4.1 函子范畴

函子和自然变换本身也构成一个范畴，称为**函子范畴 (Functor Category)** $[\mathcal{C}, \mathcal{D}]$。

- **对象**：所有从 $\mathcal{C}$ 到 $\mathcal{D}$ 的函子。
- **态射**：所有这些函子之间的自然变换。

### 4.2 米田引理 (Yoneda Lemma) 的思想

米田引理是范畴论中最深刻的结果之一，虽然其形式化陈述非常抽象，但其核心思想是革命性的：

> **一个对象完全由它与范畴中所有其他对象的关系（即它的 Hom 函子）唯一确定。**

这意味着我们可以将对范畴中**对象**的研究，完全转化为对一个更标准、更良好性质的范畴（**Set**）的研究。

**Yoneda 嵌入** $Y: \mathcal{C} \to [\mathcal{C}^{op}, \textbf{Set}]$ 将每个对象 $A$ 映射到其代表函子 $h_A = \text{Hom}(-, A)$。米田引理保证了这个嵌入是**全忠实的 (fully faithful)**，意味着它完美地保留了原范畴的所有结构信息。

## 5. 函子的类型

### 5.1 共变函子与反变函子

函子可以分为两种基本类型：

1. **共变函子**：保持态射的方向，即 $F: \mathcal{C} \to \mathcal{D}$ 将态射 $f: A \to B$ 映射为 $F(f): F(A) \to F(B)$。

2. **反变函子**：反转态射的方向，即 $F: \mathcal{C}^{\text{op}} \to \mathcal{D}$ 将态射 $f: A \to B$ 映射为 $F(f): F(B) \to F(A)$。这里 $\mathcal{C}^{\text{op}}$ 是 $\mathcal{C}$ 的对偶范畴，其中所有态射的方向都被反转。

反变函子也可以看作是从 $\mathcal{C}$ 到 $\mathcal{D}^{\text{op}}$ 的共变函子。

### 5.2 忠实函子、满函子与全函子

根据态射映射的性质，函子可以进一步分类：

1. **忠实函子**：如果对于任意两个对象 $A, B \in \mathcal{C}$，映射 $F: \text{Hom}_{\mathcal{C}}(A, B) \to \text{Hom}_{\mathcal{D}}(F(A), F(B))$ 是单射（注入），则称 $F$ 为忠实函子。

2. **满函子**：如果对于任意两个对象 $A, B \in \mathcal{C}$，映射 $F: \text{Hom}_{\mathcal{C}}(A, B) \to \text{Hom}_{\mathcal{D}}(F(A), F(B))$ 是满射（满），则称 $F$ 为满函子。

3. **全函子**：如果 $F$ 既是忠实函子又是满函子，则称 $F$ 为全函子。

### 5.3 本函子与常函子

1. **本函子**：范畴 $\mathcal{C}$ 上的恒等函子，记为 $\text{Id}_{\mathcal{C}}: \mathcal{C} \to \mathcal{C}$，它将每个对象和态射映射到自身。

2. **常函子**：将 $\mathcal{C}$ 中的所有对象都映射到 $\mathcal{D}$ 中的同一个对象 $D$，将所有态射都映射到 $D$ 上的恒等态射 $\text{id}_D$ 的函子。

## 6. 函子的例子

### 6.1 忘却函子

**忘却函子**从一个具有额外结构的范畴到一个结构较少的范畴，"忘记"了部分结构。例如：

- $U: \text{Grp} \to \text{Set}$ 将群映射为其底层集合，将群同态映射为其底层函数。
- $U: \text{Ring} \to \text{Grp}$ 将环映射为其加法群，将环同态映射为群同态。

### 6.2 幂集函子

**幂集函子** $\mathcal{P}: \text{Set} \to \text{Set}$ 定义为：

- 对于集合 $X$，$\mathcal{P}(X)$ 是 $X$ 的所有子集构成的集合。
- 对于函数 $f: X \to Y$，$\mathcal{P}(f): \mathcal{P}(X) \to \mathcal{P}(Y)$ 将 $X$ 的子集 $A$ 映射为 $f(A) = \{f(a) \mid a \in A\}$。

### 6.3 Hom 函子

对于范畴 $\mathcal{C}$ 中的固定对象 $A$，**Hom 函子** $\text{Hom}_{\mathcal{C}}(A, -): \mathcal{C} \to \text{Set}$ 定义为：

- 对于对象 $X$，$\text{Hom}_{\mathcal{C}}(A, X)$ 是从 $A$ 到 $X$ 的所有态射构成的集合。
- 对于态射 $f: X \to Y$，$\text{Hom}_{\mathcal{C}}(A, f): \text{Hom}_{\mathcal{C}}(A, X) \to \text{Hom}_{\mathcal{C}}(A, Y)$ 将态射 $g: A \to X$ 映射为复合态射 $f \circ g: A \to Y$。

类似地，可以定义反变 Hom 函子 $\text{Hom}_{\mathcal{C}}(-, A): \mathcal{C}^{\text{op}} \to \text{Set}$。

## 7. 自然变换的例子

### 7.1 单位与余单位

设 $F: \mathcal{C} \to \mathcal{D}$ 和 $G: \mathcal{D} \to \mathcal{C}$ 是函子，如果存在自然变换 $\eta: \text{Id}_{\mathcal{C}} \Rightarrow G \circ F$，则称 $\eta$ 为 $F$ 和 $G$ 的**单位**；如果存在自然变换 $\varepsilon: F \circ G \Rightarrow \text{Id}_{\mathcal{D}}$，则称 $\varepsilon$ 为 $F$ 和 $G$ 的**余单位**。

### 7.2 双对偶空间的标准嵌入

在向量空间范畴 $\text{Vect}_k$ 中，考虑双对偶函子 $(-^{**}): \text{Vect}_k \to \text{Vect}_k$，它将向量空间 $V$ 映射为其双对偶空间 $V^{**}$。存在一个自然变换 $\eta: \text{Id}_{\text{Vect}_k} \Rightarrow (-^{**})$，其中 $\eta_V: V \to V^{**}$ 是标准嵌入，定义为 $\eta_V(v)(f) = f(v)$，对于所有 $v \in V$ 和 $f \in V^*$。

### 7.3 集合与幂集之间的关系

考虑幂集函子 $\mathcal{P}: \text{Set} \to \text{Set}$ 和单元素集合函子 $\{-\}: \text{Set} \to \text{Set}$，其中 $\{-\}(X) = \{\{x\} \mid x \in X\}$。存在一个自然变换 $\eta: \{-\} \Rightarrow \mathcal{P}$，其中 $\eta_X: \{-\}(X) \to \mathcal{P}(X)$ 是包含映射。

## 8. Yoneda 引理

### 8.1 表示函子

对于范畴 $\mathcal{C}$ 中的对象 $A$，**协变表示函子** $h^A = \text{Hom}_{\mathcal{C}}(A, -): \mathcal{C} \to \text{Set}$ 和**反变表示函子** $h_A = \text{Hom}_{\mathcal{C}}(-, A): \mathcal{C}^{\text{op}} \to \text{Set}$ 是范畴论中的基本函子。

### 8.2 Yoneda 嵌入

**Yoneda 嵌入**是一个函子 $Y: \mathcal{C} \to [\mathcal{C}^{\text{op}}, \text{Set}]$，它将对象 $A$ 映射为反变表示函子 $h_A$，将态射 $f: A \to B$ 映射为自然变换 $h_f: h_A \Rightarrow h_B$，其中 $h_f$ 在对象 $X$ 处的分量 $(h_f)_X: \text{Hom}_{\mathcal{C}}(X, A) \to \text{Hom}_{\mathcal{C}}(X, B)$ 将态射 $g: X \to A$ 映射为复合态射 $f \circ g: X \to B$。

### 8.3 Yoneda 引理的陈述

**Yoneda 引理**是范畴论中的基本结果，它陈述了：

对于任意范畴 $\mathcal{C}$，任意对象 $A \in \mathcal{C}$ 和任意函子 $F: \mathcal{C}^{\text{op}} \to \text{Set}$，存在一个自然的双射：

$$\text{Nat}(h_A, F) \cong F(A)$$

其中 $\text{Nat}(h_A, F)$ 表示从 $h_A$ 到 $F$ 的所有自然变换构成的集合。

这个双射将自然变换 $\eta: h_A \Rightarrow F$ 映射为元素 $\eta_A(\text{id}_A) \in F(A)$。

### 8.4 Yoneda 引理的意义

Yoneda 引理有深远的意义：

1. 它表明对象 $A$ 可以通过其与其他对象的关系（即 $h_A$）完全确定。
2. 它建立了范畴 $\mathcal{C}$ 与函子范畴 $[\mathcal{C}^{\text{op}}, \text{Set}]$ 之间的联系。
3. 它是许多范畴论结果的基础，如表示定理和伴随函子定理。

## 9. 函子范畴

### 9.1 函子范畴的定义

给定两个范畴 $\mathcal{C}$ 和 $\mathcal{D}$，**函子范畴** $[\mathcal{C}, \mathcal{D}]$ 定义为：

- **对象**：从 $\mathcal{C}$ 到 $\mathcal{D}$ 的所有函子
- **态射**：函子之间的自然变换
- **合成**：自然变换的垂直合成
- **恒等态射**：恒等自然变换

### 9.2 函子范畴的性质

函子范畴具有许多重要性质：

1. 如果 $\mathcal{D}$ 是完备的（有所有小极限），则 $[\mathcal{C}, \mathcal{D}]$ 也是完备的。
2. 如果 $\mathcal{D}$ 是余完备的（有所有小余极限），则 $[\mathcal{C}, \mathcal{D}]$ 也是余完备的。
3. 函子范畴中的极限和余极限是逐点计算的。

## 10. 函子与自然变换的应用

### 10.1 代数拓扑中的应用

函子和自然变换在代数拓扑中有广泛应用：

1. **同调函子**：将拓扑空间映射为其同调群的函子。
2. **上同调函子**：将拓扑空间映射为其上同调群的函子。
3. **基本群函子**：将拓扑空间映射为其基本群的函子。

### 10.2 代数几何中的应用

在代数几何中，函子用于连接不同的几何和代数结构：

1. **全局截面函子**：将层映射为其全局截面的函子。
2. **结构层函子**：将代数簇映射为其结构层的函子。

### 10.3 计算机科学中的应用

函子和自然变换在计算机科学中也有重要应用：

1. **数据类型**：代数数据类型可以看作是函子。
2. **函数式编程**：单子（monad）是函子与自然变换的特殊组合。
3. **范畴语义学**：使用函子将编程语言结构映射到数学结构。

## 11. 练习与应用

### 11.1 验证函子

**练习**：验证忘却函子 $U: \text{Grp} \to \text{Set}$ 满足函子的公理。

### 11.2 构造自然变换

**练习**：构造从恒等函子 $\text{Id}_{\text{Set}}$ 到幂集函子 $\mathcal{P}$ 的自然变换。

### 11.3 应用 Yoneda 引理

**练习**：使用 Yoneda 引理证明：如果两个对象 $A$ 和 $B$ 的表示函子 $h_A$ 和 $h_B$ 同构，则 $A$ 和 $B$ 同构。

## 12. 参考文献

1. Mac Lane, S. (1998). *Categories for the Working Mathematician* (2nd ed.). Springer.
2. Awodey, S. (2010). *Category Theory* (2nd ed.). Oxford University Press.
3. Leinster, T. (2014). *Basic Category Theory*. Cambridge University Press.
4. Riehl, E. (2017). *Category Theory in Context*. Dover Publications.

---

**创建日期**: 2025-07-03
**最后更新**: 2025-07-03
