# 微积分与分析总览 (Calculus and Analysis Overview)

## 目录

- [微积分与分析总览 (Calculus and Analysis Overview)](#微积分与分析总览-calculus-and-analysis-overview)
  - [目录](#目录)
  - [1. 引言](#1-引言)
  - [2. 理论基础](#2-理论基础)
    - [2.1 基础理论文档](#21-基础理论文档)
    - [2.2 核心理论框架](#22-核心理论框架)
  - [3. 核心概念](#3-核心概念)
    - [3.1 极限与连续性](#31-极限与连续性)
    - [3.2 导数与微分](#32-导数与微分)
    - [3.3 积分](#33-积分)
  - [4. 主要分支](#4-主要分支)
    - [4.1 实分析](#41-实分析)
    - [4.2 复分析](#42-复分析)
    - [4.3 泛函分析](#43-泛函分析)
    - [4.4 微分方程](#44-微分方程)
  - [5. 应用领域](#5-应用领域)
    - [5.1 物理学](#51-物理学)
    - [5.2 工程学](#52-工程学)
    - [5.3 经济学](#53-经济学)
    - [5.4 生物学](#54-生物学)
  - [6. 学习路径](#6-学习路径)
    - [6.1 基础阶段](#61-基础阶段)
    - [6.2 进阶阶段](#62-进阶阶段)
    - [6.3 高级阶段](#63-高级阶段)
  - [7. 参考文献](#7-参考文献)
    - [7.1 基础教材](#71-基础教材)
    - [7.2 进阶教材](#72-进阶教材)
    - [7.3 专业教材](#73-专业教材)

## 1. 引言

微积分与分析是数学的核心分支，研究连续变化和累积过程。本主题从多个视角探讨微积分与分析：

- **基础视角**：实数理论、极限理论、连续性理论
- **运算视角**：微分运算、积分运算、微积分基本定理
- **演化视角**：数系从自然数到实数的演化过程
- **应用视角**：物理、工程、经济等领域的应用

### 1.1 核心目标

1. **建立严格的数学基础**
2. **揭示微积分的深层结构**
3. **探索数系演化的规律**
4. **提供形式化的证明和实现**

### 1.2 理论基础

- **集合论基础**：[见 02-数学基础与逻辑/01-集合论基础.md](../02-数学基础与逻辑/01-集合论基础.md)
- **逻辑基础**：[见 02-数学基础与逻辑/02-数理逻辑基础.md](../02-数学基础与逻辑/02-数理逻辑基础.md)
- **代数基础**：[见 02-代数结构与理论/02-抽象代数理论.md](../02-代数结构与理论/02-抽象代数理论.md)

## 2. 理论基础

### 2.1 实数完备性

#### 2.1.1 Dedekind分割

**定义 2.1.1** Dedekind分割是构造实数的方法，通过有理数的分割定义实数。

**构造过程**：
1. 将有理数集 \(\mathbb{Q}\) 分为两个非空子集 \(A\) 和 \(B\)
2. 满足：\(\forall a \in A, \forall b \in B, a < b\)
3. \(A\) 没有最大元，\(B\) 没有最小元

**完备性定理**：实数集 \(\mathbb{R}\) 是完备的，即每个有上界的非空子集都有最小上界。

**Rust实现**：
```rust
#[derive(Debug, Clone)]
struct DedekindCut {
    lower_set: Vec<f64>,
    upper_set: Vec<f64>,
}

impl DedekindCut {
    fn new(lower_set: Vec<f64>, upper_set: Vec<f64>) -> Self {
        DedekindCut { lower_set, upper_set }
    }
    
    fn is_valid(&self) -> bool {
        // 检查分割的有效性
        for &a in &self.lower_set {
            for &b in &self.upper_set {
                if a >= b {
                    return false;
                }
            }
        }
        true
    }
    
    fn supremum(&self) -> Option<f64> {
        if self.lower_set.is_empty() {
            self.upper_set.iter().min().copied()
        } else {
            Some(self.lower_set.iter().fold(f64::NEG_INFINITY, |a, &b| a.max(b)))
        }
    }
}
```

**Haskell实现**：
```haskell
data DedekindCut = DedekindCut {
    lowerSet :: [Double],
    upperSet :: [Double]
} deriving (Show, Eq)

isValid :: DedekindCut -> Bool
isValid (DedekindCut lower upper) = 
    all (\(a, b) -> a < b) [(a, b) | a <- lower, b <- upper]

supremum :: DedekindCut -> Maybe Double
supremum (DedekindCut lower _) = 
    if null lower then Nothing else Just (maximum lower)
```

#### 2.1.2 Cauchy序列

**定义 2.1.2** Cauchy序列是满足Cauchy条件的序列：
\[\forall \varepsilon > 0, \exists N \in \mathbb{N}, \forall m, n > N, |a_m - a_n| < \varepsilon\]

**完备性定理**：实数集 \(\mathbb{R}\) 中每个Cauchy序列都收敛。

**Rust实现**：
```rust
#[derive(Debug, Clone)]
struct CauchySequence {
    terms: Vec<f64>,
}

impl CauchySequence {
    fn new(terms: Vec<f64>) -> Self {
        CauchySequence { terms }
    }
    
    fn is_cauchy(&self, epsilon: f64) -> bool {
        for i in 0..self.terms.len() {
            for j in (i + 1)..self.terms.len() {
                if (self.terms[i] - self.terms[j]).abs() >= epsilon {
                    return false;
                }
            }
        }
        true
    }
    
    fn limit(&self) -> Option<f64> {
        if self.terms.is_empty() {
            None
        } else {
            Some(self.terms[self.terms.len() - 1])
        }
    }
}
```

**Haskell实现**：
```haskell
data CauchySequence = CauchySequence {
    terms :: [Double]
} deriving (Show, Eq)

isCauchy :: CauchySequence -> Double -> Bool
isCauchy (CauchySequence terms) epsilon = 
    all (\(i, j) -> abs (terms !! i - terms !! j) < epsilon) 
        [(i, j) | i <- [0..length terms - 1], j <- [i+1..length terms - 1]]

limit :: CauchySequence -> Maybe Double
limit (CauchySequence terms) = 
    if null terms then Nothing else Just (last terms)
```

### 2.2 极限理论

#### 2.2.1 函数极限

**定义 2.2.1** 函数 \(f\) 在点 \(a\) 的极限为 \(L\)，记作：
\[\lim_{x \to a} f(x) = L\]

如果：
\[\forall \varepsilon > 0, \exists \delta > 0, \forall x, 0 < |x - a| < \delta \implies |f(x) - L| < \varepsilon\]

**Rust实现**：
```rust
trait Function {
    fn evaluate(&self, x: f64) -> f64;
}

struct Polynomial {
    coefficients: Vec<f64>,
}

impl Function for Polynomial {
    fn evaluate(&self, x: f64) -> f64 {
        self.coefficients.iter()
            .enumerate()
            .map(|(i, &coef)| coef * x.powi(i as i32))
            .sum()
    }
}

fn limit<F: Function>(f: &F, a: f64, epsilon: f64) -> Option<f64> {
    // 简化的极限计算
    let delta = epsilon / 10.0;
    let left = f.evaluate(a - delta);
    let right = f.evaluate(a + delta);
    
    if (left - right).abs() < epsilon {
        Some((left + right) / 2.0)
    } else {
        None
    }
}
```

**Haskell实现**：
```haskell
class Function f where
    evaluate :: f -> Double -> Double

data Polynomial = Polynomial [Double] deriving (Show)

instance Function Polynomial where
    evaluate (Polynomial coeffs) x = 
        sum [coeff * x^i | (coeff, i) <- zip coeffs [0..]]

limit :: Function f => f -> Double -> Double -> Maybe Double
limit f a epsilon = 
    let delta = epsilon / 10
        left = evaluate f (a - delta)
        right = evaluate f (a + delta)
    in if abs (left - right) < epsilon 
       then Just ((left + right) / 2)
       else Nothing
```

#### 2.2.2 序列极限

**定义 2.2.2** 序列 \(\{a_n\}\) 的极限为 \(L\)，记作：
\[\lim_{n \to \infty} a_n = L\]

如果：
\[\forall \varepsilon > 0, \exists N \in \mathbb{N}, \forall n > N, |a_n - L| < \varepsilon\]

## 3. 数系演化

### 3.1 自然数到整数

#### 3.1.1 自然数公理

**Peano公理**：
1. 0是自然数
2. 每个自然数都有唯一的后继
3. 0不是任何自然数的后继
4. 不同的自然数有不同的后继
5. 数学归纳原理

**Rust实现**：
```rust
#[derive(Debug, Clone, PartialEq)]
enum Natural {
    Zero,
    Successor(Box<Natural>),
}

impl Natural {
    fn zero() -> Natural {
        Natural::Zero
    }
    
    fn successor(n: Natural) -> Natural {
        Natural::Successor(Box::new(n))
    }
    
    fn to_u64(&self) -> u64 {
        match self {
            Natural::Zero => 0,
            Natural::Successor(n) => 1 + n.to_u64(),
        }
    }
    
    fn from_u64(n: u64) -> Natural {
        if n == 0 {
            Natural::Zero
        } else {
            Natural::Successor(Box::new(Natural::from_u64(n - 1)))
        }
    }
}
```

**Haskell实现**：
```haskell
data Natural = Zero | Successor Natural deriving (Show, Eq)

instance Num Natural where
    Zero + n = n
    Successor m + n = Successor (m + n)
    
    Zero * _ = Zero
    Successor m * n = n + m * n
    
    abs = id
    signum Zero = Zero
    signum _ = Successor Zero
    
    fromInteger 0 = Zero
    fromInteger n = Successor (fromInteger (n - 1))
```

#### 3.1.2 整数构造

**定义 3.1.1** 整数通过自然数对的等价关系构造：
\[(a, b) \sim (c, d) \iff a + d = b + c\]

**Rust实现**：
```rust
#[derive(Debug, Clone, PartialEq)]
struct Integer {
    positive: u64,
    negative: u64,
}

impl Integer {
    fn new(positive: u64, negative: u64) -> Integer {
        Integer { positive, negative }
    }
    
    fn normalize(&self) -> Integer {
        let min_val = self.positive.min(self.negative);
        Integer::new(self.positive - min_val, self.negative - min_val)
    }
    
    fn to_i64(&self) -> i64 {
        self.positive as i64 - self.negative as i64
    }
}
```

**Haskell实现**：
```haskell
data Integer = Integer { positive :: Natural, negative :: Natural } deriving (Show, Eq)

normalize :: Integer -> Integer
normalize (Integer pos neg) = 
    let minVal = minimum [pos, neg]
    in Integer (pos - minVal) (neg - minVal)

toInt :: Integer -> Int
toInt (Integer pos neg) = fromEnum pos - fromEnum neg
```

### 3.2 有理数到实数

#### 3.2.1 有理数构造

**定义 3.2.1** 有理数通过整数对的等价关系构造：
\[(a, b) \sim (c, d) \iff a \cdot d = b \cdot c\]

**Rust实现**：
```rust
#[derive(Debug, Clone)]
struct Rational {
    numerator: i64,
    denominator: u64,
}

impl Rational {
    fn new(numerator: i64, denominator: u64) -> Rational {
        if denominator == 0 {
            panic!("Denominator cannot be zero");
        }
        Rational { numerator, denominator }
    }
    
    fn simplify(&self) -> Rational {
        let gcd = self.gcd(self.numerator.abs() as u64, self.denominator);
        Rational::new(self.numerator / gcd as i64, self.denominator / gcd)
    }
    
    fn gcd(&self, a: u64, b: u64) -> u64 {
        if b == 0 { a } else { self.gcd(b, a % b) }
    }
    
    fn to_f64(&self) -> f64 {
        self.numerator as f64 / self.denominator as f64
    }
}
```

**Haskell实现**：
```haskell
data Rational = Rational { numerator :: Integer, denominator :: Natural } deriving (Show, Eq)

simplify :: Rational -> Rational
simplify (Rational num den) = 
    let gcd_val = gcd (abs num) den
    in Rational (num `div` gcd_val) (den `div` gcd_val)

toDouble :: Rational -> Double
toDouble (Rational num den) = fromIntegral num / fromIntegral den
```

#### 3.2.2 实数构造

**定义 3.2.2** 实数通过Dedekind分割或Cauchy序列构造。

**Rust实现**：
```rust
#[derive(Debug, Clone)]
struct Real {
    dedekind_cut: DedekindCut,
}

impl Real {
    fn new(cut: DedekindCut) -> Real {
        Real { dedekind_cut: cut }
    }
    
    fn from_rational(r: &Rational) -> Real {
        let q = r.to_f64();
        let lower_set = vec![q - 0.1, q - 0.01, q - 0.001];
        let upper_set = vec![q + 0.1, q + 0.01, q + 0.001];
        Real::new(DedekindCut::new(lower_set, upper_set))
    }
    
    fn sqrt_2() -> Real {
        // 构造√2的Dedekind分割
        let lower_set = vec![1.0, 1.4, 1.41, 1.414];
        let upper_set = vec![2.0, 1.5, 1.42, 1.415];
        Real::new(DedekindCut::new(lower_set, upper_set))
    }
}
```

**Haskell实现**：
```haskell
data Real = Real { dedekindCut :: DedekindCut } deriving (Show, Eq)

fromRational :: Rational -> Real
fromRational r = 
    let q = toDouble r
        lowerSet = [q - 0.1, q - 0.01, q - 0.001]
        upperSet = [q + 0.1, q + 0.01, q + 0.001]
    in Real (DedekindCut lowerSet upperSet)

sqrt2 :: Real
sqrt2 = Real (DedekindCut [1.0, 1.4, 1.41, 1.414] [2.0, 1.5, 1.42, 1.415])
```

## 4. 极限理论

### 4.1 连续性

#### 4.1.1 函数连续性

**定义 4.1.1** 函数 \(f\) 在点 \(a\) 连续，如果：
\[\lim_{x \to a} f(x) = f(a)\]

**定理 4.1.1** 连续函数的性质：
1. 连续函数的和、差、积、商（分母不为零）都是连续的
2. 连续函数的复合函数是连续的
3. 闭区间上的连续函数有最大值和最小值

**Rust实现**：
```rust
trait ContinuousFunction: Function {
    fn is_continuous_at(&self, a: f64, epsilon: f64) -> bool {
        if let Some(limit_val) = limit(self, a, epsilon) {
            (self.evaluate(a) - limit_val).abs() < epsilon
        } else {
            false
        }
    }
}

impl ContinuousFunction for Polynomial {}
```

**Haskell实现**：
```haskell
class (Function f) => ContinuousFunction f where
    isContinuousAt :: f -> Double -> Double -> Bool
    isContinuousAt f a epsilon = 
        case limit f a epsilon of
            Just limitVal -> abs (evaluate f a - limitVal) < epsilon
            Nothing -> False

instance ContinuousFunction Polynomial
```

#### 4.1.2 一致连续性

**定义 4.1.2** 函数 \(f\) 在集合 \(A\) 上一致连续，如果：
\[\forall \varepsilon > 0, \exists \delta > 0, \forall x, y \in A, |x - y| < \delta \implies |f(x) - f(y)| < \varepsilon\]

**定理 4.1.2** 闭区间上的连续函数是一致连续的。

## 5. 微分学

### 5.1 导数定义

#### 5.1.1 函数导数

**定义 5.1.1** 函数 \(f\) 在点 \(a\) 的导数为：
\[f'(a) = \lim_{h \to 0} \frac{f(a + h) - f(a)}{h}\]

**Rust实现**：
```rust
trait DifferentiableFunction: Function {
    fn derivative_at(&self, a: f64, h: f64) -> f64 {
        (self.evaluate(a + h) - self.evaluate(a)) / h
    }
    
    fn derivative_function(&self) -> Box<dyn Function> {
        // 简化的导数函数实现
        Box::new(Polynomial { coefficients: vec![0.0, 1.0] })
    }
}

impl DifferentiableFunction for Polynomial {}
```

**Haskell实现**：
```haskell
class (Function f) => DifferentiableFunction f where
    derivativeAt :: f -> Double -> Double -> Double
    derivativeAt f a h = (evaluate f (a + h) - evaluate f a) / h
    
    derivativeFunction :: f -> Polynomial
    derivativeFunction _ = Polynomial [0, 1]  -- 简化实现

instance DifferentiableFunction Polynomial
```

#### 5.1.2 导数性质

**定理 5.1.1** 导数的基本性质：
1. \((f + g)'(x) = f'(x) + g'(x)\)
2. \((f \cdot g)'(x) = f'(x)g(x) + f(x)g'(x)\)
3. \((\frac{f}{g})'(x) = \frac{f'(x)g(x) - f(x)g'(x)}{g(x)^2}\)

### 5.2 微分应用

#### 5.2.1 极值问题

**定义 5.2.1** 函数 \(f\) 在点 \(a\) 取得局部极值，如果存在邻域 \(U\)，使得：
- 局部最大值：\(\forall x \in U, f(x) \leq f(a)\)
- 局部最小值：\(\forall x \in U, f(x) \geq f(a)\)

**定理 5.2.1** 费马定理：如果 \(f\) 在点 \(a\) 可导且取得局部极值，则 \(f'(a) = 0\)。

## 6. 积分学

### 6.1 定积分

#### 6.1.1 Riemann积分

**定义 6.1.1** 函数 \(f\) 在区间 \([a, b]\) 上的Riemann积分为：
\[\int_a^b f(x) dx = \lim_{n \to \infty} \sum_{i=1}^n f(\xi_i) \Delta x_i\]

**Rust实现**：
```rust
trait IntegrableFunction: Function {
    fn riemann_integral(&self, a: f64, b: f64, n: usize) -> f64 {
        let dx = (b - a) / n as f64;
        (0..n).map(|i| {
            let x = a + i as f64 * dx;
            self.evaluate(x) * dx
        }).sum()
    }
}

impl IntegrableFunction for Polynomial {}
```

**Haskell实现**：
```haskell
class (Function f) => IntegrableFunction f where
    riemannIntegral :: f -> Double -> Double -> Int -> Double
    riemannIntegral f a b n = 
        let dx = (b - a) / fromIntegral n
        in sum [evaluate f (a + fromIntegral i * dx) * dx | i <- [0..n-1]]

instance IntegrableFunction Polynomial
```

#### 6.1.2 微积分基本定理

**定理 6.1.1** 微积分基本定理：
如果 \(f\) 在 \([a, b]\) 上连续，\(F\) 是 \(f\) 的原函数，则：
\[\int_a^b f(x) dx = F(b) - F(a)\]

## 7. 非标准分析

### 7.1 超实数

#### 7.1.1 超实数构造

**定义 7.1.1** 超实数通过超滤子构造，包含标准实数和无穷小量。

**Rust实现**：
```rust
#[derive(Debug, Clone)]
struct Hyperreal {
    standard_part: f64,
    infinitesimal_part: f64,
}

impl Hyperreal {
    fn new(standard: f64, infinitesimal: f64) -> Hyperreal {
        Hyperreal {
            standard_part: standard,
            infinitesimal_part: infinitesimal,
        }
    }
    
    fn is_infinitesimal(&self) -> bool {
        self.standard_part == 0.0 && self.infinitesimal_part != 0.0
    }
    
    fn is_infinite(&self) -> bool {
        self.standard_part.abs() == f64::INFINITY
    }
}
```

**Haskell实现**：
```haskell
data Hyperreal = Hyperreal {
    standardPart :: Double,
    infinitesimalPart :: Double
} deriving (Show, Eq)

isInfinitesimal :: Hyperreal -> Bool
isInfinitesimal (Hyperreal std inf) = std == 0 && inf /= 0

isInfinite :: Hyperreal -> Bool
isInfinite (Hyperreal std _) = abs std == 1/0
```

### 7.2 非标准微积分

#### 7.2.1 非标准导数

**定义 7.2.1** 非标准导数定义为：
\[f'(a) = \text{st}\left(\frac{f(a + \varepsilon) - f(a)}{\varepsilon}\right)\]

其中 \(\varepsilon\) 是无穷小量，\(\text{st}\) 是标准部分函数。

## 8. 应用领域

### 8.1 物理学应用

#### 8.1.1 经典力学

- **运动学**：位置、速度、加速度的关系
- **动力学**：牛顿运动定律的微分形式
- **能量守恒**：动能和势能的积分关系

#### 8.1.2 电磁学

- **电场**：电势的梯度
- **磁场**：磁通量的变化率
- **电磁波**：波动方程的微分形式

### 8.2 工程应用

#### 8.2.1 结构力学

- **应力分析**：应力和应变的微分关系
- **变形计算**：位移的积分计算
- **稳定性分析**：临界点的导数分析

#### 8.2.2 信号处理

- **傅里叶变换**：信号的频域分析
- **滤波器设计**：微分方程的应用
- **控制系统**：传递函数的分析

### 8.3 经济应用

#### 8.3.1 微观经济学

- **边际分析**：边际成本和边际收益
- **弹性分析**：需求弹性的计算
- **优化问题**：效用最大化

#### 8.3.2 金融工程

- **期权定价**：Black-Scholes方程
- **风险管理**：VaR的计算
- **投资组合**：最优配置的求解

## 9. 学习路径

### 9.1 基础路径

1. **数系基础**：[见 04-微积分与分析/01-数系演化理论.md](01-数系演化理论.md)
2. **极限理论**：[见 04-微积分与分析/02-极限理论.md](02-极限理论.md)
3. **连续性理论**：[见 04-微积分与分析/03-连续性理论.md](03-连续性理论.md)
4. **微分学**：[见 04-微积分与分析/04-微分学.md](04-微分学.md)

### 9.2 进阶路径

1. **积分学**：[见 04-微积分与分析/05-积分学.md](05-积分学.md)
2. **非标准分析**：[见 04-微积分与分析/06-非标准分析.md](06-非标准分析.md)
3. **变分法**：[见 04-微积分与分析/07-变分法.md](07-变分法.md)
4. **微分方程**：[见 04-微积分与分析/08-微分方程.md](08-微分方程.md)

### 9.3 应用路径

1. **实分析**：[见 04-微积分与分析/09-实分析.md](09-实分析.md)
2. **复分析**：[见 04-微积分与分析/10-复分析.md](10-复分析.md)
3. **泛函分析**：[见 04-微积分与分析/11-泛函分析.md](11-泛函分析.md)

## 10. 资源索引

### 10.1 核心文档

- [01-数系演化理论.md](01-数系演化理论.md)：数系从自然数到实数的演化
- [02-极限理论.md](02-极限理论.md)：极限的基本理论和应用
- [03-连续性理论.md](03-连续性理论.md)：连续性的定义和性质
- [04-微分学.md](04-微分学.md)：导数的定义、性质和应用
- [05-积分学.md](05-积分学.md)：积分的定义、性质和应用
- [06-非标准分析.md](06-非标准分析.md)：非标准分析基础
- [07-变分法.md](07-变分法.md)：变分法理论
- [08-微分方程.md](08-微分方程.md)：微分方程理论

### 10.2 相关主题

- **数学基础与逻辑**：[见 02-数学基础与逻辑/00-数学基础与逻辑总览.md](../02-数学基础与逻辑/00-数学基础与逻辑总览.md)
- **代数结构与理论**：[见 02-代数结构与理论/00-代数结构与理论总览.md](../02-代数结构与理论/00-代数结构与理论总览.md)
- **几何与空间结构**：[见 05-几何与空间结构/00-几何与空间结构总览.md](../05-几何与空间结构/00-几何与空间结构总览.md)

### 10.3 外部资源

#### 10.3.1 经典教材

- **微积分**：
  - Stewart, "Calculus"
  - Apostol, "Calculus"
  - Spivak, "Calculus"

- **实分析**：
  - Rudin, "Principles of Mathematical Analysis"
  - Royden, "Real Analysis"
  - Folland, "Real Analysis"

#### 10.3.2 在线资源

- **课程**：
  - MIT OpenCourseWare: Calculus
  - Coursera: Calculus
  - edX: Real Analysis

- **工具**：
  - Wolfram Alpha: 符号计算
  - GeoGebra: 几何可视化
  - Desmos: 函数绘图

#### 10.3.3 研究前沿

- **非标准分析**：超实数理论、非标准微积分
- **变分法**：最优控制、变分不等式
- **微分方程**：动力系统、分岔理论
- **泛函分析**：算子理论、谱理论

## 11. 总结

微积分与分析是数学的核心分支，通过研究连续变化和累积过程，为理解自然现象和解决实际问题提供了强大的工具。从基础的数系演化到高级的非标准分析，微积分理论展现了数学的深刻性和普适性。

本主题不仅涵盖传统的微积分理论，还探索了数系演化、非标准分析等现代发展，展现了微积分在物理、工程、经济等领域的广泛应用。通过严格的形式化方法和丰富的应用实例，我们建立了完整的微积分与分析知识体系。

**下一步**：继续深入各个子主题，建立更详细的理论框架和应用实例。

---

**相关链接**：

- [返回项目总览](../../00-项目总览/00-项目总览.md)
- [数学基础与逻辑](../02-数学基础与逻辑/00-数学基础与逻辑总览.md)
- [代数结构与理论](../03-代数结构与理论/00-代数结构与理论总览.md)
- [几何与空间结构](../05-几何与空间结构/00-几何与空间结构总览.md)
- [数论与离散数学](../06-数论与离散数学/00-数论与离散数学总览.md)
- [概率统计与随机过程](../07-概率统计与随机过程/00-概率统计与随机过程总览.md)
- [跨学科应用与联系](../08-跨学科应用与联系/00-跨学科应用与联系总览.md)
- [元数学与形式化](../09-元数学与形式化/00-元数学与形式化总览.md)
