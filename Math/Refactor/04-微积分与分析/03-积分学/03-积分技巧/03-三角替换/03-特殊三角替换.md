# 特殊三角替换

## 目录

1. [基本概念](#基本概念)
2. [高次幂替换](#高次幂替换)
3. [混合函数替换](#混合函数替换)
4. [参数化替换](#参数化替换)
5. [分段函数替换](#分段函数替换)
6. [极限情况处理](#极限情况处理)
7. [数值方法](#数值方法)
8. [应用实例](#应用实例)
9. [代码实现](#代码实现)
10. [相关文件](#相关文件)

## 基本概念

### 定义

特殊三角替换是处理复杂积分形式的三角替换技巧，包括高次幂、混合函数、参数化等特殊情况。

### 核心思想

通过巧妙的变量替换和数学技巧，将复杂的特殊积分转化为可计算的标准形式。

### 基本原理

1. **递推法**：利用递推公式处理高次幂
2. **分解法**：将复杂函数分解为基本形式
3. **参数化法**：引入参数简化表达式
4. **分段法**：按区间分别处理

## 高次幂替换

### 基本形式

对于 $\int \sin^n\theta \cos^m\theta d\theta$ 形式的积分。

### 递推公式

#### 1. 正弦幂积分

**递推公式**：

$$\int \sin^n\theta d\theta = -\frac{\sin^{n-1}\theta \cos\theta}{n} + \frac{n-1}{n}\int \sin^{n-2}\theta d\theta$$

**证明**：

1. 使用分部积分：设 $u = \sin^{n-1}\theta$，$dv = \sin\theta d\theta$
2. 则 $du = (n-1)\sin^{n-2}\theta \cos\theta d\theta$，$v = -\cos\theta$
3. 积分变为：$-\sin^{n-1}\theta \cos\theta + (n-1)\int \sin^{n-2}\theta \cos^2\theta d\theta$
4. 使用三角恒等式：$\cos^2\theta = 1 - \sin^2\theta$
5. 得到递推公式

#### 2. 余弦幂积分

**递推公式**：

$$\int \cos^n\theta d\theta = \frac{\cos^{n-1}\theta \sin\theta}{n} + \frac{n-1}{n}\int \cos^{n-2}\theta d\theta$$

**证明**：

1. 使用分部积分：设 $u = \cos^{n-1}\theta$，$dv = \cos\theta d\theta$
2. 则 $du = -(n-1)\cos^{n-2}\theta \sin\theta d\theta$，$v = \sin\theta$
3. 积分变为：$\cos^{n-1}\theta \sin\theta + (n-1)\int \cos^{n-2}\theta \sin^2\theta d\theta$
4. 使用三角恒等式：$\sin^2\theta = 1 - \cos^2\theta$
5. 得到递推公式

#### 3. 混合幂积分

**递推公式**：

$$\int \sin^n\theta \cos^m\theta d\theta = \frac{\sin^{n+1}\theta \cos^{m-1}\theta}{n+m} + \frac{m-1}{n+m}\int \sin^n\theta \cos^{m-2}\theta d\theta$$

**证明**：

1. 使用分部积分：设 $u = \sin^n\theta \cos^{m-1}\theta$，$dv = \cos\theta d\theta$
2. 则 $du = n\sin^{n-1}\theta \cos^m\theta d\theta - (m-1)\sin^n\theta \cos^{m-2}\theta \sin\theta d\theta$
3. $v = \sin\theta$
4. 积分变为：$\sin^{n+1}\theta \cos^{m-1}\theta - n\int \sin^n\theta \cos^m\theta d\theta + (m-1)\int \sin^{n+1}\theta \cos^{m-2}\theta d\theta$
5. 使用三角恒等式：$\sin^{n+1}\theta = \sin^n\theta \sin\theta$
6. 得到递推公式

### 应用实例

#### 1. 高次正弦积分

**问题**：计算 $\int \sin^5\theta d\theta$

**解法**：

1. 使用递推公式：$\int \sin^5\theta d\theta = -\frac{\sin^4\theta \cos\theta}{5} + \frac{4}{5}\int \sin^3\theta d\theta$
2. 继续递推：$\int \sin^3\theta d\theta = -\frac{\sin^2\theta \cos\theta}{3} + \frac{2}{3}\int \sin\theta d\theta$
3. 基本积分：$\int \sin\theta d\theta = -\cos\theta + C$
4. 回代：$\int \sin^5\theta d\theta = -\frac{\sin^4\theta \cos\theta}{5} - \frac{4\sin^2\theta \cos\theta}{15} - \frac{8\cos\theta}{15} + C$

#### 2. 高次余弦积分

**问题**：计算 $\int \cos^6\theta d\theta$

**解法**：

1. 使用递推公式：$\int \cos^6\theta d\theta = \frac{\cos^5\theta \sin\theta}{6} + \frac{5}{6}\int \cos^4\theta d\theta$
2. 继续递推：$\int \cos^4\theta d\theta = \frac{\cos^3\theta \sin\theta}{4} + \frac{3}{4}\int \cos^2\theta d\theta$
3. 基本积分：$\int \cos^2\theta d\theta = \frac{\theta}{2} + \frac{\sin(2\theta)}{4} + C$
4. 回代：$\int \cos^6\theta d\theta = \frac{\cos^5\theta \sin\theta}{6} + \frac{5\cos^3\theta \sin\theta}{24} + \frac{5\theta}{16} + \frac{5\sin(2\theta)}{32} + C$

#### 3. 混合幂积分

**问题**：计算 $\int \sin^3\theta \cos^4\theta d\theta$

**解法**：

1. 使用递推公式：$\int \sin^3\theta \cos^4\theta d\theta = \frac{\sin^4\theta \cos^3\theta}{7} + \frac{3}{7}\int \sin^3\theta \cos^2\theta d\theta$
2. 继续递推：$\int \sin^3\theta \cos^2\theta d\theta = \frac{\sin^4\theta \cos\theta}{5} + \frac{1}{5}\int \sin^3\theta d\theta$
3. 使用正弦幂积分递推公式
4. 回代得到最终结果

## 混合函数替换

### 基本形式

对于包含多种函数类型的积分，如 $\int f(\sin\theta, \cos\theta, \tan\theta) d\theta$。

### 处理方法

#### 1. 万能替换

使用 $t = \tan\frac{\theta}{2}$ 替换：

$$\sin\theta = \frac{2t}{1+t^2}, \quad \cos\theta = \frac{1-t^2}{1+t^2}, \quad \tan\theta = \frac{2t}{1-t^2}$$

$$d\theta = \frac{2}{1+t^2} dt$$

#### 2. 部分替换

根据积分的特点选择部分替换：

- 如果主要包含 $\sin\theta$ 和 $\cos\theta$，使用 $t = \tan\theta$
- 如果主要包含 $\tan\theta$，使用 $t = \sin\theta$ 或 $t = \cos\theta$

### 应用实例

#### 1. 有理三角函数积分

**问题**：计算 $\int \frac{d\theta}{1 + \sin\theta + \cos\theta}$

**解法**：

1. 使用万能替换：$t = \tan\frac{\theta}{2}$
2. 代入：$\sin\theta = \frac{2t}{1+t^2}$, $\cos\theta = \frac{1-t^2}{1+t^2}$
3. 积分变为：$\int \frac{\frac{2}{1+t^2} dt}{1 + \frac{2t}{1+t^2} + \frac{1-t^2}{1+t^2}}$
4. 简化：$\int \frac{2 dt}{(1+t^2) + 2t + (1-t^2)} = \int \frac{2 dt}{2 + 2t} = \int \frac{dt}{1+t}$
5. 结果：$\ln|1+t| + C = \ln\left|1 + \tan\frac{\theta}{2}\right| + C$

#### 2. 混合幂积分

**问题**：计算 $\int \sin^2\theta \cos^3\theta \tan\theta d\theta$

**解法**：

1. 使用 $\tan\theta = \frac{\sin\theta}{\cos\theta}$
2. 积分变为：$\int \sin^3\theta \cos^2\theta d\theta$
3. 使用混合幂递推公式
4. 得到结果

## 参数化替换

### 基本形式

对于含有参数的积分，如 $\int f(x, a, b, c) dx$。

### 处理方法

#### 1. 参数分离

将参数从变量中分离出来，简化积分。

#### 2. 参数化替换

引入新的参数化变量，简化表达式。

### 应用实例

#### 1. 参数化二次函数

**问题**：计算 $\int \frac{dx}{\sqrt{ax^2 + bx + c}}$，其中 $a, b, c$ 是参数。

**解法**：

1. 配方法：$ax^2 + bx + c = a\left(x + \frac{b}{2a}\right)^2 + \left(c - \frac{b^2}{4a}\right)$
2. 设 $u = x + \frac{b}{2a}$，则 $du = dx$
3. 积分变为：$\int \frac{du}{\sqrt{au^2 + k}}$，其中 $k = c - \frac{b^2}{4a}$
4. 根据 $k$ 的符号选择替换：
   - 如果 $k > 0$：使用正切替换 $u = \sqrt{\frac{k}{a}}\tan\theta$
   - 如果 $k < 0$：使用正割替换 $u = \sqrt{-\frac{k}{a}}\sec\theta$
   - 如果 $k = 0$：使用幂函数积分

#### 2. 参数化指数函数

**问题**：计算 $\int e^{ax} \sqrt{b^2 - x^2} dx$，其中 $a, b$ 是参数。

**解法**：

1. 设 $x = b\sin\theta$，则 $dx = b\cos\theta d\theta$
2. 积分变为：$\int e^{ab\sin\theta} b\cos\theta \cdot b\cos\theta d\theta = b^2\int e^{ab\sin\theta} \cos^2\theta d\theta$
3. 使用分部积分：设 $u = e^{ab\sin\theta}$，$dv = \cos^2\theta d\theta$
4. 得到递推公式或使用数值方法

## 分段函数替换

### 基本形式

对于在不同区间有不同表达式的积分。

### 处理方法

#### 1. 区间分析

分析函数在不同区间的性质，选择合适的替换。

#### 2. 分段积分

将积分区间分段，每段使用不同的替换方法。

### 应用实例

#### 1. 绝对值函数

**问题**：计算 $\int \frac{dx}{\sqrt{|x^2 - 1|}}$

**解法**：

1. 分析区间：
   - 当 $|x| < 1$ 时：$|x^2 - 1| = 1 - x^2$，使用正弦替换
   - 当 $|x| > 1$ 时：$|x^2 - 1| = x^2 - 1$，使用正割替换
2. 分段积分：
   - $\int_{-1}^1 \frac{dx}{\sqrt{1-x^2}} = \pi$
   - $\int_1^{\infty} \frac{dx}{\sqrt{x^2-1}} = \infty$
   - $\int_{-\infty}^{-1} \frac{dx}{\sqrt{x^2-1}} = \infty$

#### 2. 符号函数

**问题**：计算 $\int \text{sgn}(x) \sqrt{1-x^2} dx$

**解法**：

1. 分析区间：
   - 当 $x > 0$ 时：$\text{sgn}(x) = 1$
   - 当 $x < 0$ 时：$\text{sgn}(x) = -1$
2. 分段积分：
   - $\int_0^1 \sqrt{1-x^2} dx = \frac{\pi}{4}$
   - $\int_{-1}^0 (-\sqrt{1-x^2}) dx = -\frac{\pi}{4}$
3. 总结果：$0$

## 极限情况处理

### 基本形式

对于在极限点附近有特殊行为的积分。

### 处理方法

#### 1. 极限分析

分析函数在极限点的行为，确定积分的收敛性。

#### 2. 渐近展开

使用渐近展开方法处理极限情况。

### 应用实例

#### 1. 奇点处理

**问题**：计算 $\int_0^1 \frac{dx}{\sqrt{x(1-x)}}$

**解法**：

1. 分析奇点：在 $x = 0$ 和 $x = 1$ 处有奇点
2. 使用替换：$x = \sin^2\theta$，则 $dx = 2\sin\theta\cos\theta d\theta$
3. 积分变为：$\int_0^{\pi/2} \frac{2\sin\theta\cos\theta d\theta}{\sin\theta\cos\theta} = 2\int_0^{\pi/2} d\theta = \pi$
4. 结果：$\pi$

#### 2. 无穷积分

**问题**：计算 $\int_0^{\infty} \frac{dx}{\sqrt{x^2 + 1}}$

**解法**：

1. 使用正切替换：$x = \tan\theta$，则 $dx = \sec^2\theta d\theta$
2. 积分变为：$\int_0^{\pi/2} \frac{\sec^2\theta d\theta}{\sec\theta} = \int_0^{\pi/2} \sec\theta d\theta$
3. 结果：$\ln|\sec\theta + \tan\theta|_0^{\pi/2} = \infty$
4. 积分发散

## 数值方法

### 基本形式

对于无法用解析方法求解的积分，使用数值方法。

### 处理方法

#### 1. 数值积分

使用数值积分方法，如梯形法则、辛普森法则等。

#### 2. 蒙特卡洛方法

使用蒙特卡洛方法进行数值积分。

### 应用实例

#### 1. 复杂函数积分

**问题**：计算 $\int_0^1 e^{x^2} \sqrt{1-x^2} dx$

**解法**：

1. 使用数值积分方法
2. 将区间分割为小区间
3. 在每个小区间上使用近似公式
4. 累加得到近似结果

## 应用实例

### 1. 物理学应用

#### 1.1 非线性振动

**问题**：计算非线性振动的周期

$$T = 4\int_0^A \frac{dx}{\sqrt{2g(h-x) + \frac{k}{m}x^3}}$$

**解法**：

1. 使用数值方法或特殊函数
2. 分析积分的收敛性
3. 使用渐近展开

#### 1.2 量子力学

**问题**：计算波函数的归一化积分

$$\int_{-\infty}^{\infty} |\psi(x)|^2 dx$$

其中 $\psi(x) = e^{-x^2/2} H_n(x)$，$H_n(x)$ 是厄米多项式。

**解法**：

1. 使用厄米多项式的性质
2. 利用正交性条件
3. 得到归一化常数

### 2. 工程应用

#### 2.1 信号处理

**问题**：计算滤波器的群延迟

$$\tau(\omega) = -\frac{d}{d\omega} \arg H(\omega)$$

其中 $H(\omega)$ 是传递函数。

**解法**：

1. 计算传递函数的相位
2. 对频率求导
3. 使用数值方法

#### 2.2 控制系统

**问题**：计算系统的稳定性裕度

$$\text{GM} = \frac{1}{|G(j\omega_c)|}$$

其中 $\omega_c$ 是相位穿越频率。

**解法**：

1. 求解相位穿越频率
2. 计算增益裕度
3. 使用数值方法

### 3. 经济学应用

#### 3.1 金融数学

**问题**：计算期权的希腊字母

$$\Delta = \frac{\partial V}{\partial S}, \quad \Gamma = \frac{\partial^2 V}{\partial S^2}$$

其中 $V$ 是期权价值，$S$ 是标的资产价格。

**解法**：

1. 使用布莱克-斯科尔斯公式
2. 对价格求偏导数
3. 得到希腊字母

#### 3.2 风险管理

**问题**：计算风险度量

$$\text{CVaR} = \frac{1}{\alpha} \int_{-\infty}^{-\text{VaR}} x f(x) dx$$

其中 $f(x)$ 是损失分布函数。

**解法**：

1. 使用数值积分方法
2. 蒙特卡洛模拟
3. 得到条件风险价值

## 代码实现

### Rust实现

```rust
use std::f64::consts::PI;

/// 特殊三角替换积分计算器
pub struct SpecialTrigonometricSubstitution;

impl SpecialTrigonometricSubstitution {
    /// 高次正弦幂积分
    pub fn high_power_sine_integral(n: u32, theta: f64) -> f64 {
        if n == 0 {
            theta
        } else if n == 1 {
            -theta.cos()
        } else {
            let power = n as f64;
            -theta.sin().powf(power - 1.0) * theta.cos() / power + 
            (power - 1.0) / power * Self::high_power_sine_integral(n - 2, theta)
        }
    }
    
    /// 高次余弦幂积分
    pub fn high_power_cosine_integral(n: u32, theta: f64) -> f64 {
        if n == 0 {
            theta
        } else if n == 1 {
            theta.sin()
        } else {
            let power = n as f64;
            theta.cos().powf(power - 1.0) * theta.sin() / power + 
            (power - 1.0) / power * Self::high_power_cosine_integral(n - 2, theta)
        }
    }
    
    /// 混合幂积分
    pub fn mixed_power_integral(n: u32, m: u32, theta: f64) -> f64 {
        if m == 0 {
            Self::high_power_sine_integral(n, theta)
        } else if n == 0 {
            Self::high_power_cosine_integral(m, theta)
        } else {
            let n_power = n as f64;
            let m_power = m as f64;
            theta.sin().powf(n_power + 1.0) * theta.cos().powf(m_power - 1.0) / (n_power + m_power) +
            (m_power - 1.0) / (n_power + m_power) * Self::mixed_power_integral(n, m - 2, theta)
        }
    }
    
    /// 万能替换积分
    pub fn universal_substitution_integral<F>(f: F, theta: f64) -> f64 
    where F: Fn(f64, f64, f64) -> f64 {
        let t = (theta / 2.0).tan();
        let sin_theta = 2.0 * t / (1.0 + t * t);
        let cos_theta = (1.0 - t * t) / (1.0 + t * t);
        let dtheta_dt = 2.0 / (1.0 + t * t);
        
        f(sin_theta, cos_theta, t) * dtheta_dt
    }
    
    /// 参数化二次函数积分
    pub fn parametric_quadratic_integral(a: f64, b: f64, c: f64, x: f64) -> f64 {
        let discriminant = b * b - 4.0 * a * c;
        let h = -b / (2.0 * a);
        let k = c - (b * b) / (4.0 * a);
        let u = x - h;
        
        if k > 0.0 {
            // 使用正切替换
            let theta = (u / k.sqrt()).atan();
            theta
        } else if k < 0.0 {
            // 使用正割替换
            let theta = (u / (-k).sqrt()).acos();
            theta
        } else {
            // 线性情况
            u.ln()
        }
    }
    
    /// 分段函数积分
    pub fn piecewise_integral<F>(f: F, a: f64, b: f64, breakpoints: &[f64]) -> f64 
    where F: Fn(f64) -> f64 {
        let mut result = 0.0;
        let mut current_a = a;
        
        for &breakpoint in breakpoints {
            if breakpoint > a && breakpoint < b {
                result += Self::numerical_integral(&f, current_a, breakpoint);
                current_a = breakpoint;
            }
        }
        
        result + Self::numerical_integral(&f, current_a, b)
    }
    
    /// 数值积分（梯形法则）
    pub fn numerical_integral<F>(f: &F, a: f64, b: f64) -> f64 
    where F: Fn(f64) -> f64 {
        let n = 1000;
        let h = (b - a) / n as f64;
        let mut sum = (f(a) + f(b)) / 2.0;
        
        for i in 1..n {
            let x = a + i as f64 * h;
            sum += f(x);
        }
        
        sum * h
    }
    
    /// 极限情况处理
    pub fn limit_case_integral<F>(f: F, a: f64, b: f64, tolerance: f64) -> Result<f64, String> 
    where F: Fn(f64) -> f64 {
        // 检查积分的收敛性
        let test_points = vec![a + tolerance, b - tolerance];
        let mut max_value = 0.0;
        
        for &x in &test_points {
            let value = f(x).abs();
            if value > max_value {
                max_value = value;
            }
        }
        
        if max_value.is_infinite() || max_value.is_nan() {
            Err("Integral diverges or contains NaN".to_string())
        } else {
            Ok(Self::numerical_integral(&f, a, b))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_high_power_sine_integral() {
        let result = SpecialTrigonometricSubstitution::high_power_sine_integral(3, 0.5);
        assert!(result.is_finite());
    }
    
    #[test]
    fn test_high_power_cosine_integral() {
        let result = SpecialTrigonometricSubstitution::high_power_cosine_integral(4, 0.5);
        assert!(result.is_finite());
    }
    
    #[test]
    fn test_mixed_power_integral() {
        let result = SpecialTrigonometricSubstitution::mixed_power_integral(2, 3, 0.5);
        assert!(result.is_finite());
    }
    
    #[test]
    fn test_parametric_quadratic_integral() {
        let result = SpecialTrigonometricSubstitution::parametric_quadratic_integral(1.0, 2.0, 1.0, 0.5);
        assert!(result.is_finite());
    }
    
    #[test]
    fn test_numerical_integral() {
        let f = |x: f64| x * x;
        let result = SpecialTrigonometricSubstitution::numerical_integral(&f, 0.0, 1.0);
        assert!((result - 1.0/3.0).abs() < 0.01);
    }
    
    #[test]
    fn test_limit_case_integral() {
        let f = |x: f64| 1.0 / x.sqrt();
        let result = SpecialTrigonometricSubstitution::limit_case_integral(f, 0.0, 1.0, 1e-6);
        assert!(result.is_ok());
    }
}
```

### Haskell实现

```haskell
module SpecialTrigonometricSubstitution where

import Data.Complex

-- 特殊三角替换积分计算器
data SpecialTrigonometricSubstitution = SpecialTrigonometricSubstitution

-- 高次正弦幂积分
highPowerSineIntegral :: Integer -> Double -> Double
highPowerSineIntegral n theta
  | n == 0 = theta
  | n == 1 = -cos theta
  | otherwise = 
      let power = fromIntegral n
      in -sin theta ** (power - 1) * cos theta / power + 
         (power - 1) / power * highPowerSineIntegral (n - 2) theta

-- 高次余弦幂积分
highPowerCosineIntegral :: Integer -> Double -> Double
highPowerCosineIntegral n theta
  | n == 0 = theta
  | n == 1 = sin theta
  | otherwise = 
      let power = fromIntegral n
      in cos theta ** (power - 1) * sin theta / power + 
         (power - 1) / power * highPowerCosineIntegral (n - 2) theta

-- 混合幂积分
mixedPowerIntegral :: Integer -> Integer -> Double -> Double
mixedPowerIntegral n m theta
  | m == 0 = highPowerSineIntegral n theta
  | n == 0 = highPowerCosineIntegral m theta
  | otherwise = 
      let nPower = fromIntegral n
          mPower = fromIntegral m
      in sin theta ** (nPower + 1) * cos theta ** (mPower - 1) / (nPower + mPower) +
         (mPower - 1) / (nPower + mPower) * mixedPowerIntegral n (m - 2) theta

-- 万能替换积分
universalSubstitutionIntegral :: (Double -> Double -> Double -> Double) -> Double -> Double
universalSubstitutionIntegral f theta = 
    let t = tan (theta / 2)
        sinTheta = 2 * t / (1 + t * t)
        cosTheta = (1 - t * t) / (1 + t * t)
        dthetaDt = 2 / (1 + t * t)
    in f sinTheta cosTheta t * dthetaDt

-- 参数化二次函数积分
parametricQuadraticIntegral :: Double -> Double -> Double -> Double -> Double
parametricQuadraticIntegral a b c x = 
    let discriminant = b * b - 4.0 * a * c
        h = -b / (2.0 * a)
        k = c - (b * b) / (4.0 * a)
        u = x - h
    in if k > 0.0
       then atan (u / sqrt k)  -- 使用正切替换
       else if k < 0.0
            then acos (u / sqrt (-k))  -- 使用正割替换
            else log (abs u)  -- 线性情况

-- 数值积分（梯形法则）
numericalIntegral :: (Double -> Double) -> Double -> Double -> Double
numericalIntegral f a b = 
    let n = 1000
        h = (b - a) / fromIntegral n
        sum = (f a + f b) / 2.0 + sum [f (a + fromIntegral i * h) | i <- [1..n-1]]
    in sum * h

-- 分段函数积分
piecewiseIntegral :: (Double -> Double) -> Double -> Double -> [Double] -> Double
piecewiseIntegral f a b breakpoints = 
    let sortedBreakpoints = filter (\x -> x > a && x < b) breakpoints
        intervals = zip (a : sortedBreakpoints) (sortedBreakpoints ++ [b])
    in sum [numericalIntegral f start end | (start, end) <- intervals]

-- 极限情况处理
limitCaseIntegral :: (Double -> Double) -> Double -> Double -> Double -> Either String Double
limitCaseIntegral f a b tolerance = 
    let testPoints = [a + tolerance, b - tolerance]
        maxValue = maximum [abs (f x) | x <- testPoints]
    in if isInfinite maxValue || isNaN maxValue
       then Left "Integral diverges or contains NaN"
       else Right (numericalIntegral f a b)

-- 辅助函数
sqrt :: Double -> Double
sqrt = Prelude.sqrt

log :: Double -> Double
log = Prelude.log

sin, cos, tan, asin, acos, atan :: Double -> Double
sin = Prelude.sin
cos = Prelude.cos
tan = Prelude.tan
asin = Prelude.asin
acos = Prelude.acos
atan = Prelude.atan

abs :: Double -> Double
abs = Prelude.abs

isInfinite :: Double -> Bool
isInfinite = Prelude.isInfinite

isNaN :: Double -> Bool
isNaN = Prelude.isNaN

-- 测试函数
testHighPowerSineIntegral :: Bool
testHighPowerSineIntegral = isFinite (highPowerSineIntegral 3 0.5)

testHighPowerCosineIntegral :: Bool
testHighPowerCosineIntegral = isFinite (highPowerCosineIntegral 4 0.5)

testMixedPowerIntegral :: Bool
testMixedPowerIntegral = isFinite (mixedPowerIntegral 2 3 0.5)

testParametricQuadraticIntegral :: Bool
testParametricQuadraticIntegral = isFinite (parametricQuadraticIntegral 1.0 2.0 1.0 0.5)

testNumericalIntegral :: Bool
testNumericalIntegral = 
    let f x = x * x
        result = numericalIntegral f 0.0 1.0
    in abs (result - 1.0/3.0) < 0.01

testLimitCaseIntegral :: Bool
testLimitCaseIntegral = 
    let f x = 1.0 / sqrt x
        result = limitCaseIntegral f 0.0 1.0 1e-6
    in case result of
         Right _ -> True
         Left _ -> False

-- 辅助函数
isFinite :: Double -> Bool
isFinite x = not (isNaN x || isInfinite x)

-- 运行所有测试
runTests :: Bool
runTests = testHighPowerSineIntegral && testHighPowerCosineIntegral && 
           testMixedPowerIntegral && testParametricQuadraticIntegral && 
           testNumericalIntegral && testLimitCaseIntegral
```

## 相关文件

- [00-三角替换总览](00-三角替换总览.md)
- [01-基本三角替换](01-基本三角替换.md)
- [02-复合三角替换](02-复合三角替换.md)
- [04-双曲函数替换](04-双曲函数替换.md)
- [05-欧拉替换](05-欧拉替换.md)
- [06-万能替换](06-万能替换.md)
- [07-应用实例](07-应用实例.md)
- [00-积分技巧总览](../00-积分技巧总览.md)
- [01-换元积分法](../01-换元积分法/00-换元积分法总览.md)
- [02-分部积分法](../02-分部积分法/00-分部积分法总览.md)
- [04-部分分式分解](../04-部分分式分解/00-部分分式分解总览.md)
- [05-有理函数积分](../05-有理函数积分/00-有理函数积分总览.md) 