# 04-经济学中的积分应用

## 目录

- [1. 消费与投资模型](#1-消费与投资模型)
- [2. 利息与现值计算](#2-利息与现值计算)
- [3. 收入分布与洛伦兹曲线](#3-收入分布与洛伦兹曲线)
- [4. 生产函数与最优分配](#4-生产函数与最优分配)
- [5. 风险与保险](#5-风险与保险)
- [6. 代码实现](#6-代码实现)
- [7. 相关链接](#7-相关链接)

## 1. 消费与投资模型

### 1.1 持续消费模型

$$C = \int_0^T c(t) dt$$

### 1.2 投资回报

$$R = \int_0^T r(t) dt$$

## 2. 利息与现值计算

### 2.1 连续复利现值

$$PV = \int_0^T CF(t) e^{-rt} dt$$

### 2.2 贴现因子

$$DF = \int_0^T e^{-rt} dt = \frac{1-e^{-rT}}{r}$$

## 3. 收入分布与洛伦兹曲线

### 3.1 洛伦兹曲线

$$L(p) = \frac{\int_0^p f(x) dx}{\int_0^1 f(x) dx}$$

### 3.2 基尼系数

$$G = 1 - 2 \int_0^1 L(p) dp$$

## 4. 生产函数与最优分配

### 4.1 柯布-道格拉斯生产函数

$$Q = \int_0^T A K(t)^{\alpha} L(t)^{1-\alpha} dt$$

### 4.2 最优资源分配

$$U = \int_0^T u(c(t)) dt$$

## 5. 风险与保险

### 5.1 期望损失

$$E[L] = \int_0^{\infty} l f(l) dl$$

### 5.2 保费定价

$$P = (1+\theta) E[L]$$

## 6. 代码实现

### 6.1 Rust实现

```rust
// 连续复利现值
fn present_value(cf: impl Fn(f64) -> f64, r: f64, t0: f64, t1: f64, n: usize) -> f64 {
    let h = (t1 - t0) / n as f64;
    let mut sum = 0.0;
    for i in 0..=n {
        let t = t0 + i as f64 * h;
        let v = cf(t) * (-r * t).exp();
        sum += if i == 0 || i == n { v } else if i % 2 == 0 { 2.0 * v } else { 4.0 * v };
    }
    sum * h / 3.0
}
```

### 6.2 Haskell实现

```haskell
presentValue :: (Double -> Double) -> Double -> Double -> Double -> Int -> Double
presentValue cf r t0 t1 n = sum [w i * cf t * exp (-r * t) | i <- [0..n], let t = t0 + fromIntegral i * h] * h / 3
  where
    h = (t1 - t0) / fromIntegral n
    w i | i == 0 || i == n = 1
        | even i = 2
        | otherwise = 4
```

## 7. 相关链接

- [积分学总览](../00-积分学总览.md)
- [积分技巧](../03-积分技巧/00-积分技巧总览.md)
- [反常积分](../04-反常积分/00-反常积分总览.md) 