# 05-级数理论

## 目录

1. [级数理论概述](#1-级数理论概述)
2. [数项级数](#2-数项级数)
3. [函数项级数](#3-函数项级数)
4. [幂级数](#4-幂级数)
5. [傅里叶级数](#5-傅里叶级数)
6. [级数的应用](#6-级数的应用)
7. [形式化实现](#7-形式化实现)
8. [习题与练习](#8-习题与练习)
9. [参考文献](#9-参考文献)

## 1. 级数理论概述

### 1.1 级数的历史发展

级数理论的发展经历了几个重要阶段：

**古典时期**：
- 古希腊的无穷级数思想
- 芝诺悖论与无穷概念
- 阿基米德的几何级数

**微积分创立时期**：
- 牛顿的幂级数展开
- 莱布尼茨的交替级数
- 泰勒和麦克劳林级数

**严格化时期**：
- 柯西的收敛性理论
- 魏尔斯特拉斯的函数项级数
- 傅里叶的三角级数

### 1.2 级数的基本概念

**定义 1.2.1**（级数）
给定数列 $\{a_n\}_{n=1}^{\infty}$，形式表达式：

$$\sum_{n=1}^{\infty} a_n = a_1 + a_2 + a_3 + \cdots$$

称为无穷级数，简称级数。

**定义 1.2.2**（部分和）
级数 $\sum_{n=1}^{\infty} a_n$ 的第 $n$ 个部分和定义为：

$$S_n = \sum_{k=1}^n a_k = a_1 + a_2 + \cdots + a_n$$

**定义 1.2.3**（级数收敛）
如果部分和序列 $\{S_n\}$ 收敛到有限极限 $S$，即：

$$\lim_{n \to \infty} S_n = S$$

则称级数 $\sum_{n=1}^{\infty} a_n$ 收敛，其和为 $S$，记作：

$$\sum_{n=1}^{\infty} a_n = S$$

如果 $\{S_n\}$ 发散，则称级数 $\sum_{n=1}^{\infty} a_n$ 发散。

### 1.3 级数的基本性质

**性质 1.3.1**（线性性）
设 $\sum_{n=1}^{\infty} a_n$ 和 $\sum_{n=1}^{\infty} b_n$ 收敛，$\alpha, \beta \in \mathbb{R}$，则：

$$\sum_{n=1}^{\infty} (\alpha a_n + \beta b_n) = \alpha \sum_{n=1}^{\infty} a_n + \beta \sum_{n=1}^{\infty} b_n$$

**性质 1.3.2**（收敛的必要条件）
如果级数 $\sum_{n=1}^{\infty} a_n$ 收敛，则：

$$\lim_{n \to \infty} a_n = 0$$

**性质 1.3.3**（柯西收敛准则）
级数 $\sum_{n=1}^{\infty} a_n$ 收敛的充分必要条件是：对于任意 $\epsilon > 0$，存在正整数 $N$，使得当 $m > n \geq N$ 时，有：

$$|a_{n+1} + a_{n+2} + \cdots + a_m| < \epsilon$$

## 2. 数项级数

### 2.1 正项级数

**定义 2.1.1**（正项级数）
如果级数 $\sum_{n=1}^{\infty} a_n$ 的所有项 $a_n \geq 0$，则称该级数为正项级数。

**定理 2.1.1**（正项级数收敛的充分必要条件）
正项级数 $\sum_{n=1}^{\infty} a_n$ 收敛的充分必要条件是：其部分和序列 $\{S_n\}$ 有上界。

**定理 2.1.2**（比较判别法）
设 $\sum_{n=1}^{\infty} a_n$ 和 $\sum_{n=1}^{\infty} b_n$ 是正项级数，且 $0 \leq a_n \leq b_n$ 对所有 $n$ 成立。

1. 如果 $\sum_{n=1}^{\infty} b_n$ 收敛，则 $\sum_{n=1}^{\infty} a_n$ 收敛
2. 如果 $\sum_{n=1}^{\infty} a_n$ 发散，则 $\sum_{n=1}^{\infty} b_n$ 发散

**定理 2.1.3**（比值判别法）
设 $\sum_{n=1}^{\infty} a_n$ 是正项级数，且 $a_n > 0$，如果极限：

$$\lim_{n \to \infty} \frac{a_{n+1}}{a_n} = L$$

存在，则：

1. 如果 $L < 1$，则级数收敛
2. 如果 $L > 1$，则级数发散
3. 如果 $L = 1$，则判别法失效

**定理 2.1.4**（根值判别法）
设 $\sum_{n=1}^{\infty} a_n$ 是正项级数，且 $a_n \geq 0$，如果极限：

$$\lim_{n \to \infty} \sqrt[n]{a_n} = L$$

存在，则：

1. 如果 $L < 1$，则级数收敛
2. 如果 $L > 1$，则级数发散
3. 如果 $L = 1$，则判别法失效

**定理 2.1.5**（积分判别法）
设 $f: [1,+\infty) \to \mathbb{R}$ 是连续、单调递减的正函数，且 $a_n = f(n)$，则级数 $\sum_{n=1}^{\infty} a_n$ 与反常积分 $\int_1^{\infty} f(x) dx$ 同时收敛或同时发散。

### 2.2 交错级数

**定义 2.2.1**（交错级数）
如果级数 $\sum_{n=1}^{\infty} a_n$ 的项交替为正负，即 $a_n a_{n+1} < 0$ 对所有 $n$ 成立，则称该级数为交错级数。

**定理 2.2.1**（莱布尼茨判别法）
设 $\sum_{n=1}^{\infty} (-1)^{n-1} a_n$ 是交错级数，其中 $a_n > 0$，如果：

1. $a_n \geq a_{n+1}$ 对所有 $n$ 成立（单调递减）
2. $\lim_{n \to \infty} a_n = 0$

则级数收敛。

**定理 2.2.2**（交错级数误差估计）
在莱布尼茨判别法的条件下，级数的余项 $R_n = \sum_{k=n+1}^{\infty} (-1)^{k-1} a_k$ 满足：

$$|R_n| \leq a_{n+1}$$

### 2.3 绝对收敛与条件收敛

**定义 2.3.1**（绝对收敛）
如果级数 $\sum_{n=1}^{\infty} |a_n|$ 收敛，则称级数 $\sum_{n=1}^{\infty} a_n$ 绝对收敛。

**定义 2.3.2**（条件收敛）
如果级数 $\sum_{n=1}^{\infty} a_n$ 收敛，但 $\sum_{n=1}^{\infty} |a_n|$ 发散，则称级数 $\sum_{n=1}^{\infty} a_n$ 条件收敛。

**定理 2.3.1**（绝对收敛的充分条件）
如果级数 $\sum_{n=1}^{\infty} a_n$ 绝对收敛，则它收敛。

**定理 2.3.2**（重排定理）
如果级数 $\sum_{n=1}^{\infty} a_n$ 绝对收敛，则其任意重排级数也收敛，且和相同。

**定理 2.3.3**（黎曼重排定理）
如果级数 $\sum_{n=1}^{\infty} a_n$ 条件收敛，则对于任意实数 $S$（包括 $\pm \infty$），都存在该级数的重排，使其收敛到 $S$。

### 2.4 常见级数

**几何级数**：
$$\sum_{n=0}^{\infty} r^n = \frac{1}{1-r}, \quad |r| < 1$$

**调和级数**：
$$\sum_{n=1}^{\infty} \frac{1}{n} = +\infty$$

**p-级数**：
$$\sum_{n=1}^{\infty} \frac{1}{n^p} \begin{cases}
\text{收敛}, & p > 1 \\
\text{发散}, & p \leq 1
\end{cases}$$

**指数级数**：
$$\sum_{n=0}^{\infty} \frac{x^n}{n!} = e^x$$

## 3. 函数项级数

### 3.1 函数项级数的基本概念

**定义 3.1.1**（函数项级数）
设 $\{f_n\}_{n=1}^{\infty}$ 是定义在集合 $D$ 上的函数序列，形式表达式：

$$\sum_{n=1}^{\infty} f_n(x) = f_1(x) + f_2(x) + f_3(x) + \cdots$$

称为函数项级数。

**定义 3.1.2**（点收敛）
如果对于每个 $x \in D$，数项级数 $\sum_{n=1}^{\infty} f_n(x)$ 收敛，则称函数项级数在 $D$ 上点收敛。

**定义 3.1.3**（一致收敛）
如果对于任意 $\epsilon > 0$，存在正整数 $N$，使得当 $n \geq N$ 时，对于所有 $x \in D$，有：

$$|f_{n+1}(x) + f_{n+2}(x) + \cdots + f_{n+m}(x)| < \epsilon$$

对所有正整数 $m$ 成立，则称函数项级数在 $D$ 上一致收敛。

### 3.2 一致收敛的判别法

**定理 3.2.1**（魏尔斯特拉斯判别法）
设 $\sum_{n=1}^{\infty} f_n(x)$ 是定义在 $D$ 上的函数项级数，如果存在正数列 $\{M_n\}$，使得：

1. $|f_n(x)| \leq M_n$ 对所有 $x \in D$ 和所有 $n$ 成立
2. 数项级数 $\sum_{n=1}^{\infty} M_n$ 收敛

则函数项级数在 $D$ 上一致收敛。

**定理 3.2.2**（柯西一致收敛准则）
函数项级数 $\sum_{n=1}^{\infty} f_n(x)$ 在 $D$ 上一致收敛的充分必要条件是：对于任意 $\epsilon > 0$，存在正整数 $N$，使得当 $m > n \geq N$ 时，对于所有 $x \in D$，有：

$$|f_{n+1}(x) + f_{n+2}(x) + \cdots + f_m(x)| < \epsilon$$

### 3.3 一致收敛的性质

**定理 3.3.1**（连续性）
如果函数项级数 $\sum_{n=1}^{\infty} f_n(x)$ 在 $D$ 上一致收敛，且每个 $f_n$ 在 $D$ 上连续，则其和函数 $S(x) = \sum_{n=1}^{\infty} f_n(x)$ 在 $D$ 上连续。

**定理 3.3.2**（逐项积分）
如果函数项级数 $\sum_{n=1}^{\infty} f_n(x)$ 在 $[a,b]$ 上一致收敛，且每个 $f_n$ 在 $[a,b]$ 上连续，则：

$$\int_a^b \sum_{n=1}^{\infty} f_n(x) dx = \sum_{n=1}^{\infty} \int_a^b f_n(x) dx$$

**定理 3.3.3**（逐项求导）
如果函数项级数 $\sum_{n=1}^{\infty} f_n(x)$ 在 $[a,b]$ 上收敛，且每个 $f_n$ 在 $[a,b]$ 上可导，且导函数级数 $\sum_{n=1}^{\infty} f_n'(x)$ 在 $[a,b]$ 上一致收敛，则：

$$\frac{d}{dx} \sum_{n=1}^{\infty} f_n(x) = \sum_{n=1}^{\infty} f_n'(x)$$

## 4. 幂级数

### 4.1 幂级数的基本概念

**定义 4.1.1**（幂级数）
形如：

$$\sum_{n=0}^{\infty} a_n (x - c)^n = a_0 + a_1(x-c) + a_2(x-c)^2 + \cdots$$

的级数称为幂级数，其中 $c$ 称为中心，$\{a_n\}$ 称为系数。

**定理 4.1.1**（阿贝尔定理）
如果幂级数 $\sum_{n=0}^{\infty} a_n x^n$ 在 $x = x_0 \neq 0$ 处收敛，则它在 $|x| < |x_0|$ 的每个点处绝对收敛。

**定理 4.1.2**（收敛半径）
对于幂级数 $\sum_{n=0}^{\infty} a_n x^n$，存在唯一的 $R \in [0,+\infty]$，称为收敛半径，使得：

1. 当 $|x| < R$ 时，级数绝对收敛
2. 当 $|x| > R$ 时，级数发散
3. 当 $|x| = R$ 时，级数可能收敛也可能发散

### 4.2 收敛半径的计算

**定理 4.2.1**（柯西-阿达马公式）
幂级数 $\sum_{n=0}^{\infty} a_n x^n$ 的收敛半径为：

$$R = \frac{1}{\limsup_{n \to \infty} \sqrt[n]{|a_n|}}$$

**定理 4.2.2**（比值判别法）
如果极限 $\lim_{n \to \infty} \left|\frac{a_{n+1}}{a_n}\right| = L$ 存在，则收敛半径为：

$$R = \frac{1}{L}$$

### 4.3 幂级数的性质

**定理 4.3.1**（幂级数的连续性）
幂级数在其收敛区间内连续。

**定理 4.3.2**（幂级数的逐项积分）
设幂级数 $\sum_{n=0}^{\infty} a_n x^n$ 的收敛半径为 $R$，则：

$$\int_0^x \sum_{n=0}^{\infty} a_n t^n dt = \sum_{n=0}^{\infty} \frac{a_n}{n+1} x^{n+1}$$

且积分后的级数收敛半径仍为 $R$。

**定理 4.3.3**（幂级数的逐项求导）
设幂级数 $\sum_{n=0}^{\infty} a_n x^n$ 的收敛半径为 $R$，则：

$$\frac{d}{dx} \sum_{n=0}^{\infty} a_n x^n = \sum_{n=1}^{\infty} n a_n x^{n-1}$$

且求导后的级数收敛半径仍为 $R$。

### 4.4 泰勒级数

**定理 4.4.1**（泰勒定理）
设函数 $f$ 在点 $a$ 的邻域内具有 $n+1$ 阶导数，则对于该邻域内的任意 $x$，有：

$$f(x) = \sum_{k=0}^n \frac{f^{(k)}(a)}{k!} (x-a)^k + R_n(x)$$

其中余项 $R_n(x)$ 为：

$$R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!} (x-a)^{n+1}$$

其中 $\xi$ 在 $a$ 与 $x$ 之间。

**定义 4.4.1**（泰勒级数）
如果函数 $f$ 在点 $a$ 的邻域内具有任意阶导数，则：

$$\sum_{n=0}^{\infty} \frac{f^{(n)}(a)}{n!} (x-a)^n$$

称为 $f$ 在点 $a$ 的泰勒级数。

**定理 4.4.2**（泰勒级数收敛的充分条件）
如果存在常数 $M > 0$，使得 $|f^{(n)}(x)| \leq M$ 对所有 $n$ 和 $x$ 在 $a$ 的邻域内成立，则泰勒级数收敛到 $f(x)$。

### 4.5 常见函数的泰勒级数

**指数函数**：
$$e^x = \sum_{n=0}^{\infty} \frac{x^n}{n!}, \quad x \in \mathbb{R}$$

**正弦函数**：
$$\sin x = \sum_{n=0}^{\infty} \frac{(-1)^n}{(2n+1)!} x^{2n+1}, \quad x \in \mathbb{R}$$

**余弦函数**：
$$\cos x = \sum_{n=0}^{\infty} \frac{(-1)^n}{(2n)!} x^{2n}, \quad x \in \mathbb{R}$$

**对数函数**：
$$\ln(1+x) = \sum_{n=1}^{\infty} \frac{(-1)^{n-1}}{n} x^n, \quad |x| < 1$$

**几何级数**：
$$\frac{1}{1-x} = \sum_{n=0}^{\infty} x^n, \quad |x| < 1$$

## 5. 傅里叶级数

### 5.1 三角级数

**定义 5.1.1**（三角级数）
形如：

$$\frac{a_0}{2} + \sum_{n=1}^{\infty} (a_n \cos nx + b_n \sin nx)$$

的级数称为三角级数。

**定义 5.1.2**（傅里叶系数）
设 $f$ 是 $[-\pi,\pi]$ 上的可积函数，其傅里叶系数定义为：

$$a_n = \frac{1}{\pi} \int_{-\pi}^{\pi} f(x) \cos nx dx, \quad n = 0,1,2,\ldots$$

$$b_n = \frac{1}{\pi} \int_{-\pi}^{\pi} f(x) \sin nx dx, \quad n = 1,2,3,\ldots$$

**定义 5.1.3**（傅里叶级数）
函数 $f$ 的傅里叶级数为：

$$S_f(x) = \frac{a_0}{2} + \sum_{n=1}^{\infty} (a_n \cos nx + b_n \sin nx)$$

### 5.2 傅里叶级数的收敛性

**定理 5.2.1**（狄利克雷收敛定理）
设 $f$ 是 $[-\pi,\pi]$ 上的分段连续函数，且在每个不连续点处存在左极限和右极限，则 $f$ 的傅里叶级数在 $f$ 的连续点处收敛到 $f(x)$，在不连续点处收敛到：

$$\frac{f(x^+) + f(x^-)}{2}$$

**定理 5.2.2**（帕塞瓦尔等式）
如果 $f$ 的傅里叶级数一致收敛到 $f$，则：

$$\frac{1}{\pi} \int_{-\pi}^{\pi} [f(x)]^2 dx = \frac{a_0^2}{2} + \sum_{n=1}^{\infty} (a_n^2 + b_n^2)$$

### 5.3 复数形式的傅里叶级数

**定义 5.3.1**（复数傅里叶系数）
设 $f$ 是 $[-\pi,\pi]$ 上的可积函数，其复数傅里叶系数为：

$$c_n = \frac{1}{2\pi} \int_{-\pi}^{\pi} f(x) e^{-inx} dx, \quad n \in \mathbb{Z}$$

**定理 5.3.1**（复数傅里叶级数）
函数 $f$ 的复数傅里叶级数为：

$$S_f(x) = \sum_{n=-\infty}^{\infty} c_n e^{inx}$$

其中 $c_n$ 与 $a_n, b_n$ 的关系为：

$$c_n = \frac{a_n - ib_n}{2}, \quad c_{-n} = \frac{a_n + ib_n}{2}, \quad n > 0$$

$$c_0 = \frac{a_0}{2}$$

## 6. 级数的应用

### 6.1 数值计算

**级数近似**：
- 使用泰勒级数近似计算函数值
- 使用傅里叶级数近似周期函数
- 使用幂级数求解微分方程

**数值积分**：
- 使用级数展开计算定积分
- 使用傅里叶变换进行数值分析

### 6.2 物理应用

**波动方程**：
- 使用傅里叶级数求解波动方程
- 分析声波、光波的传播

**热传导方程**：
- 使用傅里叶级数求解热传导方程
- 分析温度分布

**量子力学**：
- 使用幂级数求解薛定谔方程
- 分析能级和波函数

### 6.3 工程应用

**信号处理**：
- 使用傅里叶级数进行信号分析
- 滤波和调制

**控制系统**：
- 使用幂级数分析系统响应
- 稳定性分析

## 7. 形式化实现

### 7.1 Haskell实现

```haskell
-- 级数理论模块
module SeriesTheory where

import Data.List (scanl', zipWith)
import Data.Complex

-- 级数收敛性判断
type Series = [Double]

-- 部分和
partialSums :: Series -> [Double]
partialSums = scanl' (+) 0

-- 判断级数是否收敛（使用柯西准则）
isConvergent :: Series -> Double -> Bool
isConvergent series epsilon = 
    let sums = partialSums series
        checkCauchy n = all (\m -> abs (sums !! (n+m) - sums !! n) < epsilon) [1..10]
    in any checkCauchy [0..length series - 11]

-- 几何级数
geometricSeries :: Double -> Series
geometricSeries r = [r^n | n <- [0..]]

-- 调和级数
harmonicSeries :: Series
harmonicSeries = [1/n | n <- [1..]]

-- p-级数
pSeries :: Double -> Series
pSeries p = [1/n**p | n <- [1..]]

-- 交错调和级数
alternatingHarmonicSeries :: Series
alternatingHarmonicSeries = [(-1)^(n-1) / n | n <- [1..]]

-- 泰勒级数系数
taylorCoefficients :: (Double -> Double) -> Double -> Int -> [Double]
taylorCoefficients f a n = [f k a / fromIntegral (factorial k) | k <- [0..n]]
  where
    f 0 = f
    f k = derivative (f (k-1))
    derivative g x = (g (x + h) - g x) / h where h = 1e-6
    factorial n = product [1..n]

-- 泰勒级数
taylorSeries :: (Double -> Double) -> Double -> Double -> Int -> Double
taylorSeries f a x n = sum $ zipWith (*) (taylorCoefficients f a n) powers
  where powers = [(x-a)^k | k <- [0..n]]

-- 傅里叶系数
fourierCoefficients :: (Double -> Double) -> Int -> (Double, [Double], [Double])
fourierCoefficients f n = (a0, as, bs)
  where
    a0 = integrate (\x -> f x) (-pi) pi / pi
    as = [integrate (\x -> f x * cos (k*x)) (-pi) pi / pi | k <- [1..n]]
    bs = [integrate (\x -> f x * sin (k*x)) (-pi) pi / pi | k <- [1..n]]

-- 数值积分（梯形法）
integrate :: (Double -> Double) -> Double -> Double -> Double
integrate f a b = h * sum [f (a + i*h) | i <- [0..n]] / 2
  where
    n = 1000
    h = (b - a) / fromIntegral n

-- 傅里叶级数
fourierSeries :: (Double -> Double) -> Int -> Double -> Double
fourierSeries f n x = a0/2 + sum [ak * cos (k*x) + bk * sin (k*x) | k <- [1..n]]
  where
    (a0, as, bs) = fourierCoefficients f n
    ak = as !! (k-1)
    bk = bs !! (k-1)

-- 幂级数收敛半径
convergenceRadius :: [Double] -> Double
convergenceRadius coeffs = 1 / limsup
  where
    limsup = maximum [abs (coeffs !! n) ** (1/fromIntegral n) | n <- [1..min 100 (length coeffs - 1)]]

-- 测试函数
testSeries :: IO ()
testSeries = do
    putStrLn "级数收敛性测试："
    
    -- 几何级数测试
    let geo1 = take 100 $ geometricSeries 0.5
    let geo2 = take 100 $ geometricSeries 1.5
    putStrLn $ "几何级数 r=0.5 收敛: " ++ show (isConvergent geo1 1e-6)
    putStrLn $ "几何级数 r=1.5 收敛: " ++ show (isConvergent geo2 1e-6)
    
    -- 调和级数测试
    let harm = take 1000 harmonicSeries
    putStrLn $ "调和级数收敛: " ++ show (isConvergent harm 1e-6)
    
    -- 泰勒级数测试
    let expApprox = taylorSeries exp 0 1 10
    putStrLn $ "e^1 的泰勒近似: " ++ show expApprox
    putStrLn $ "e^1 的精确值: " ++ show (exp 1)
    
    -- 傅里叶级数测试
    let squareWave x = if x > 0 then 1 else -1
    let fourierApprox = fourierSeries squareWave 10 0.5
    putStrLn $ "方波的傅里叶近似: " ++ show fourierApprox
```

### 7.2 Rust实现

```rust
use std::f64::consts::PI;

// 级数类型
type Series = Vec<f64>;

// 级数分析结构
struct SeriesAnalyzer;

impl SeriesAnalyzer {
    // 部分和
    fn partial_sums(series: &Series) -> Vec<f64> {
        let mut sums = Vec::new();
        let mut sum = 0.0;
        for &term in series {
            sum += term;
            sums.push(sum);
        }
        sums
    }
    
    // 判断收敛性（柯西准则）
    fn is_convergent(series: &Series, epsilon: f64) -> bool {
        let sums = Self::partial_sums(series);
        let n = sums.len();
        
        for i in 0..n.saturating_sub(10) {
            let mut convergent = true;
            for m in 1..=10 {
                if i + m < n && (sums[i + m] - sums[i]).abs() >= epsilon {
                    convergent = false;
                    break;
                }
            }
            if convergent {
                return true;
            }
        }
        false
    }
    
    // 几何级数
    fn geometric_series(r: f64, n: usize) -> Series {
        (0..n).map(|i| r.powi(i as i32)).collect()
    }
    
    // 调和级数
    fn harmonic_series(n: usize) -> Series {
        (1..=n).map(|i| 1.0 / i as f64).collect()
    }
    
    // p-级数
    fn p_series(p: f64, n: usize) -> Series {
        (1..=n).map(|i| 1.0 / (i as f64).powf(p)).collect()
    }
    
    // 交错调和级数
    fn alternating_harmonic_series(n: usize) -> Series {
        (1..=n).map(|i| if i % 2 == 1 { 1.0 } else { -1.0 } / i as f64).collect()
    }
}

// 泰勒级数结构
struct TaylorSeries;

impl TaylorSeries {
    // 数值导数
    fn derivative<F>(f: F, x: f64) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let h = 1e-6;
        (f(x + h) - f(x)) / h
    }
    
    // 高阶导数
    fn nth_derivative<F>(f: F, x: f64, n: usize) -> f64
    where
        F: Fn(f64) -> f64 + Copy,
    {
        if n == 0 {
            f(x)
        } else {
            Self::derivative(|t| Self::nth_derivative(f, t, n - 1), x)
        }
    }
    
    // 泰勒系数
    fn coefficients<F>(f: F, a: f64, n: usize) -> Vec<f64>
    where
        F: Fn(f64) -> f64 + Copy,
    {
        (0..=n)
            .map(|k| {
                let factorial = (1..=k).product::<usize>() as f64;
                Self::nth_derivative(f, a, k) / factorial
            })
            .collect()
    }
    
    // 泰勒级数
    fn evaluate<F>(f: F, a: f64, x: f64, n: usize) -> f64
    where
        F: Fn(f64) -> f64 + Copy,
    {
        let coeffs = Self::coefficients(f, a, n);
        coeffs
            .iter()
            .enumerate()
            .map(|(k, &c)| c * (x - a).powi(k as i32))
            .sum()
    }
}

// 傅里叶级数结构
struct FourierSeries;

impl FourierSeries {
    // 数值积分（梯形法）
    fn integrate<F>(f: F, a: f64, b: f64) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let n = 1000;
        let h = (b - a) / n as f64;
        let mut sum = (f(a) + f(b)) / 2.0;
        
        for i in 1..n {
            sum += f(a + i as f64 * h);
        }
        
        h * sum
    }
    
    // 傅里叶系数
    fn coefficients<F>(f: F, n: usize) -> (f64, Vec<f64>, Vec<f64>)
    where
        F: Fn(f64) -> f64 + Copy,
    {
        let a0 = Self::integrate(f, -PI, PI) / PI;
        
        let as_coeffs: Vec<f64> = (1..=n)
            .map(|k| Self::integrate(|x| f(x) * (k as f64 * x).cos(), -PI, PI) / PI)
            .collect();
            
        let bs_coeffs: Vec<f64> = (1..=n)
            .map(|k| Self::integrate(|x| f(x) * (k as f64 * x).sin(), -PI, PI) / PI)
            .collect();
            
        (a0, as_coeffs, bs_coeffs)
    }
    
    // 傅里叶级数
    fn evaluate<F>(f: F, n: usize, x: f64) -> f64
    where
        F: Fn(f64) -> f64 + Copy,
    {
        let (a0, as_coeffs, bs_coeffs) = Self::coefficients(f, n);
        
        let cosine_terms: f64 = as_coeffs
            .iter()
            .enumerate()
            .map(|(k, &ak)| ak * ((k + 1) as f64 * x).cos())
            .sum();
            
        let sine_terms: f64 = bs_coeffs
            .iter()
            .enumerate()
            .map(|(k, &bk)| bk * ((k + 1) as f64 * x).sin())
            .sum();
            
        a0 / 2.0 + cosine_terms + sine_terms
    }
}

// 幂级数结构
struct PowerSeries;

impl PowerSeries {
    // 收敛半径
    fn convergence_radius(coeffs: &[f64]) -> f64 {
        let n = coeffs.len().min(100);
        let mut max_root = 0.0;
        
        for i in 1..n {
            let root = coeffs[i].abs().powf(1.0 / i as f64);
            max_root = max_root.max(root);
        }
        
        if max_root > 0.0 {
            1.0 / max_root
        } else {
            f64::INFINITY
        }
    }
    
    // 幂级数求值
    fn evaluate(coeffs: &[f64], x: f64) -> f64 {
        coeffs
            .iter()
            .enumerate()
            .map(|(n, &c)| c * x.powi(n as i32))
            .sum()
    }
}

// 测试函数
fn test_series() {
    println!("级数理论测试：");
    
    // 几何级数测试
    let geo1 = SeriesAnalyzer::geometric_series(0.5, 100);
    let geo2 = SeriesAnalyzer::geometric_series(1.5, 100);
    println!("几何级数 r=0.5 收敛: {}", SeriesAnalyzer::is_convergent(&geo1, 1e-6));
    println!("几何级数 r=1.5 收敛: {}", SeriesAnalyzer::is_convergent(&geo2, 1e-6));
    
    // 调和级数测试
    let harm = SeriesAnalyzer::harmonic_series(1000);
    println!("调和级数收敛: {}", SeriesAnalyzer::is_convergent(&harm, 1e-6));
    
    // 泰勒级数测试
    let exp_approx = TaylorSeries::evaluate(|x| x.exp(), 0.0, 1.0, 10);
    println!("e^1 的泰勒近似: {:.6}", exp_approx);
    println!("e^1 的精确值: {:.6}", 1.0_f64.exp());
    
    // 傅里叶级数测试
    let square_wave = |x: f64| if x > 0.0 { 1.0 } else { -1.0 };
    let fourier_approx = FourierSeries::evaluate(square_wave, 10, 0.5);
    println!("方波的傅里叶近似: {:.6}", fourier_approx);
    
    // 幂级数测试
    let exp_coeffs = vec![1.0, 1.0, 0.5, 1.0/6.0, 1.0/24.0];
    let radius = PowerSeries::convergence_radius(&exp_coeffs);
    println!("指数函数幂级数的收敛半径: {:.6}", radius);
}

fn main() {
    test_series();
}
```

## 8. 习题与练习

### 8.1 基础练习

**练习 8.1.1**
判断以下级数的收敛性：
1. $\sum_{n=1}^{\infty} \frac{1}{n^2}$
2. $\sum_{n=1}^{\infty} \frac{1}{n}$
3. $\sum_{n=1}^{\infty} \frac{1}{2^n}$

**练习 8.1.2**
计算以下级数的和：
1. $\sum_{n=0}^{\infty} \frac{1}{3^n}$
2. $\sum_{n=1}^{\infty} \frac{1}{n(n+1)}$

**练习 8.1.3**
使用比较判别法判断级数收敛性：
1. $\sum_{n=1}^{\infty} \frac{1}{n^2+1}$
2. $\sum_{n=1}^{\infty} \frac{1}{\sqrt{n}}$

### 8.2 中级练习

**练习 8.2.1**
使用比值判别法判断级数收敛性：
1. $\sum_{n=1}^{\infty} \frac{n!}{n^n}$
2. $\sum_{n=1}^{\infty} \frac{n^2}{2^n}$

**练习 8.2.2**
使用根值判别法判断级数收敛性：
1. $\sum_{n=1}^{\infty} \left(\frac{n}{n+1}\right)^n$
2. $\sum_{n=1}^{\infty} \frac{1}{n^n}$

**练习 8.2.3**
判断交错级数的收敛性：
1. $\sum_{n=1}^{\infty} \frac{(-1)^n}{n}$
2. $\sum_{n=1}^{\infty} \frac{(-1)^n}{n^2}$

### 8.3 高级练习

**练习 8.3.1**
求幂级数的收敛半径：
1. $\sum_{n=0}^{\infty} n! x^n$
2. $\sum_{n=0}^{\infty} \frac{x^n}{n!}$

**练习 8.3.2**
计算泰勒级数：
1. 求 $f(x) = \sin x$ 在 $x = 0$ 的泰勒级数
2. 求 $f(x) = \ln(1+x)$ 在 $x = 0$ 的泰勒级数

**练习 8.3.3**
傅里叶级数计算：
1. 求函数 $f(x) = x$ 在 $[-\pi,\pi]$ 上的傅里叶级数
2. 求函数 $f(x) = |x|$ 在 $[-\pi,\pi]$ 上的傅里叶级数

## 9. 参考文献

1. **Apostol, T. M.** (1974). *Mathematical Analysis*. Addison-Wesley.

2. **Rudin, W.** (1976). *Principles of Mathematical Analysis*. McGraw-Hill.

3. **Stewart, J.** (2015). *Calculus: Early Transcendentals*. Cengage Learning.

4. **Kreyszig, E.** (2011). *Advanced Engineering Mathematics*. Wiley.

5. **Churchill, R. V., & Brown, J. W.** (2014). *Fourier Series and Boundary Value Problems*. McGraw-Hill.

6. **Zygmund, A.** (2002). *Trigonometric Series*. Cambridge University Press.

7. **Titchmarsh, E. C.** (1939). *The Theory of Functions*. Oxford University Press.

8. **Hardy, G. H.** (1949). *Divergent Series*. Oxford University Press.

---

> **文档信息**
> - **创建时间**：2024年12月19日
> - **最后更新**：2024年12月19日
> - **版本**：1.0
> - **状态**：已完成
> - **下一步**：创建 06-多元微积分.md 