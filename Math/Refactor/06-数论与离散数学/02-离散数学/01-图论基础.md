# 图论基础

## 1. 图论导论

### 1.1 图论的历史与发展

图论作为离散数学的重要分支，其起源可以追溯到18世纪。

**柯尼斯堡七桥问题与欧拉**:

1736年，瑞士数学家莱昂哈德·欧拉（Leonhard Euler, 1707-1783）解决了著名的"柯尼斯堡七桥问题"，这被广泛认为是图论的起点。当时的柯尼斯堡（今俄罗斯加里宁格勒）城内有两个岛屿，与河岸通过七座桥连接。问题是：能否不重复地走过所有七座桥，最后回到起点？

欧拉通过抽象化处理，将陆地表示为点（顶点），桥梁表示为线（边），从而将这个实际问题转化为数学问题：是否存在一条路径，恰好通过每条边一次？欧拉证明了这样的路径不存在，并给出了一般性的判断条件：当且仅当图中所有顶点的度数都是偶数时，才存在这样的回路（后来被称为"欧拉回路"）。

**图论的诞生与发展历程**:

- **19世纪**：图论的基础概念逐渐形成
  - 1847年，基尔霍夫（Gustav Kirchhoff）应用图论研究电路问题
  - 1852年，弗朗西斯·格思里（Francis Guthrie）提出四色问题
  - 1857年，凯莱（Arthur Cayley）开始研究树的性质

- **20世纪前半叶**：图论理论体系初步建立
  - 1930年，库拉托夫斯基（Kazimierz Kuratowski）给出平面图的特征
  - 1936年，柯尼格（Dénes Kőnig）出版第一本图论专著
  - 1941年，拉姆齐（Frank P. Ramsey）的工作引发组合图论发展

- **20世纪后半叶**：图论的快速发展与应用拓展
  - 1959年，厄德什（Paul Erdős）和雷尼（Alfréd Rényi）开创随机图理论
  - 1976年，阿佩尔（Kenneth Appel）和哈肯（Wolfgang Haken）证明四色定理
  - 1980年代起，图论在计算机科学中的应用日益广泛

**当代图论研究方向**:

现代图论研究呈现多元化趋势，主要包括：

1. **结构图论**：研究图的结构特性，如平面图、完美图、区间图等特殊图类
2. **极值图论**：研究满足特定条件的图的极端情况
3. **代数图论**：利用代数方法研究图的性质，特别是谱图理论
4. **随机图论**：研究随机过程生成的图及其性质
5. **计算图论**：研究图算法的设计与复杂性分析
6. **应用图论**：将图论应用于网络科学、生物信息学、社会网络分析等领域

图论的发展历程展示了数学如何从具体问题抽象出普遍原理，并反过来指导实践应用的典范。

### 1.2 基本术语与概念

**图的定义**:

一个**图** $G$ 是一个有序对 $G = (V, E)$，其中：

- $V$ 是非空的**顶点集**（或称**节点集**）
- $E$ 是**边集**，边是顶点对，可表示为 $e = \{u, v\}$ 或 $e = (u, v)$，其中 $u, v \in V$

从数学上讲，边集 $E$ 是顶点集 $V$ 中元素的二元关系。

**顶点与边**:

- **顶点**（Vertex，复数形式Vertices）：图中的基本元素，也称为节点（Node）
  - 顶点通常用字母、数字或符号表示
  - 顶点的**度**（Degree）：与该顶点相连的边的数量，记为 $\deg(v)$
  - **孤立点**：度为0的顶点
  - **悬挂点**（或称叶子）：度为1的顶点

- **边**（Edge）：连接两个顶点的线段或弧
  - 如果边连接顶点 $u$ 和 $v$，则称 $u$ 和 $v$ 是**相邻的**（Adjacent）
  - 边 $e = \{u, v\}$ 被称为**关联于**（Incident to）顶点 $u$ 和 $v$
  - 两条不同的边如果关联同一个顶点，则称它们是**相邻的**

**图的基本定理**：在任何图中，所有顶点的度数之和等于边数的两倍：$\sum_{v \in V} \deg(v) = 2|E|$

**有向图与无向图**:

- **无向图**（Undirected Graph）：边没有方向，表示为无序对 $\{u, v\}$
  - 在无向图中，如果 $\{u, v\}$ 是一条边，则顶点 $u$ 和 $v$ 之间存在双向连接

- **有向图**（Directed Graph 或 Digraph）：边有方向，表示为有序对 $(u, v)$
  - 在有向图中，边 $(u, v)$ 表示从顶点 $u$ 指向顶点 $v$ 的有向边
  - $u$ 称为该边的**起点**（Tail），$v$ 称为**终点**（Head）
  - 在有向图中，顶点的度分为**入度**（In-degree）和**出度**（Out-degree）
    - 入度：指向该顶点的边的数量，记为 $\deg^-(v)$
    - 出度：从该顶点出发的边的数量，记为 $\deg^+(v)$
    - 总度：$\deg(v) = \deg^-(v) + \deg^+(v)$

**有向图的基本定理**：在任何有向图中，所有顶点的入度之和等于所有顶点的出度之和，也等于边的总数：$\sum_{v \in V} \deg^-(v) = \sum_{v \in V} \deg^+(v) = |E|$

**简单图、多重图与伪图**:

- **简单图**（Simple Graph）：
  - 没有自环（即没有连接顶点到自身的边）
  - 没有多重边（即任意两个顶点之间最多有一条边）
  - $n$ 个顶点的简单图最多有 $\binom{n}{2} = \frac{n(n-1)}{2}$ 条边

- **多重图**（Multigraph）：
  - 允许两个顶点之间有多条边（称为多重边或平行边）
  - 不允许自环

- **伪图**（Pseudograph）：
  - 允许多重边
  - 也允许自环

- **完全图**（Complete Graph）：
  - 每对不同顶点之间都有一条边相连的简单图
  - $n$ 个顶点的完全图记为 $K_n$，有 $\frac{n(n-1)}{2}$ 条边

- **二分图**（Bipartite Graph）：
  - 顶点集可以分割为两个不相交的子集，使得每条边连接的两个顶点分别来自这两个子集
  - 完全二分图记为 $K_{m,n}$，其中 $m$ 和 $n$ 分别是两个顶点子集的大小

### 1.3 图的表示方法

在计算机科学和应用数学中，图可以通过多种方式表示，每种表示方法都有其优缺点。选择合适的表示方法对于设计高效的图算法至关重要。

**邻接矩阵**:

邻接矩阵是一个 $n \times n$ 的矩阵 $A$（其中 $n$ 是图中顶点的数量），定义如下：

- 对于无向图：
  $$A_{ij} = \begin{cases}
  1 & \text{如果顶点 } i \text{ 和顶点 } j \text{ 之间有边} \\
  0 & \text{否则}
  \end{cases}$$

- 对于有向图：
  $$A_{ij} = \begin{cases}
  1 & \text{如果从顶点 } i \text{ 到顶点 } j \text{ 有有向边} \\
  0 & \text{否则}
  \end{cases}$$

- 对于带权图：$A_{ij}$ 表示从顶点 $i$ 到顶点 $j$ 的边的权重，如果不存在这样的边，通常用特殊值（如 $\infty$ 或 0）表示

**特点**：

- 无向图的邻接矩阵是对称的：$A_{ij} = A_{ji}$
- 顶点 $i$ 的度可以通过计算矩阵第 $i$ 行（或列）的和获得
- 空间复杂度：$O(n^2)$，与边数无关
- 检查两个顶点之间是否有边的时间复杂度：$O(1)$
- 找出与特定顶点相邻的所有顶点的时间复杂度：$O(n)$

**邻接表**:

邻接表由 $n$ 个链表组成，每个链表对应图中的一个顶点，链表中存储与该顶点相邻的所有顶点。

- 对于无向图：顶点 $v$ 的邻接表包含所有与 $v$ 相邻的顶点
- 对于有向图：顶点 $v$ 的邻接表包含所有从 $v$ 出发可到达的顶点
- 对于带权图：链表中的每个节点还需存储对应边的权重

**特点**：

- 空间复杂度：$O(n + m)$，其中 $n$ 是顶点数，$m$ 是边数
- 特别适合稀疏图（边数远小于 $n^2$ 的图）
- 找出与特定顶点相邻的所有顶点的时间复杂度：$O(\deg(v))$
- 检查两个顶点之间是否有边的时间复杂度：$O(\deg(v))$，最坏情况下为 $O(n)$

**关联矩阵**:

关联矩阵是一个 $n \times m$ 的矩阵 $B$（其中 $n$ 是顶点数，$m$ 是边数），定义如下：

- 对于无向图：
  $$B_{ij} = \begin{cases}
  1 & \text{如果顶点 } i \text{ 关联于边 } j \\
  0 & \text{否则}
  \end{cases}$$

- 对于有向图：
  $$B_{ij} = \begin{cases}
  1 & \text{如果顶点 } i \text{ 是边 } j \text{ 的终点} \\
  -1 & \text{如果顶点 } i \text{ 是边 } j \text{ 的起点} \\
  0 & \text{如果顶点 } i \text{ 不关联于边 } j
  \end{cases}$$

**特点**：

- 每列恰好有两个非零元素（无向图）或者一个1和一个-1（有向图）
- 空间复杂度：$O(nm)$
- 不常用于一般图算法，但在某些理论分析和特定应用中很有用

**各表示方法的优缺点比较**:

| 表示方法 | 优点 | 缺点 | 适用场景 |
|---------|------|------|---------|
| 邻接矩阵 | 1. 实现简单\2. 查询边的存在性快速\3. 适合稠密图 | 1. 空间消耗大\2. 对稀疏图浪费空间 | 1. 稠密图\2. 需要频繁查询边的存在性\3. 图规模较小 |
| 邻接表 | 1. 节省空间\2. 快速枚举顶点的邻居\3. 适合稀疏图 | 1. 查询边的存在性较慢\2. 实现略复杂 | 1. 稀疏图\2. 需要频繁遍历顶点的邻居\3. 图规模较大 |
| 关联矩阵 | 1. 直观表示顶点与边的关系\2. 便于分析图的某些理论性质 | 1. 空间消耗大\2. 不便于常见图算法操作 | 1. 理论分析\2. 特定应用（如电路分析） |

在实际应用中，邻接矩阵和邻接表是最常用的两种表示方法，选择哪种方法主要取决于图的密度和需要执行的操作类型。

## 2. 图的连通性

### 2.1 路径与回路

**路径的定义**:

在图 $G = (V, E)$ 中，从顶点 $u$ 到顶点 $v$ 的**路径**（Path）是一个顶点序列 $P = (v_0, v_1, v_2, ..., v_k)$，满足：

- $v_0 = u$（起点）
- $v_k = v$（终点）
- 对于每个 $i \in \{0, 1, ..., k-1\}$，$(v_i, v_{i+1})$ 或 $\{v_i, v_{i+1}\}$ 是图 $G$ 中的一条边

路径的**长度**定义为路径中边的数量，即 $k$。

**简单路径与简单回路**:

- **简单路径**（Simple Path）：路径中所有顶点都不重复（除了可能的起点和终点）
  - 形式化定义：对于所有 $0 \leq i < j \leq k$，如果 $i \neq 0$ 或 $j \neq k$，则 $v_i \neq v_j$
  - 简单路径的长度最多为 $|V| - 1$

- **回路**（Circuit 或 Cycle）：起点和终点相同的路径，即 $v_0 = v_k$
  - 回路的长度至少为 1（如果允许自环）或 3（如果是简单图）

- **简单回路**（Simple Circuit 或 Simple Cycle）：除了起点和终点相同外，路径中不重复经过任何顶点
  - 形式化定义：$v_0 = v_k$，且对于所有 $1 \leq i < j \leq k-1$，$v_i \neq v_j$
  - 简单回路的长度最多为 $|V|$

**欧拉路径与欧拉回路**:

- **欧拉路径**（Eulerian Path）：经过图中每条边恰好一次的路径
  - 不一定经过所有顶点
  - 起点和终点可以不同

- **欧拉回路**（Eulerian Circuit）：经过图中每条边恰好一次，且起点和终点相同的回路

**欧拉图的判定定理**：

1. 连通无向图 $G$ 存在欧拉回路当且仅当 $G$ 中所有顶点的度数都是偶数
2. 连通无向图 $G$ 存在欧拉路径但不存在欧拉回路当且仅当 $G$ 中恰好有两个顶点的度数为奇数
3. 连通有向图 $G$ 存在欧拉回路当且仅当 $G$ 中所有顶点的入度等于出度
4. 连通有向图 $G$ 存在欧拉路径但不存在欧拉回路当且仅当：
   - 恰好有一个顶点的出度比入度大1（起点）
   - 恰好有一个顶点的入度比出度大1（终点）
   - 其余所有顶点的入度等于出度

**哈密顿路径与哈密顿回路**:

- **哈密顿路径**（Hamiltonian Path）：经过图中每个顶点恰好一次的路径
  - 不一定经过所有边
  - 起点和终点可以不同

- **哈密顿回路**（Hamiltonian Circuit）：经过图中每个顶点恰好一次，且起点和终点相同的回路

与欧拉问题不同，判断一个图是否存在哈密顿路径或回路是NP完全问题，没有已知的高效算法。但有一些充分条件可以帮助判断：

**狄拉克定理**（Dirac's Theorem）：如果 $G$ 是具有 $n \geq 3$ 个顶点的简单图，且每个顶点的度数至少为 $\frac{n}{2}$，则 $G$ 包含哈密顿回路。

**欧拉与哈密顿的比较**：

- 欧拉问题关注**边**的遍历，哈密顿问题关注**顶点**的遍历
- 欧拉问题有高效的判定算法，哈密顿问题是NP完全的
- 欧拉问题在网络设计和路径规划中有广泛应用，哈密顿问题在旅行商问题等优化领域有重要应用

### 2.2 连通性概念

**连通分量**:

在无向图 $G = (V, E)$ 中：

- 如果从顶点 $u$ 到顶点 $v$ 存在路径，则称 $u$ 和 $v$ 是**连通的**（Connected）
- **连通图**：任意两个顶点之间都是连通的图
- **连通分量**（Connected Component）：图 $G$ 的一个最大连通子图
  - "最大"意味着不能通过添加任何其他顶点或边使其保持连通
  - 每个顶点恰好属于一个连通分量
  - 孤立点自成一个连通分量

**连通性的数学表示**：

- 连通性定义了顶点集上的等价关系
- 连通分量对应于这个等价关系下的等价类
- 图 $G$ 的连通分量数记为 $c(G)$
- $G$ 是连通图当且仅当 $c(G) = 1$

**强连通分量**:

在有向图 $G = (V, E)$ 中：

- 如果从顶点 $u$ 到顶点 $v$ 存在有向路径，且从 $v$ 到 $u$ 也存在有向路径，则称 $u$ 和 $v$ 是**强连通的**（Strongly Connected）
- **强连通图**：任意两个顶点之间都是强连通的有向图
- **强连通分量**（Strongly Connected Component, SCC）：有向图 $G$ 的一个最大强连通子图
  - 每个顶点恰好属于一个强连通分量
  - 强连通分量之间形成有向无环图（DAG）

**Kosaraju算法**可以在 $O(|V| + |E|)$ 时间内找出有向图的所有强连通分量。

**割点与桥**:

- **割点**（Cut Vertex 或 Articulation Point）：
  - 如果删除顶点 $v$ 及其关联的所有边后，图 $G$ 的连通分量数增加，则称 $v$ 为割点
  - 割点的删除会破坏图的连通性

- **桥**（Bridge 或 Cut Edge）：
  - 如果删除边 $e$ 后，图 $G$ 的连通分量数增加，则称 $e$ 为桥
  - 桥的删除会破坏图的连通性
  - 每个桥连接两个不同的双连通分量

**Tarjan算法**可以在 $O(|V| + |E|)$ 时间内找出图中的所有割点和桥。

**点连通度与边连通度**:

- **点连通度**（Vertex Connectivity）：
  - 图 $G$ 的点连通度 $\kappa(G)$ 是使 $G$ 不连通所需删除的最少顶点数
  - 如果 $G$ 不是完全图，则 $\kappa(G)$ 等于任意两个非相邻顶点之间的最小点不相交路径数
  - 完全图 $K_n$ 的点连通度为 $n-1$

- **边连通度**（Edge Connectivity）：
  - 图 $G$ 的边连通度 $\lambda(G)$ 是使 $G$ 不连通所需删除的最少边数
  - $\lambda(G)$ 等于任意两个顶点之间的最小边不相交路径数
  - 对于任何图 $G$，都有 $\kappa(G) \leq \lambda(G) \leq \delta(G)$，其中 $\delta(G)$ 是图中最小度数

**连通度的应用**：

- 网络可靠性分析
- 鲁棒通信系统设计
- 关键基础设施保护

### 2.3 图的遍历

图的遍历是指按照某种系统性的方式访问图中所有顶点的过程。两种基本的图遍历方法是深度优先搜索和广度优先搜索。

**深度优先搜索 (DFS)**:

深度优先搜索是一种优先走到最深处，然后回溯的遍历策略。

**算法描述**：

1. 选择一个起始顶点，标记为已访问
2. 递归地访问该顶点的一个未访问的邻接顶点
3. 如果当前顶点的所有邻接顶点都已被访问，则回溯到上一个顶点
4. 重复步骤2和3，直到所有顶点都被访问

**伪代码实现**：

```text
DFS(G, v):
    标记顶点v为已访问
    对于v的每个未访问的邻接顶点w:
        DFS(G, w)
```

**时间复杂度**：

- 使用邻接表表示：$O(|V| + |E|)$
- 使用邻接矩阵表示：$O(|V|^2)$

**DFS的应用**：

- 拓扑排序
- 检测有向图中的环
- 寻找强连通分量
- 解决迷宫问题

**广度优先搜索 (BFS)**:

广度优先搜索是一种优先访问所有邻接顶点，然后再向下一层扩展的遍历策略。

**算法描述**：

1. 选择一个起始顶点，标记为已访问，并将其加入队列
2. 从队列中取出一个顶点，访问其所有未访问的邻接顶点，标记它们为已访问，并将它们加入队列
3. 重复步骤2，直到队列为空

**伪代码实现**：

```text
BFS(G, s):
    创建一个队列Q
    标记顶点s为已访问，并将s加入队列Q
    当Q非空时:
        从Q中取出顶点v
        对于v的每个未访问的邻接顶点w:
            标记w为已访问
            将w加入队列Q
```

**时间复杂度**：

- 使用邻接表表示：$O(|V| + |E|)$
- 使用邻接矩阵表示：$O(|V|^2)$

**BFS的应用**：

- 寻找无权图中的最短路径
- 网络爬虫
- 社交网络中的"六度分离"计算
- 寻找连通分量

**遍历算法的比较**：

| 特性 | DFS | BFS |
|------|-----|-----|
| 实现方式 | 递归或栈 | 队列 |
| 空间复杂度 | $O(h)$，$h$是图的高度 | $O(w)$，$w$是图的宽度 |
| 完整性 | 可能不找到最短路径 | 保证找到最短路径（无权图） |
| 适用场景 | 探索所有可能路径，检测环 | 寻找最短路径，层次遍历 |
| 特点 | 深入探索，回溯 | 逐层扩展 |

DFS和BFS是图算法的基础，许多复杂的图算法都是建立在这两种遍历方法之上的。

## 3. 特殊图类

### 3.1 树

**树的定义与性质**:

**树**（Tree）是一种无环连通无向图，具有以下等价定义：

- 无环连通图
- 任意两个顶点之间恰有一条简单路径的图
- 连通且具有 $n-1$ 条边的 $n$ 顶点图
- 无环且具有 $n-1$ 条边的 $n$ 顶点图
- 极小连通图（删除任何一条边后不再连通）
- 极大无环图（添加任何一条边后会形成环）

**树的基本性质**：

1. 树有 $n$ 个顶点，则有 $n-1$ 条边
2. 树中任意两个顶点之间存在唯一的简单路径
3. 树没有环
4. 树是连通的
5. 树中至少有两个叶子节点（度为1的顶点），当 $n \geq 2$ 时

**生成树**:

**生成树**（Spanning Tree）是连通图 $G$ 的一个子图，它是一棵包含 $G$ 中所有顶点的树。

**生成树的性质**：

- 如果图 $G$ 有 $n$ 个顶点，则其任何生成树有 $n-1$ 条边
- 图 $G$ 的不同生成树可能有不同的结构
- 连通图 $G$ 至少有一棵生成树
- 非连通图没有生成树

**最小生成树算法**:

**最小生成树**（Minimum Spanning Tree, MST）是带权连通无向图中权值和最小的生成树。

两种经典的最小生成树算法：

1. **Kruskal算法**：
   - 基于贪心策略，按边权重从小到大考虑
   - 算法步骤：
     1. 将图 $G$ 中所有边按权重升序排序
     2. 初始化一个空集合 $T$
     3. 按排序依次考察每条边 $(u,v)$：如果将其加入 $T$ 不会形成环，则加入
     4. 当 $T$ 包含 $n-1$ 条边时停止
   - 时间复杂度：$O(|E| \log |E|)$，主要是排序的时间
   - 使用并查集数据结构可以高效判断是否形成环

2. **Prim算法**：
   - 基于贪心策略，从一个顶点开始逐步扩展
   - 算法步骤：
     1. 选择任意起始顶点 $s$，初始化树 $T = \{s\}$
     2. 重复以下步骤直到 $T$ 包含所有顶点：
        - 选择一条最小权重的边 $(u,v)$，其中 $u \in T$，$v \not\in T$
        - 将顶点 $v$ 和边 $(u,v)$ 加入 $T$
   - 时间复杂度：使用二叉堆实现为 $O(|E| \log |V|)$，使用斐波那契堆可优化至 $O(|E| + |V| \log |V|)$

**Kruskal与Prim算法比较**：

- Kruskal算法适合稀疏图（边较少）
- Prim算法适合稠密图（边较多）
- 两种算法都能保证找到最小生成树
- 如果图有多棵最小生成树（即存在权值相等的边），不同算法可能得到不同的树

**二叉树与多叉树**:

**二叉树**（Binary Tree）是每个节点最多有两个子节点的树，通常称为"左子节点"和"右子节点"。

**二叉树的性质**：

- 第 $i$ 层最多有 $2^{i-1}$ 个节点（$i \geq 1$）
- 深度为 $k$ 的二叉树最多有 $2^k - 1$ 个节点
- 任何二叉树，如果叶节点数为 $n_0$，度为2的节点数为 $n_2$，则 $n_0 = n_2 + 1$

**特殊二叉树**：

- **满二叉树**：除叶节点外，每个节点都有两个子节点
- **完全二叉树**：除最后一层外，每层都填满，且最后一层的节点从左到右填充
- **平衡二叉树**：任意节点的左右子树高度差不超过1

**多叉树**（Multiway Tree）是每个节点可以有多于两个子节点的树。

**特殊多叉树**：

- **B树**：自平衡的搜索树，用于数据库和文件系统
- **Trie树**（前缀树）：用于高效存储和检索字符串
- **堆**：完全二叉树，满足堆属性（最大堆或最小堆）

### 3.2 二分图

**二分图的定义与性质**:

**二分图**（Bipartite Graph）是一种可以将顶点集合分割为两个不相交的子集 $X$ 和 $Y$，使得每条边连接的两个顶点分别来自 $X$ 和 $Y$ 的图。

**二分图的等价定义**：

- 顶点可分为两个独立集（没有边连接同一集合内的顶点）
- 图中不存在长度为奇数的环
- 图可以进行二着色（用两种颜色为顶点着色，使相邻顶点颜色不同）

**二分图的性质**：

1. 二分图中所有环的长度都是偶数
2. 二分图不包含奇数长度的环
3. 如果图是连通的，则二分划分是唯一的（忽略两个集合的交换）
4. 完全二分图 $K_{m,n}$ 有 $m+n$ 个顶点和 $m \times n$ 条边

**二分图的判定算法**:

判断一个图是否为二分图的标准方法是使用**二着色算法**：

1. 选择任意起始顶点，将其着为颜色1
2. 使用BFS或DFS遍历图，将每个顶点的邻居着为不同于该顶点的颜色
3. 如果在过程中发现任何冲突（相邻顶点需要相同颜色），则图不是二分图
4. 如果能成功完成着色，则图是二分图

**伪代码实现**（使用BFS）：

```text
IsBipartite(G):
    对所有顶点v，初始化color[v] = UNCOLORED
    对于G中的每个连通分量:
        选择一个未着色的顶点s
        color[s] = RED
        创建队列Q并加入s
        当Q非空时:
            取出顶点v
            对于v的每个邻居u:
                如果color[u] == UNCOLORED:
                    color[u] = 与color[v]相反的颜色
                    将u加入队列Q
                否则如果color[u] == color[v]:
                    返回false（不是二分图）
    返回true（是二分图）
```

**时间复杂度**：$O(|V| + |E|)$

**二分图匹配问题**:

**匹配**（Matching）是图中一组边的集合，其中任意两条边不共享顶点。

**二分图匹配**是指在二分图中寻找匹配。

**最大匹配**（Maximum Matching）是具有最多边数的匹配。

**完美匹配**（Perfect Matching）是覆盖所有顶点的匹配（每个顶点都是某条匹配边的端点）。

**寻找二分图最大匹配的算法**：

1. **匈牙利算法**（Hungarian Algorithm）：
   - 基于增广路径（augmenting path）的概念
   - 算法步骤：
     1. 初始化一个空匹配 $M$
     2. 对于每个未匹配的顶点 $u \in X$：
        - 尝试找到一条增广路径，即从 $u$ 开始的交替路径，以未匹配的顶点 $v \in Y$ 结束
        - 如果找到增广路径，则更新匹配 $M$
   - 时间复杂度：$O(|V| \times |E|)$

2. **Hopcroft-Karp算法**：
   - 匈牙利算法的优化版本，一次寻找多条增广路径
   - 时间复杂度：$O(|E| \sqrt{|V|})$

**最大匹配与最小覆盖**:

**顶点覆盖**（Vertex Cover）是一组顶点，使得图中每条边至少有一个端点在该组中。

**最小顶点覆盖**（Minimum Vertex Cover）是具有最少顶点数的顶点覆盖。

**Kőnig定理**：在二分图中，最大匹配的大小等于最小顶点覆盖的大小。

这一定理建立了二分图匹配问题与覆盖问题之间的重要联系，也是二分图特有的性质（在一般图中不成立）。

**二分图匹配的应用**：

- 任务分配问题
- 人员调度
- 网络流问题
- 最大权二分匹配（带权二分图中寻找权值和最大的匹配）

### 3.3 平面图

**平面图的定义**:

**平面图**（Planar Graph）是可以在平面上绘制的图，使得边只在顶点处相交（即没有边的交叉）。

**平面嵌入**（Planar Embedding）是平面图在平面上的一种特定绘制方式，没有边的交叉。

**面**（Face）是平面嵌入中被边围成的区域，包括一个无界的外部面。

**欧拉公式**:

对于连通平面图，如果有 $v$ 个顶点、$e$ 条边和 $f$ 个面，则：

$$v - e + f = 2$$

这个公式被称为**欧拉公式**（Euler's Formula），是平面图理论中最基本的结果之一。

**欧拉公式的推论**：

1. 如果平面图有 $v \geq 3$ 个顶点，则 $e \leq 3v - 6$
2. 如果平面图是简单图且没有环和多重边，则至少有一个顶点的度数不超过5
3. 每个平面图都是6-可着色的（六色定理）

**平面图的特性**:

1. **对偶图**（Dual Graph）：
   - 对于平面图 $G$ 的每个平面嵌入，可以定义其对偶图 $G^*$
   - $G^*$ 的每个顶点对应 $G$ 的一个面
   - $G^*$ 中的边连接相邻面对应的顶点
   - 如果 $G$ 是连通的，则 $(G^*)^* = G$

2. **面的度数**：
   - 面的度数是围绕该面的边的数量
   - 对于简单连通平面图，所有面的度数之和等于 $2e$

3. **平面三角剖分**：
   - 平面图的三角剖分是在图中添加边，使得所有面（除外部面外）都是三角形
   - 具有 $v$ 个顶点的平面三角剖分恰好有 $3v - 6$ 条边和 $2v - 4$ 个面

**库拉托夫斯基定理**:

**库拉托夫斯基定理**（Kuratowski's Theorem）给出了判断图是否为平面图的拓扑特征：

一个图是平面图当且仅当它不包含 $K_5$（完全图，5个顶点）或 $K_{3,3}$（完全二分图，3+3个顶点）作为子图或细分图。

这里的**细分图**（Subdivision）是指通过在边上添加顶点得到的图。

**瓦格纳定理**（Wagner's Theorem）是库拉托夫斯基定理的一个变形：一个图是平面图当且仅当它不包含 $K_5$ 或 $K_{3,3}$ 作为导出子图或收缩。

**平面图的应用**：

- 电路设计（避免导线交叉）
- 地图着色问题
- 图形用户界面布局
- 分子结构表示

## 4. 图的着色

### 4.1 顶点着色

**顶点着色问题**:

**顶点着色**（Vertex Coloring）是为图的顶点分配"颜色"，使得相邻顶点具有不同颜色。

**图的色数**（Chromatic Number），记为 $\chi(G)$，是为图 $G$ 进行正确着色所需的最少颜色数。

**顶点着色问题**：给定图 $G$，求其色数 $\chi(G)$。

**顶点着色的基本结果**：

1. 任何图 $G$ 的色数满足 $\chi(G) \leq \Delta(G) + 1$，其中 $\Delta(G)$ 是图中的最大度数
2. 如果 $G$ 是二分图，则 $\chi(G) \leq 2$
3. 如果 $G$ 是平面图，则 $\chi(G) \leq 4$（四色定理）
4. 如果 $G$ 是完全图 $K_n$，则 $\chi(G) = n$

**色多项式**:

**色多项式**（Chromatic Polynomial）$P(G, k)$ 表示使用不超过 $k$ 种颜色为图 $G$ 进行顶点着色的方法数。

**色多项式的性质**：

1. $P(G, k)$ 是关于 $k$ 的多项式
2. 如果 $G$ 有 $n$ 个顶点，则 $P(G, k)$ 的次数为 $n$
3. $P(G, k)$ 的首项系数为1
4. $P(G, 0) = 0$
5. 如果 $\chi(G) = m$，则 $P(G, k) = 0$ 对于 $k < m$，且 $P(G, m) > 0$

**计算色多项式的递归方法**：

- 对于边 $e = (u, v)$，有 $P(G, k) = P(G - e, k) - P(G/e, k)$
  - 其中 $G - e$ 是删除边 $e$ 的图
  - $G/e$ 是收缩边 $e$（合并顶点 $u$ 和 $v$）的图

**贪心着色算法**:

尽管确定图的精确色数是NP-完全问题，但有一些启发式算法可以得到近似解：

**贪心着色算法**：

1. 按某种顺序考虑图中的顶点
2. 为每个顶点分配可用的最小颜色编号（不与已着色的邻接顶点冲突）

**常见的顶点排序方法**：

- 随机顺序
- 按度数降序（饱和度着色）
- 按饱和度降序（已着色邻居的不同颜色数）

**贪心算法的性能**：

- 最坏情况下，贪心算法可能使用 $\Delta(G) + 1$ 种颜色
- 对于特定图类（如二分图、树），贪心算法可以达到最优解
- 对于一般图，贪心算法的性能依赖于顶点考虑的顺序

**四色定理简介**:

**四色定理**（Four Color Theorem）：任何平面图都可以用不超过四种颜色进行顶点着色，使得相邻顶点颜色不同。

**历史背景**：

- 1852年，Francis Guthrie首次提出四色猜想
- 1976年，Kenneth Appel和Wolfgang Haken给出了证明，使用计算机验证了1,936种情况
- 这是第一个主要依赖计算机的数学证明，引发了关于证明本质的哲学讨论
- 1997年，Robertson、Sanders、Seymour和Thomas给出了简化的证明，减少了需要验证的情况数

**四色定理的意义**：

- 在图论中具有里程碑意义
- 对地图着色问题提供了理论上限
- 推动了计算机辅助证明的发展
- 在组合数学中具有深远影响

### 4.2 边着色

**边着色问题**:

**边着色**（Edge Coloring）是为图的边分配"颜色"，使得相邻边（共享顶点的边）具有不同颜色。

**图的边色数**（Edge Chromatic Number），记为 $\chi'(G)$，是为图 $G$ 进行正确边着色所需的最少颜色数。

**边着色问题**：给定图 $G$，求其边色数 $\chi'(G)$。

**边色数的基本结果**：

1. 任何图 $G$ 的边色数满足 $\chi'(G) \geq \Delta(G)$，其中 $\Delta(G)$ 是图中的最大度数
2. **Vizing定理**：任何简单图 $G$ 的边色数满足 $\Delta(G) \leq \chi'(G) \leq \Delta(G) + 1$

根据Vizing定理，简单图可以分为两类：

- **第1类图**：$\chi'(G) = \Delta(G)$
- **第2类图**：$\chi'(G) = \Delta(G) + 1$

区分一个图是第1类还是第2类是一个NP-完全问题。

**边色数的特殊情况**：

- 二分图：$\chi'(G) = \Delta(G)$（Kőnig定理）
- 完全图 $K_n$：
  - 当 $n$ 为偶数时，$\chi'(K_n) = n - 1$
  - 当 $n$ 为奇数时，$\chi'(K_n) = n$

**二部图的边着色**:

**Kőnig定理**：如果 $G$ 是二分图，则 $\chi'(G) = \Delta(G)$。

这意味着二分图的边着色问题可以用最优的颜色数解决。

**二分图边着色算法**：

1. 将边着色问题转化为顶点着色问题：
   - 构造线图 $L(G)$，其中 $L(G)$ 的顶点对应 $G$ 的边
   - 如果 $G$ 中的两条边相邻，则 $L(G)$ 中对应的顶点相邻
2. 对于二分图，其线图的顶点着色可以在多项式时间内解决

**另一种方法**是直接应用匹配算法：

1. 将所有边按颜色分组，每种颜色形成一个匹配
2. 问题转化为：将边集划分为最少数量的匹配
3. 对于二分图，可以使用贪心算法：
   - 重复寻找最大匹配并分配新颜色，直到所有边都被着色

**维辛定理**:

**维辛定理**（Vizing's Theorem）：任何简单图 $G$ 的边色数满足：

$$\Delta(G) \leq \chi'(G) \leq \Delta(G) + 1$$

这一定理给出了边色数的紧界，表明任何简单图的边色数要么等于其最大度数，要么比最大度数多1。

**维辛定理的构造性证明**提供了一个算法，可以在多项式时间内找到使用不超过 $\Delta(G) + 1$ 种颜色的边着色。

**边着色的应用**：

- 调度问题（如考试安排）
- 频率分配问题
- 寄存器分配
- 通信网络中的时隙分配

### 4.3 总图着色与其他着色变体

**总图着色**（Total Coloring）是同时为图的顶点和边分配颜色，使得相邻或关联的元素具有不同颜色。

**总色数**（Total Chromatic Number），记为 $\chi''(G)$，是总图着色所需的最少颜色数。

**总图着色猜想**：对于任何简单图 $G$，$\chi''(G) \leq \Delta(G) + 2$。

**其他着色变体**：

- **列表着色**（List Coloring）：每个顶点有一个可用颜色列表
- **调和着色**（Harmonious Coloring）：任意两条边的端点都有不同的颜色组合
- **完美着色**（Perfect Coloring）：每个颜色类形成一个独立集
- **T-着色**（T-Coloring）：相邻顶点的颜色差不在禁止集T中

**着色问题的计算复杂性**：

- 大多数着色问题是NP-完全的
- 对于特殊图类（如二分图、完全图、环）有多项式时间算法
- 近似算法和启发式方法在实践中很重要

## 5. 图的优化问题

### 5.1 最短路径

- 单源最短路径问题
- Dijkstra算法
- Bellman-Ford算法
- Floyd-Warshall算法

### 5.2 网络流

- 流网络基本概念
- 最大流问题
- Ford-Fulkerson算法
- 最小割最大流定理

### 5.3 匹配问题

- 二分图匹配
- 带权二分图匹配
- 匈牙利算法
- 稳定匹配与Gale-Shapley算法

## 6. 图论的应用

### 6.1 计算机网络

- 网络拓扑设计
- 路由算法
- 网络可靠性分析

### 6.2 社交网络分析

- 社交网络建模
- 中心性度量
- 社区发现算法

### 6.3 生物信息学

- 分子网络建模
- 蛋白质相互作用网络
- 基因调控网络分析

### 6.4 交通规划

- 交通网络建模
- 交通流分析
- 路线优化问题

## 7. 现代图论前沿

### 7.1 随机图理论

- Erdős–Rényi模型
- 小世界网络
- 无标度网络

### 7.2 谱图理论

- 图的特征值与特征向量
- 拉普拉斯矩阵
- 谱聚类

### 7.3 图神经网络

- 图嵌入
- 图卷积网络
- 图注意力网络

## 参考文献

1. Bondy, J. A., & Murty, U. S. R. (2008). Graph Theory. Springer.
2. West, D. B. (2000). Introduction to Graph Theory (2nd ed.). Prentice Hall.
3. Diestel, R. (2017). Graph Theory (5th ed.). Springer.
4. Newman, M. (2010). Networks: An Introduction. Oxford University Press.

---

**创建日期**: 2024-06-20
**最后更新**: 2024-06-20
**作者**: AI助手

**注**: 本文档是图论基础的概要大纲，后续将逐步完善各章节的详细内容，包括定理证明、算法实现和应用案例分析。
