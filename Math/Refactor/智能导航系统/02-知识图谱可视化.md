# 02-çŸ¥è¯†å›¾è°±å¯è§†åŒ–

## ğŸ“Š ç³»ç»Ÿæ¦‚è¿°

- **ç³»ç»Ÿåç§°**: RefactorçŸ¥è¯†å›¾è°±å¯è§†åŒ–ç³»ç»Ÿ
- **æ ¸å¿ƒåŠŸèƒ½**: äº¤äº’å¼æ•°å­¦çŸ¥è¯†ç½‘ç»œå±•ç¤ºä¸æ¢ç´¢
- **æŠ€æœ¯æ ˆ**: React + D3.js + Python + Neo4j
- **å¯è§†åŒ–ç›®æ ‡**: ç›´è§‚å±•ç¤ºæ•°å­¦æ¦‚å¿µé—´çš„å…³è”å…³ç³»

---

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½è®¾è®¡

### 1. çŸ¥è¯†å›¾è°±æ„å»ºåŠŸèƒ½

#### 1.1 æ¦‚å¿µèŠ‚ç‚¹æå–

```python
# æ¦‚å¿µèŠ‚ç‚¹æå–å™¨
class ConceptNodeExtractor:
    def __init__(self):
        self.math_concepts = self.load_math_concepts()
        self.concept_patterns = self.load_concept_patterns()
    
    def extract_concepts_from_content(self, content, file_path):
        """ä»å†…å®¹ä¸­æå–æ•°å­¦æ¦‚å¿µ"""
        concepts = []
        
        # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–æ¦‚å¿µ
        for pattern in self.concept_patterns:
            matches = re.findall(pattern, content)
            for match in matches:
                concept = self.normalize_concept(match)
                if concept in self.math_concepts:
                    concepts.append({
                        'concept': concept,
                        'category': self.math_concepts[concept]['category'],
                        'file_path': file_path,
                        'position': content.find(match)
                    })
        
        return concepts
    
    def normalize_concept(self, concept):
        """æ ‡å‡†åŒ–æ¦‚å¿µåç§°"""
        # ç§»é™¤LaTeXæ ‡è®°
        concept = re.sub(r'\\[a-zA-Z]+', '', concept)
        # ç§»é™¤æ•°å­¦ç¬¦å·
        concept = re.sub(r'[^\w\s]', '', concept)
        return concept.strip().lower()
    
    def build_concept_graph(self, documents):
        """æ„å»ºæ¦‚å¿µå›¾è°±"""
        graph = {
            'nodes': [],
            'edges': []
        }
        
        concept_nodes = {}
        
        for doc in documents:
            concepts = self.extract_concepts_from_content(
                doc['content'], doc['file_path'])
            
            for concept_info in concepts:
                concept_id = f"concept_{len(concept_nodes)}"
                concept_nodes[concept_info['concept']] = concept_id
                
                graph['nodes'].append({
                    'id': concept_id,
                    'label': concept_info['concept'],
                    'category': concept_info['category'],
                    'file_path': concept_info['file_path']
                })
        
        # æ„å»ºæ¦‚å¿µé—´çš„è¾¹
        graph['edges'] = self.build_concept_relationships(graph['nodes'])
        
        return graph
```

#### 1.2 å…³ç³»è¯†åˆ«ä¸æ„å»º

```python
# å…³ç³»è¯†åˆ«å™¨
class RelationshipExtractor:
    def __init__(self):
        self.relationship_patterns = {
            'definition': r'(å®šä¹‰|å®šä¹‰äº|å®šä¹‰ä¸º)',
            'theorem': r'(å®šç†|å¼•ç†|æ¨è®º)',
            'proof': r'(è¯æ˜|æ¨å¯¼|è¯æ˜è¿‡ç¨‹)',
            'application': r'(åº”ç”¨|åº”ç”¨äº|åœ¨.*ä¸­çš„åº”ç”¨)',
            'generalization': r'(æ¨å¹¿|ä¸€èˆ¬åŒ–|æ‰©å±•)',
            'specialization': r'(ç‰¹ä¾‹|ç‰¹æ®Šæƒ…å†µ|å…·ä½“åŒ–)'
        }
    
    def extract_relationships(self, content, concepts):
        """æå–æ¦‚å¿µé—´çš„å…³ç³»"""
        relationships = []
        
        for i, concept1 in enumerate(concepts):
            for j, concept2 in enumerate(concepts[i+1:], i+1):
                relationship = self.find_relationship(
                    content, concept1, concept2)
                if relationship:
                    relationships.append({
                        'source': concept1['concept'],
                        'target': concept2['concept'],
                        'type': relationship['type'],
                        'strength': relationship['strength']
                    })
        
        return relationships
    
    def find_relationship(self, content, concept1, concept2):
        """æŸ¥æ‰¾ä¸¤ä¸ªæ¦‚å¿µé—´çš„å…³ç³»"""
        # æŸ¥æ‰¾æ¦‚å¿µåœ¨å†…å®¹ä¸­çš„ä½ç½®
        pos1 = content.find(concept1['concept'])
        pos2 = content.find(concept2['concept'])
        
        if pos1 == -1 or pos2 == -1:
            return None
        
        # åˆ†ææ¦‚å¿µé—´çš„æ–‡æœ¬å†…å®¹
        start = min(pos1, pos2)
        end = max(pos1, pos2) + max(len(concept1['concept']), len(concept2['concept']))
        context = content[start:end]
        
        # è¯†åˆ«å…³ç³»ç±»å‹
        for rel_type, pattern in self.relationship_patterns.items():
            if re.search(pattern, context):
                return {
                    'type': rel_type,
                    'strength': self.calculate_relationship_strength(context)
                }
        
        return None
    
    def calculate_relationship_strength(self, context):
        """è®¡ç®—å…³ç³»å¼ºåº¦"""
        # åŸºäºä¸Šä¸‹æ–‡é•¿åº¦å’Œå…³é”®è¯å¯†åº¦è®¡ç®—å¼ºåº¦
        keywords = ['å®šä¹‰', 'å®šç†', 'è¯æ˜', 'åº”ç”¨', 'æ¨å¹¿']
        keyword_count = sum(1 for keyword in keywords if keyword in context)
        return min(1.0, keyword_count / len(keywords))
```

### 2. å¯è§†åŒ–æ¸²æŸ“åŠŸèƒ½

#### 2.1 åŠ›å¯¼å‘å›¾å¸ƒå±€

```javascript
// åŠ›å¯¼å‘å›¾å¸ƒå±€å¼•æ“
class ForceDirectedLayout {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(30));
    }
    
    updateLayout(nodes, links) {
        this.simulation
            .nodes(nodes)
            .on("tick", () => this.ticked(nodes, links));
        
        this.simulation.force("link")
            .links(links)
            .distance(d => this.calculateLinkDistance(d));
    }
    
    calculateLinkDistance(link) {
        // æ ¹æ®å…³ç³»ç±»å‹å’Œå¼ºåº¦è®¡ç®—è¿æ¥è·ç¦»
        const baseDistance = 100;
        const strengthFactor = 1 - link.strength;
        return baseDistance * strengthFactor;
    }
    
    ticked(nodes, links) {
        // æ›´æ–°èŠ‚ç‚¹ä½ç½®
        nodes.forEach(node => {
            node.x = Math.max(30, Math.min(this.width - 30, node.x));
            node.y = Math.max(30, Math.min(this.height - 30, node.y));
        });
        
        // æ›´æ–°è¿æ¥çº¿ä½ç½®
        links.forEach(link => {
            link.x1 = link.source.x;
            link.y1 = link.source.y;
            link.x2 = link.target.x;
            link.y2 = link.target.y;
        });
    }
}
```

#### 2.2 èŠ‚ç‚¹æ¸²æŸ“ç»„ä»¶

```javascript
// èŠ‚ç‚¹æ¸²æŸ“ç»„ä»¶
class NodeRenderer {
    constructor(container) {
        this.container = container;
        this.nodeGroups = container.append("g")
            .attr("class", "nodes");
    }
    
    renderNodes(nodes) {
        const node = this.nodeGroups.selectAll(".node")
            .data(nodes, d => d.id)
            .join("g")
            .attr("class", "node")
            .call(this.dragBehavior());
        
        // æ¸²æŸ“èŠ‚ç‚¹åœ†åœˆ
        node.append("circle")
            .attr("r", d => this.calculateNodeRadius(d))
            .attr("fill", d => this.getNodeColor(d.category))
            .attr("stroke", "#fff")
            .attr("stroke-width", 2);
        
        // æ¸²æŸ“èŠ‚ç‚¹æ ‡ç­¾
        node.append("text")
            .text(d => d.label)
            .attr("text-anchor", "middle")
            .attr("dy", ".35em")
            .attr("font-size", "12px")
            .attr("fill", "#333");
        
        // æ·»åŠ äº¤äº’äº‹ä»¶
        node.on("click", this.handleNodeClick.bind(this))
            .on("mouseover", this.handleNodeHover.bind(this))
            .on("mouseout", this.handleNodeOut.bind(this));
    }
    
    calculateNodeRadius(node) {
        // æ ¹æ®èŠ‚ç‚¹é‡è¦æ€§è®¡ç®—åŠå¾„
        const baseRadius = 15;
        const importance = node.importance || 1;
        return baseRadius * Math.sqrt(importance);
    }
    
    getNodeColor(category) {
        const colorMap = {
            'algebra': '#ff7f0e',
            'analysis': '#2ca02c',
            'geometry': '#d62728',
            'topology': '#9467bd',
            'logic': '#8c564b',
            'number_theory': '#e377c2'
        };
        return colorMap[category] || '#7f7f7f';
    }
    
    handleNodeClick(event, node) {
        // å¤„ç†èŠ‚ç‚¹ç‚¹å‡»äº‹ä»¶
        this.onNodeClick(node);
    }
    
    handleNodeHover(event, node) {
        // å¤„ç†èŠ‚ç‚¹æ‚¬åœäº‹ä»¶
        d3.select(event.currentTarget).select("circle")
            .attr("stroke-width", 4);
    }
    
    handleNodeOut(event, node) {
        // å¤„ç†èŠ‚ç‚¹ç¦»å¼€äº‹ä»¶
        d3.select(event.currentTarget).select("circle")
            .attr("stroke-width", 2);
    }
}
```

#### 2.3 è¿æ¥çº¿æ¸²æŸ“ç»„ä»¶

```javascript
// è¿æ¥çº¿æ¸²æŸ“ç»„ä»¶
class LinkRenderer {
    constructor(container) {
        this.container = container;
        this.linkGroups = container.append("g")
            .attr("class", "links");
    }
    
    renderLinks(links) {
        const link = this.linkGroups.selectAll(".link")
            .data(links, d => d.source.id + "-" + d.target.id)
            .join("line")
            .attr("class", "link")
            .attr("stroke", d => this.getLinkColor(d.type))
            .attr("stroke-width", d => this.calculateLinkWidth(d.strength))
            .attr("opacity", 0.6);
        
        // æ·»åŠ è¿æ¥çº¿æ ‡ç­¾
        const linkLabels = this.linkGroups.selectAll(".link-label")
            .data(links, d => d.source.id + "-" + d.target.id)
            .join("text")
            .attr("class", "link-label")
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("fill", "#666");
        
        linkLabels.append("textPath")
            .attr("href", d => "#link-" + d.source.id + "-" + d.target.id)
            .text(d => d.type);
    }
    
    getLinkColor(type) {
        const colorMap = {
            'definition': '#1f77b4',
            'theorem': '#ff7f0e',
            'proof': '#2ca02c',
            'application': '#d62728',
            'generalization': '#9467bd',
            'specialization': '#8c564b'
        };
        return colorMap[type] || '#7f7f7f';
    }
    
    calculateLinkWidth(strength) {
        // æ ¹æ®å…³ç³»å¼ºåº¦è®¡ç®—çº¿å®½
        const minWidth = 1;
        const maxWidth = 5;
        return minWidth + (maxWidth - minWidth) * strength;
    }
}
```

### 3. äº¤äº’åŠŸèƒ½è®¾è®¡

#### 3.1 ç¼©æ”¾å’Œå¹³ç§»

```javascript
// ç¼©æ”¾å’Œå¹³ç§»æ§åˆ¶å™¨
class ZoomPanController {
    constructor(container) {
        this.container = container;
        this.zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", this.handleZoom.bind(this));
        
        this.container.call(this.zoom);
    }
    
    handleZoom(event) {
        const { transform } = event;
        
        this.container.selectAll(".nodes")
            .attr("transform", transform);
        
        this.container.selectAll(".links")
            .attr("transform", transform);
    }
    
    resetZoom() {
        this.container.transition()
            .duration(750)
            .call(this.zoom.transform, d3.zoomIdentity);
    }
    
    fitToView() {
        const bounds = this.container.node().getBBox();
        const fullWidth = this.container.node().clientWidth;
        const fullHeight = this.container.node().clientHeight;
        
        const width = bounds.width;
        const height = bounds.height;
        const midX = bounds.x + width / 2;
        const midY = bounds.y + height / 2;
        
        const scale = 0.9 / Math.max(width / fullWidth, height / fullHeight);
        const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
        
        this.container.transition()
            .duration(750)
            .call(this.zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
    }
}
```

#### 3.2 æœç´¢å’Œè¿‡æ»¤

```javascript
// æœç´¢å’Œè¿‡æ»¤æ§åˆ¶å™¨
class SearchFilterController {
    constructor(container) {
        this.container = container;
        this.currentFilter = null;
        this.setupSearchInterface();
    }
    
    setupSearchInterface() {
        const searchContainer = d3.select("#search-container");
        
        // æœç´¢è¾“å…¥æ¡†
        const searchInput = searchContainer.append("input")
            .attr("type", "text")
            .attr("placeholder", "æœç´¢æ¦‚å¿µ...")
            .attr("class", "search-input")
            .on("input", this.handleSearch.bind(this));
        
        // ç±»åˆ«è¿‡æ»¤å™¨
        const categoryFilter = searchContainer.append("select")
            .attr("class", "category-filter")
            .on("change", this.handleCategoryFilter.bind(this));
        
        categoryFilter.selectAll("option")
            .data(["å…¨éƒ¨", "ä»£æ•°", "åˆ†æ", "å‡ ä½•", "æ‹“æ‰‘", "é€»è¾‘", "æ•°è®º"])
            .enter()
            .append("option")
            .text(d => d)
            .attr("value", d => d);
    }
    
    handleSearch(event) {
        const searchTerm = event.target.value.toLowerCase();
        this.filterNodes(searchTerm, this.currentFilter);
    }
    
    handleCategoryFilter(event) {
        const category = event.target.value;
        this.currentFilter = category === "å…¨éƒ¨" ? null : category;
        this.filterNodes(this.currentSearchTerm, this.currentFilter);
    }
    
    filterNodes(searchTerm, category) {
        this.currentSearchTerm = searchTerm;
        
        this.container.selectAll(".node")
            .style("opacity", d => {
                const matchesSearch = !searchTerm || 
                    d.label.toLowerCase().includes(searchTerm);
                const matchesCategory = !category || 
                    d.category === category;
                return matchesSearch && matchesCategory ? 1 : 0.1;
            });
        
        this.container.selectAll(".link")
            .style("opacity", d => {
                const sourceVisible = d.source.opacity !== 0.1;
                const targetVisible = d.target.opacity !== 0.1;
                return sourceVisible && targetVisible ? 0.6 : 0.1;
            });
    }
}
```

### 4. è·¯å¾„è§„åˆ’åŠŸèƒ½

#### 4.1 æœ€çŸ­è·¯å¾„ç®—æ³•

```javascript
// è·¯å¾„è§„åˆ’å™¨
class PathPlanner {
    constructor(graph) {
        this.graph = graph;
        this.adjacencyList = this.buildAdjacencyList();
    }
    
    buildAdjacencyList() {
        const adjacencyList = {};
        
        this.graph.nodes.forEach(node => {
            adjacencyList[node.id] = [];
        });
        
        this.graph.links.forEach(link => {
            adjacencyList[link.source.id].push({
                target: link.target.id,
                weight: 1 / link.strength,
                type: link.type
            });
            adjacencyList[link.target.id].push({
                target: link.source.id,
                weight: 1 / link.strength,
                type: link.type
            });
        });
        
        return adjacencyList;
    }
    
    findShortestPath(startId, endId) {
        const distances = {};
        const previous = {};
        const queue = new PriorityQueue();
        
        // åˆå§‹åŒ–è·ç¦»
        this.graph.nodes.forEach(node => {
            distances[node.id] = Infinity;
        });
        distances[startId] = 0;
        
        queue.enqueue(startId, 0);
        
        while (!queue.isEmpty()) {
            const currentId = queue.dequeue().element;
            
            if (currentId === endId) {
                break;
            }
            
            const neighbors = this.adjacencyList[currentId] || [];
            neighbors.forEach(neighbor => {
                const distance = distances[currentId] + neighbor.weight;
                
                if (distance < distances[neighbor.target]) {
                    distances[neighbor.target] = distance;
                    previous[neighbor.target] = {
                        node: currentId,
                        type: neighbor.type
                    };
                    queue.enqueue(neighbor.target, distance);
                }
            });
        }
        
        return this.reconstructPath(previous, startId, endId);
    }
    
    reconstructPath(previous, startId, endId) {
        const path = [];
        let currentId = endId;
        
        while (currentId !== startId) {
            const prev = previous[currentId];
            if (!prev) {
                return null; // è·¯å¾„ä¸å­˜åœ¨
            }
            
            path.unshift({
                from: prev.node,
                to: currentId,
                type: prev.type
            });
            
            currentId = prev.node;
        }
        
        return path;
    }
    
    highlightPath(path) {
        // é«˜äº®æ˜¾ç¤ºè·¯å¾„
        this.container.selectAll(".link")
            .style("stroke", d => {
                const isInPath = path.some(link => 
                    (link.from === d.source.id && link.to === d.target.id) ||
                    (link.from === d.target.id && link.to === d.source.id)
                );
                return isInPath ? "#ff0000" : this.getLinkColor(d.type);
            })
            .style("stroke-width", d => {
                const isInPath = path.some(link => 
                    (link.from === d.source.id && link.to === d.target.id) ||
                    (link.from === d.target.id && link.to === d.source.id)
                );
                return isInPath ? 4 : this.calculateLinkWidth(d.strength);
            });
    }
}
```

---

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### 1. å‰ç«¯æ¶æ„

```text
çŸ¥è¯†å›¾è°±å‰ç«¯/
â”œâ”€â”€ components/              # Reactç»„ä»¶
â”‚   â”œâ”€â”€ GraphViewer/        # å›¾è°±æŸ¥çœ‹å™¨
â”‚   â”œâ”€â”€ NodeRenderer/       # èŠ‚ç‚¹æ¸²æŸ“å™¨
â”‚   â”œâ”€â”€ LinkRenderer/       # è¿æ¥çº¿æ¸²æŸ“å™¨
â”‚   â”œâ”€â”€ SearchFilter/       # æœç´¢è¿‡æ»¤å™¨
â”‚   â””â”€â”€ PathPlanner/        # è·¯å¾„è§„åˆ’å™¨
â”œâ”€â”€ services/               # æœåŠ¡å±‚
â”‚   â”œâ”€â”€ graphService.js     # å›¾è°±æœåŠ¡
â”‚   â”œâ”€â”€ searchService.js    # æœç´¢æœåŠ¡
â”‚   â””â”€â”€ pathService.js      # è·¯å¾„æœåŠ¡
â”œâ”€â”€ utils/                  # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ d3Utils.js          # D3å·¥å…·
â”‚   â”œâ”€â”€ graphUtils.js       # å›¾è°±å·¥å…·
â”‚   â””â”€â”€ layoutUtils.js      # å¸ƒå±€å·¥å…·
â””â”€â”€ styles/                 # æ ·å¼æ–‡ä»¶
    â”œâ”€â”€ graph.css           # å›¾è°±æ ·å¼
    â”œâ”€â”€ nodes.css           # èŠ‚ç‚¹æ ·å¼
    â””â”€â”€ links.css           # è¿æ¥çº¿æ ·å¼
```

### 2. åç«¯æ¶æ„

```text
çŸ¥è¯†å›¾è°±åç«¯/
â”œâ”€â”€ api/                    # APIæ¥å£
â”‚   â”œâ”€â”€ graph_api.py        # å›¾è°±API
â”‚   â”œâ”€â”€ search_api.py       # æœç´¢API
â”‚   â””â”€â”€ path_api.py         # è·¯å¾„API
â”œâ”€â”€ services/               # ä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ graph_service.py    # å›¾è°±æœåŠ¡
â”‚   â”œâ”€â”€ concept_service.py  # æ¦‚å¿µæœåŠ¡
â”‚   â””â”€â”€ relationship_service.py # å…³ç³»æœåŠ¡
â”œâ”€â”€ models/                 # æ•°æ®æ¨¡å‹
â”‚   â”œâ”€â”€ concept_model.py    # æ¦‚å¿µæ¨¡å‹
â”‚   â”œâ”€â”€ relationship_model.py # å…³ç³»æ¨¡å‹
â”‚   â””â”€â”€ graph_model.py      # å›¾è°±æ¨¡å‹
â””â”€â”€ database/               # æ•°æ®åº“
    â”œâ”€â”€ neo4j_client.py     # Neo4jå®¢æˆ·ç«¯
    â”œâ”€â”€ graph_queries.py    # å›¾è°±æŸ¥è¯¢
    â””â”€â”€ data_loader.py      # æ•°æ®åŠ è½½å™¨
```

### 3. æ•°æ®åº“è®¾è®¡

```cypher
// Neo4jå›¾æ•°æ®åº“æ¨¡å¼
// æ¦‚å¿µèŠ‚ç‚¹
CREATE (c:Concept {
    id: string,
    name: string,
    category: string,
    description: string,
    importance: float,
    file_path: string
})

// å…³ç³»è¾¹
CREATE (c1:Concept)-[r:RELATES_TO {
    type: string,
    strength: float,
    description: string
}]->(c2:Concept)

// ç´¢å¼•
CREATE INDEX ON :Concept(name)
CREATE INDEX ON :Concept(category)
CREATE INDEX ON :RELATES_TO(type)
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. æ¸²æŸ“ä¼˜åŒ–

```javascript
// è™šæ‹ŸåŒ–æ¸²æŸ“
class VirtualizedRenderer {
    constructor(container, viewport) {
        this.container = container;
        this.viewport = viewport;
        this.visibleNodes = new Set();
    }
    
    updateVisibleNodes(transform) {
        const visible = [];
        
        this.graph.nodes.forEach(node => {
            const screenX = transform.applyX(node.x);
            const screenY = transform.applyY(node.y);
            
            if (this.isInViewport(screenX, screenY)) {
                visible.push(node);
                this.visibleNodes.add(node.id);
            } else {
                this.visibleNodes.delete(node.id);
            }
        });
        
        this.renderVisibleNodes(visible);
    }
    
    isInViewport(x, y) {
        return x >= -50 && x <= this.viewport.width + 50 &&
               y >= -50 && y <= this.viewport.height + 50;
    }
}
```

### 2. æ•°æ®ä¼˜åŒ–

```python
# å›¾æ•°æ®å‹ç¼©
class GraphCompressor:
    def __init__(self):
        self.compression_ratio = 0.8
    
    def compress_graph(self, graph):
        """å‹ç¼©å›¾è°±æ•°æ®"""
        # ç§»é™¤ä½é‡è¦æ€§èŠ‚ç‚¹
        important_nodes = [node for node in graph['nodes'] 
                          if node.get('importance', 0) > 0.3]
        
        # ä¿ç•™é‡è¦è¿æ¥
        important_edges = [edge for edge in graph['edges'] 
                          if edge.get('strength', 0) > 0.5]
        
        return {
            'nodes': important_nodes,
            'edges': important_edges
        }
    
    def hierarchical_clustering(self, graph):
        """å±‚æ¬¡èšç±»å‹ç¼©"""
        # å®ç°å±‚æ¬¡èšç±»ç®—æ³•
        pass
```

---

## ğŸš€ éƒ¨ç½²æ–¹æ¡ˆ

### 1. å®¹å™¨åŒ–éƒ¨ç½²

```dockerfile
# å‰ç«¯Dockerfile
FROM node:16-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

EXPOSE 3000

CMD ["npm", "start"]
```

```dockerfile
# åç«¯Dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 2. å¾®æœåŠ¡æ¶æ„

```yaml
# docker-compose.yml
version: '3.8'
services:
  graph-frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - graph-backend
  
  graph-backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - NEO4J_URI=bolt://neo4j:7687
    depends_on:
      - neo4j
  
  neo4j:
    image: neo4j:4.4
    ports:
      - "7474:7474"
      - "7687:7687"
    environment:
      - NEO4J_AUTH=neo4j/password
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs

volumes:
  neo4j_data:
  neo4j_logs:
```

---

## ğŸ“ˆ ç›‘æ§ä¸åˆ†æ

### 1. æ€§èƒ½ç›‘æ§

- **æ¸²æŸ“æ€§èƒ½**: ç›‘æ§å›¾è°±æ¸²æŸ“å¸§ç‡
- **äº¤äº’å“åº”**: ç›‘æ§ç”¨æˆ·äº¤äº’å“åº”æ—¶é—´
- **å†…å­˜ä½¿ç”¨**: ç›‘æ§å†…å­˜æ¶ˆè€—æƒ…å†µ
- **ç½‘ç»œå»¶è¿Ÿ**: ç›‘æ§APIè¯·æ±‚å»¶è¿Ÿ

### 2. ç”¨æˆ·è¡Œä¸ºåˆ†æ

- **æœç´¢æ¨¡å¼**: åˆ†æç”¨æˆ·æœç´¢è¡Œä¸º
- **è·¯å¾„æ¢ç´¢**: è·Ÿè¸ªç”¨æˆ·è·¯å¾„æ¢ç´¢æ¨¡å¼
- **èŠ‚ç‚¹ç‚¹å‡»**: ç»Ÿè®¡èŠ‚ç‚¹ç‚¹å‡»é¢‘ç‡
- **åœç•™æ—¶é—´**: åˆ†æç”¨æˆ·åœç•™æ—¶é—´

---

## ğŸ¯ åç»­å‘å±•

### 1. åŠŸèƒ½æ‰©å±•

- **3Då¯è§†åŒ–**: æ”¯æŒ3Då›¾è°±å±•ç¤º
- **åŠ¨ç”»æ•ˆæœ**: æ·»åŠ åŠ¨æ€è¿‡æ¸¡æ•ˆæœ
- **å¤šè§†å›¾**: æ”¯æŒå¤šç§è§†å›¾æ¨¡å¼
- **åä½œåŠŸèƒ½**: æ”¯æŒå¤šäººåä½œç¼–è¾‘

### 2. æ™ºèƒ½åŒ–æå‡

- **è‡ªåŠ¨å¸ƒå±€**: æ™ºèƒ½ä¼˜åŒ–å›¾è°±å¸ƒå±€
- **æ¨èè·¯å¾„**: æ™ºèƒ½æ¨èå­¦ä¹ è·¯å¾„
- **å¼‚å¸¸æ£€æµ‹**: è‡ªåŠ¨æ£€æµ‹å¼‚å¸¸å…³ç³»
- **é¢„æµ‹åˆ†æ**: é¢„æµ‹æ¦‚å¿µå‘å±•è¶‹åŠ¿

---

*æœ¬æ–‡æ¡£ä¸ºçŸ¥è¯†å›¾è°±å¯è§†åŒ–ç³»ç»Ÿçš„è¯¦ç»†è®¾è®¡ï¼Œä¸ºRefactoré¡¹ç›®çš„æ™ºèƒ½åŒ–å¯¼èˆªç³»ç»Ÿæä¾›å¯è§†åŒ–æ”¯æ’‘ã€‚*
