# 02-知识图谱可视化

## 📊 系统概述

- **系统名称**: Refactor知识图谱可视化系统
- **核心功能**: 交互式数学知识网络展示与探索
- **技术栈**: React + D3.js + Python + Neo4j
- **可视化目标**: 直观展示数学概念间的关联关系

---

## 🎯 核心功能设计

### 1. 知识图谱构建功能

#### 1.1 概念节点提取

```python
# 概念节点提取器
class ConceptNodeExtractor:
    def __init__(self):
        self.math_concepts = self.load_math_concepts()
        self.concept_patterns = self.load_concept_patterns()
    
    def extract_concepts_from_content(self, content, file_path):
        """从内容中提取数学概念"""
        concepts = []
        
        # 使用正则表达式提取概念
        for pattern in self.concept_patterns:
            matches = re.findall(pattern, content)
            for match in matches:
                concept = self.normalize_concept(match)
                if concept in self.math_concepts:
                    concepts.append({
                        'concept': concept,
                        'category': self.math_concepts[concept]['category'],
                        'file_path': file_path,
                        'position': content.find(match)
                    })
        
        return concepts
    
    def normalize_concept(self, concept):
        """标准化概念名称"""
        # 移除LaTeX标记
        concept = re.sub(r'\\[a-zA-Z]+', '', concept)
        # 移除数学符号
        concept = re.sub(r'[^\w\s]', '', concept)
        return concept.strip().lower()
    
    def build_concept_graph(self, documents):
        """构建概念图谱"""
        graph = {
            'nodes': [],
            'edges': []
        }
        
        concept_nodes = {}
        
        for doc in documents:
            concepts = self.extract_concepts_from_content(
                doc['content'], doc['file_path'])
            
            for concept_info in concepts:
                concept_id = f"concept_{len(concept_nodes)}"
                concept_nodes[concept_info['concept']] = concept_id
                
                graph['nodes'].append({
                    'id': concept_id,
                    'label': concept_info['concept'],
                    'category': concept_info['category'],
                    'file_path': concept_info['file_path']
                })
        
        # 构建概念间的边
        graph['edges'] = self.build_concept_relationships(graph['nodes'])
        
        return graph
```

#### 1.2 关系识别与构建

```python
# 关系识别器
class RelationshipExtractor:
    def __init__(self):
        self.relationship_patterns = {
            'definition': r'(定义|定义于|定义为)',
            'theorem': r'(定理|引理|推论)',
            'proof': r'(证明|推导|证明过程)',
            'application': r'(应用|应用于|在.*中的应用)',
            'generalization': r'(推广|一般化|扩展)',
            'specialization': r'(特例|特殊情况|具体化)'
        }
    
    def extract_relationships(self, content, concepts):
        """提取概念间的关系"""
        relationships = []
        
        for i, concept1 in enumerate(concepts):
            for j, concept2 in enumerate(concepts[i+1:], i+1):
                relationship = self.find_relationship(
                    content, concept1, concept2)
                if relationship:
                    relationships.append({
                        'source': concept1['concept'],
                        'target': concept2['concept'],
                        'type': relationship['type'],
                        'strength': relationship['strength']
                    })
        
        return relationships
    
    def find_relationship(self, content, concept1, concept2):
        """查找两个概念间的关系"""
        # 查找概念在内容中的位置
        pos1 = content.find(concept1['concept'])
        pos2 = content.find(concept2['concept'])
        
        if pos1 == -1 or pos2 == -1:
            return None
        
        # 分析概念间的文本内容
        start = min(pos1, pos2)
        end = max(pos1, pos2) + max(len(concept1['concept']), len(concept2['concept']))
        context = content[start:end]
        
        # 识别关系类型
        for rel_type, pattern in self.relationship_patterns.items():
            if re.search(pattern, context):
                return {
                    'type': rel_type,
                    'strength': self.calculate_relationship_strength(context)
                }
        
        return None
    
    def calculate_relationship_strength(self, context):
        """计算关系强度"""
        # 基于上下文长度和关键词密度计算强度
        keywords = ['定义', '定理', '证明', '应用', '推广']
        keyword_count = sum(1 for keyword in keywords if keyword in context)
        return min(1.0, keyword_count / len(keywords))
```

### 2. 可视化渲染功能

#### 2.1 力导向图布局

```javascript
// 力导向图布局引擎
class ForceDirectedLayout {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(30));
    }
    
    updateLayout(nodes, links) {
        this.simulation
            .nodes(nodes)
            .on("tick", () => this.ticked(nodes, links));
        
        this.simulation.force("link")
            .links(links)
            .distance(d => this.calculateLinkDistance(d));
    }
    
    calculateLinkDistance(link) {
        // 根据关系类型和强度计算连接距离
        const baseDistance = 100;
        const strengthFactor = 1 - link.strength;
        return baseDistance * strengthFactor;
    }
    
    ticked(nodes, links) {
        // 更新节点位置
        nodes.forEach(node => {
            node.x = Math.max(30, Math.min(this.width - 30, node.x));
            node.y = Math.max(30, Math.min(this.height - 30, node.y));
        });
        
        // 更新连接线位置
        links.forEach(link => {
            link.x1 = link.source.x;
            link.y1 = link.source.y;
            link.x2 = link.target.x;
            link.y2 = link.target.y;
        });
    }
}
```

#### 2.2 节点渲染组件

```javascript
// 节点渲染组件
class NodeRenderer {
    constructor(container) {
        this.container = container;
        this.nodeGroups = container.append("g")
            .attr("class", "nodes");
    }
    
    renderNodes(nodes) {
        const node = this.nodeGroups.selectAll(".node")
            .data(nodes, d => d.id)
            .join("g")
            .attr("class", "node")
            .call(this.dragBehavior());
        
        // 渲染节点圆圈
        node.append("circle")
            .attr("r", d => this.calculateNodeRadius(d))
            .attr("fill", d => this.getNodeColor(d.category))
            .attr("stroke", "#fff")
            .attr("stroke-width", 2);
        
        // 渲染节点标签
        node.append("text")
            .text(d => d.label)
            .attr("text-anchor", "middle")
            .attr("dy", ".35em")
            .attr("font-size", "12px")
            .attr("fill", "#333");
        
        // 添加交互事件
        node.on("click", this.handleNodeClick.bind(this))
            .on("mouseover", this.handleNodeHover.bind(this))
            .on("mouseout", this.handleNodeOut.bind(this));
    }
    
    calculateNodeRadius(node) {
        // 根据节点重要性计算半径
        const baseRadius = 15;
        const importance = node.importance || 1;
        return baseRadius * Math.sqrt(importance);
    }
    
    getNodeColor(category) {
        const colorMap = {
            'algebra': '#ff7f0e',
            'analysis': '#2ca02c',
            'geometry': '#d62728',
            'topology': '#9467bd',
            'logic': '#8c564b',
            'number_theory': '#e377c2'
        };
        return colorMap[category] || '#7f7f7f';
    }
    
    handleNodeClick(event, node) {
        // 处理节点点击事件
        this.onNodeClick(node);
    }
    
    handleNodeHover(event, node) {
        // 处理节点悬停事件
        d3.select(event.currentTarget).select("circle")
            .attr("stroke-width", 4);
    }
    
    handleNodeOut(event, node) {
        // 处理节点离开事件
        d3.select(event.currentTarget).select("circle")
            .attr("stroke-width", 2);
    }
}
```

#### 2.3 连接线渲染组件

```javascript
// 连接线渲染组件
class LinkRenderer {
    constructor(container) {
        this.container = container;
        this.linkGroups = container.append("g")
            .attr("class", "links");
    }
    
    renderLinks(links) {
        const link = this.linkGroups.selectAll(".link")
            .data(links, d => d.source.id + "-" + d.target.id)
            .join("line")
            .attr("class", "link")
            .attr("stroke", d => this.getLinkColor(d.type))
            .attr("stroke-width", d => this.calculateLinkWidth(d.strength))
            .attr("opacity", 0.6);
        
        // 添加连接线标签
        const linkLabels = this.linkGroups.selectAll(".link-label")
            .data(links, d => d.source.id + "-" + d.target.id)
            .join("text")
            .attr("class", "link-label")
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("fill", "#666");
        
        linkLabels.append("textPath")
            .attr("href", d => "#link-" + d.source.id + "-" + d.target.id)
            .text(d => d.type);
    }
    
    getLinkColor(type) {
        const colorMap = {
            'definition': '#1f77b4',
            'theorem': '#ff7f0e',
            'proof': '#2ca02c',
            'application': '#d62728',
            'generalization': '#9467bd',
            'specialization': '#8c564b'
        };
        return colorMap[type] || '#7f7f7f';
    }
    
    calculateLinkWidth(strength) {
        // 根据关系强度计算线宽
        const minWidth = 1;
        const maxWidth = 5;
        return minWidth + (maxWidth - minWidth) * strength;
    }
}
```

### 3. 交互功能设计

#### 3.1 缩放和平移

```javascript
// 缩放和平移控制器
class ZoomPanController {
    constructor(container) {
        this.container = container;
        this.zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", this.handleZoom.bind(this));
        
        this.container.call(this.zoom);
    }
    
    handleZoom(event) {
        const { transform } = event;
        
        this.container.selectAll(".nodes")
            .attr("transform", transform);
        
        this.container.selectAll(".links")
            .attr("transform", transform);
    }
    
    resetZoom() {
        this.container.transition()
            .duration(750)
            .call(this.zoom.transform, d3.zoomIdentity);
    }
    
    fitToView() {
        const bounds = this.container.node().getBBox();
        const fullWidth = this.container.node().clientWidth;
        const fullHeight = this.container.node().clientHeight;
        
        const width = bounds.width;
        const height = bounds.height;
        const midX = bounds.x + width / 2;
        const midY = bounds.y + height / 2;
        
        const scale = 0.9 / Math.max(width / fullWidth, height / fullHeight);
        const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
        
        this.container.transition()
            .duration(750)
            .call(this.zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
    }
}
```

#### 3.2 搜索和过滤

```javascript
// 搜索和过滤控制器
class SearchFilterController {
    constructor(container) {
        this.container = container;
        this.currentFilter = null;
        this.setupSearchInterface();
    }
    
    setupSearchInterface() {
        const searchContainer = d3.select("#search-container");
        
        // 搜索输入框
        const searchInput = searchContainer.append("input")
            .attr("type", "text")
            .attr("placeholder", "搜索概念...")
            .attr("class", "search-input")
            .on("input", this.handleSearch.bind(this));
        
        // 类别过滤器
        const categoryFilter = searchContainer.append("select")
            .attr("class", "category-filter")
            .on("change", this.handleCategoryFilter.bind(this));
        
        categoryFilter.selectAll("option")
            .data(["全部", "代数", "分析", "几何", "拓扑", "逻辑", "数论"])
            .enter()
            .append("option")
            .text(d => d)
            .attr("value", d => d);
    }
    
    handleSearch(event) {
        const searchTerm = event.target.value.toLowerCase();
        this.filterNodes(searchTerm, this.currentFilter);
    }
    
    handleCategoryFilter(event) {
        const category = event.target.value;
        this.currentFilter = category === "全部" ? null : category;
        this.filterNodes(this.currentSearchTerm, this.currentFilter);
    }
    
    filterNodes(searchTerm, category) {
        this.currentSearchTerm = searchTerm;
        
        this.container.selectAll(".node")
            .style("opacity", d => {
                const matchesSearch = !searchTerm || 
                    d.label.toLowerCase().includes(searchTerm);
                const matchesCategory = !category || 
                    d.category === category;
                return matchesSearch && matchesCategory ? 1 : 0.1;
            });
        
        this.container.selectAll(".link")
            .style("opacity", d => {
                const sourceVisible = d.source.opacity !== 0.1;
                const targetVisible = d.target.opacity !== 0.1;
                return sourceVisible && targetVisible ? 0.6 : 0.1;
            });
    }
}
```

### 4. 路径规划功能

#### 4.1 最短路径算法

```javascript
// 路径规划器
class PathPlanner {
    constructor(graph) {
        this.graph = graph;
        this.adjacencyList = this.buildAdjacencyList();
    }
    
    buildAdjacencyList() {
        const adjacencyList = {};
        
        this.graph.nodes.forEach(node => {
            adjacencyList[node.id] = [];
        });
        
        this.graph.links.forEach(link => {
            adjacencyList[link.source.id].push({
                target: link.target.id,
                weight: 1 / link.strength,
                type: link.type
            });
            adjacencyList[link.target.id].push({
                target: link.source.id,
                weight: 1 / link.strength,
                type: link.type
            });
        });
        
        return adjacencyList;
    }
    
    findShortestPath(startId, endId) {
        const distances = {};
        const previous = {};
        const queue = new PriorityQueue();
        
        // 初始化距离
        this.graph.nodes.forEach(node => {
            distances[node.id] = Infinity;
        });
        distances[startId] = 0;
        
        queue.enqueue(startId, 0);
        
        while (!queue.isEmpty()) {
            const currentId = queue.dequeue().element;
            
            if (currentId === endId) {
                break;
            }
            
            const neighbors = this.adjacencyList[currentId] || [];
            neighbors.forEach(neighbor => {
                const distance = distances[currentId] + neighbor.weight;
                
                if (distance < distances[neighbor.target]) {
                    distances[neighbor.target] = distance;
                    previous[neighbor.target] = {
                        node: currentId,
                        type: neighbor.type
                    };
                    queue.enqueue(neighbor.target, distance);
                }
            });
        }
        
        return this.reconstructPath(previous, startId, endId);
    }
    
    reconstructPath(previous, startId, endId) {
        const path = [];
        let currentId = endId;
        
        while (currentId !== startId) {
            const prev = previous[currentId];
            if (!prev) {
                return null; // 路径不存在
            }
            
            path.unshift({
                from: prev.node,
                to: currentId,
                type: prev.type
            });
            
            currentId = prev.node;
        }
        
        return path;
    }
    
    highlightPath(path) {
        // 高亮显示路径
        this.container.selectAll(".link")
            .style("stroke", d => {
                const isInPath = path.some(link => 
                    (link.from === d.source.id && link.to === d.target.id) ||
                    (link.from === d.target.id && link.to === d.source.id)
                );
                return isInPath ? "#ff0000" : this.getLinkColor(d.type);
            })
            .style("stroke-width", d => {
                const isInPath = path.some(link => 
                    (link.from === d.source.id && link.to === d.target.id) ||
                    (link.from === d.target.id && link.to === d.source.id)
                );
                return isInPath ? 4 : this.calculateLinkWidth(d.strength);
            });
    }
}
```

---

## 🏗️ 技术架构

### 1. 前端架构

```text
知识图谱前端/
├── components/              # React组件
│   ├── GraphViewer/        # 图谱查看器
│   ├── NodeRenderer/       # 节点渲染器
│   ├── LinkRenderer/       # 连接线渲染器
│   ├── SearchFilter/       # 搜索过滤器
│   └── PathPlanner/        # 路径规划器
├── services/               # 服务层
│   ├── graphService.js     # 图谱服务
│   ├── searchService.js    # 搜索服务
│   └── pathService.js      # 路径服务
├── utils/                  # 工具函数
│   ├── d3Utils.js          # D3工具
│   ├── graphUtils.js       # 图谱工具
│   └── layoutUtils.js      # 布局工具
└── styles/                 # 样式文件
    ├── graph.css           # 图谱样式
    ├── nodes.css           # 节点样式
    └── links.css           # 连接线样式
```

### 2. 后端架构

```text
知识图谱后端/
├── api/                    # API接口
│   ├── graph_api.py        # 图谱API
│   ├── search_api.py       # 搜索API
│   └── path_api.py         # 路径API
├── services/               # 业务逻辑
│   ├── graph_service.py    # 图谱服务
│   ├── concept_service.py  # 概念服务
│   └── relationship_service.py # 关系服务
├── models/                 # 数据模型
│   ├── concept_model.py    # 概念模型
│   ├── relationship_model.py # 关系模型
│   └── graph_model.py      # 图谱模型
└── database/               # 数据库
    ├── neo4j_client.py     # Neo4j客户端
    ├── graph_queries.py    # 图谱查询
    └── data_loader.py      # 数据加载器
```

### 3. 数据库设计

```cypher
// Neo4j图数据库模式
// 概念节点
CREATE (c:Concept {
    id: string,
    name: string,
    category: string,
    description: string,
    importance: float,
    file_path: string
})

// 关系边
CREATE (c1:Concept)-[r:RELATES_TO {
    type: string,
    strength: float,
    description: string
}]->(c2:Concept)

// 索引
CREATE INDEX ON :Concept(name)
CREATE INDEX ON :Concept(category)
CREATE INDEX ON :RELATES_TO(type)
```

---

## 📊 性能优化

### 1. 渲染优化

```javascript
// 虚拟化渲染
class VirtualizedRenderer {
    constructor(container, viewport) {
        this.container = container;
        this.viewport = viewport;
        this.visibleNodes = new Set();
    }
    
    updateVisibleNodes(transform) {
        const visible = [];
        
        this.graph.nodes.forEach(node => {
            const screenX = transform.applyX(node.x);
            const screenY = transform.applyY(node.y);
            
            if (this.isInViewport(screenX, screenY)) {
                visible.push(node);
                this.visibleNodes.add(node.id);
            } else {
                this.visibleNodes.delete(node.id);
            }
        });
        
        this.renderVisibleNodes(visible);
    }
    
    isInViewport(x, y) {
        return x >= -50 && x <= this.viewport.width + 50 &&
               y >= -50 && y <= this.viewport.height + 50;
    }
}
```

### 2. 数据优化

```python
# 图数据压缩
class GraphCompressor:
    def __init__(self):
        self.compression_ratio = 0.8
    
    def compress_graph(self, graph):
        """压缩图谱数据"""
        # 移除低重要性节点
        important_nodes = [node for node in graph['nodes'] 
                          if node.get('importance', 0) > 0.3]
        
        # 保留重要连接
        important_edges = [edge for edge in graph['edges'] 
                          if edge.get('strength', 0) > 0.5]
        
        return {
            'nodes': important_nodes,
            'edges': important_edges
        }
    
    def hierarchical_clustering(self, graph):
        """层次聚类压缩"""
        # 实现层次聚类算法
        pass
```

---

## 🚀 部署方案

### 1. 容器化部署

```dockerfile
# 前端Dockerfile
FROM node:16-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

EXPOSE 3000

CMD ["npm", "start"]
```

```dockerfile
# 后端Dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 2. 微服务架构

```yaml
# docker-compose.yml
version: '3.8'
services:
  graph-frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - graph-backend
  
  graph-backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - NEO4J_URI=bolt://neo4j:7687
    depends_on:
      - neo4j
  
  neo4j:
    image: neo4j:4.4
    ports:
      - "7474:7474"
      - "7687:7687"
    environment:
      - NEO4J_AUTH=neo4j/password
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs

volumes:
  neo4j_data:
  neo4j_logs:
```

---

## 📈 监控与分析

### 1. 性能监控

- **渲染性能**: 监控图谱渲染帧率
- **交互响应**: 监控用户交互响应时间
- **内存使用**: 监控内存消耗情况
- **网络延迟**: 监控API请求延迟

### 2. 用户行为分析

- **搜索模式**: 分析用户搜索行为
- **路径探索**: 跟踪用户路径探索模式
- **节点点击**: 统计节点点击频率
- **停留时间**: 分析用户停留时间

---

## 🎯 后续发展

### 1. 功能扩展

- **3D可视化**: 支持3D图谱展示
- **动画效果**: 添加动态过渡效果
- **多视图**: 支持多种视图模式
- **协作功能**: 支持多人协作编辑

### 2. 智能化提升

- **自动布局**: 智能优化图谱布局
- **推荐路径**: 智能推荐学习路径
- **异常检测**: 自动检测异常关系
- **预测分析**: 预测概念发展趋势

---

*本文档为知识图谱可视化系统的详细设计，为Refactor项目的智能化导航系统提供可视化支撑。*
