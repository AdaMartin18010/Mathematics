# 01-自动化检测引擎

## 📊 引擎概述

- **引擎名称**: Refactor自动化检测引擎
- **核心功能**: 自动检测和验证文档质量
- **技术栈**: Python + 正则表达式 + 机器学习
- **检测覆盖率目标**: 100%

---

## 🎯 核心功能设计

### 1. 引用链接检测功能

#### 1.1 链接有效性检测

```python
# 链接检测器
class LinkDetector:
    def __init__(self):
        self.session = requests.Session()
        self.timeout = 10
        self.max_retries = 3
    
    def check_link_validity(self, url):
        """检测链接有效性"""
        try:
            response = self.session.head(url, timeout=self.timeout)
            return {
                'url': url,
                'status': response.status_code,
                'valid': 200 <= response.status_code < 400,
                'response_time': response.elapsed.total_seconds()
            }
        except Exception as e:
            return {
                'url': url,
                'status': None,
                'valid': False,
                'error': str(e)
            }
    
    def batch_check_links(self, urls, max_workers=10):
        """批量检测链接"""
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            results = list(executor.map(self.check_link_validity, urls))
        return results
    
    def extract_links_from_markdown(self, content):
        """从Markdown内容中提取链接"""
        link_pattern = r'\[([^\]]+)\]\(([^)]+)\)'
        links = re.findall(link_pattern, content)
        return [url for _, url in links]
```

#### 1.2 内部引用检测

```python
# 内部引用检测器
class InternalReferenceDetector:
    def __init__(self, base_path):
        self.base_path = base_path
        self.file_index = self.build_file_index()
    
    def build_file_index(self):
        """构建文件索引"""
        file_index = {}
        for root, dirs, files in os.walk(self.base_path):
            for file in files:
                if file.endswith('.md'):
                    file_path = os.path.join(root, file)
                    relative_path = os.path.relpath(file_path, self.base_path)
                    file_index[relative_path] = file_path
        return file_index
    
    def check_internal_references(self, content, current_file):
        """检测内部引用"""
        issues = []
        
        # 检测相对路径引用
        relative_pattern = r'\[([^\]]+)\]\(([^)]+\.md)\)'
        matches = re.findall(relative_pattern, content)
        
        for text, ref_path in matches:
            if not self.is_valid_internal_reference(ref_path, current_file):
                issues.append({
                    'type': 'invalid_internal_reference',
                    'text': text,
                    'reference': ref_path,
                    'current_file': current_file
                })
        
        return issues
    
    def is_valid_internal_reference(self, ref_path, current_file):
        """验证内部引用是否有效"""
        # 解析相对路径
        current_dir = os.path.dirname(current_file)
        absolute_ref_path = os.path.normpath(os.path.join(current_dir, ref_path))
        
        # 检查文件是否存在
        return absolute_ref_path in self.file_index.values()
```

### 2. 命名规范检查功能

#### 2.1 文件命名规范检查

```python
# 文件命名检测器
class FileNamingDetector:
    def __init__(self):
        self.naming_patterns = {
            'directory': r'^\d{2}-[A-Za-z0-9_-]+$',
            'file': r'^\d{2}-[A-Za-z0-9_-]+\.md$',
            'backup': r'^\d{2}-[A-Za-z0-9_-]+-备份$'
        }
    
    def check_file_naming(self, file_path):
        """检查文件命名规范"""
        filename = os.path.basename(file_path)
        directory = os.path.dirname(file_path)
        
        issues = []
        
        # 检查目录命名
        if os.path.isdir(file_path):
            if not re.match(self.naming_patterns['directory'], filename):
                issues.append({
                    'type': 'invalid_directory_naming',
                    'file': file_path,
                    'expected_pattern': self.naming_patterns['directory']
                })
        
        # 检查文件命名
        elif filename.endswith('.md'):
            if not re.match(self.naming_patterns['file'], filename):
                issues.append({
                    'type': 'invalid_file_naming',
                    'file': file_path,
                    'expected_pattern': self.naming_patterns['file']
                })
        
        return issues
    
    def suggest_correction(self, filename, file_type='file'):
        """建议命名修正"""
        # 移除特殊字符
        clean_name = re.sub(r'[^\w\s-]', '', filename)
        clean_name = re.sub(r'\s+', '-', clean_name)
        
        # 添加编号前缀
        if not re.match(r'^\d{2}-', clean_name):
            clean_name = f"01-{clean_name}"
        
        # 添加文件扩展名
        if file_type == 'file' and not clean_name.endswith('.md'):
            clean_name += '.md'
        
        return clean_name
```

#### 2.2 内容标题规范检查

```python
# 标题规范检测器
class TitleFormatDetector:
    def __init__(self):
        self.title_patterns = {
            'main_title': r'^#\s+[A-Za-z0-9\s\-_]+$',
            'sub_title': r'^#{2,6}\s+[A-Za-z0-9\s\-_]+$'
        }
    
    def check_title_format(self, content):
        """检查标题格式规范"""
        issues = []
        lines = content.split('\n')
        
        for line_num, line in enumerate(lines, 1):
            if line.strip().startswith('#'):
                if not self.is_valid_title_format(line):
                    issues.append({
                        'type': 'invalid_title_format',
                        'line': line_num,
                        'content': line.strip(),
                        'suggestion': self.suggest_title_correction(line)
                    })
        
        return issues
    
    def is_valid_title_format(self, title_line):
        """验证标题格式"""
        title_line = title_line.strip()
        
        # 检查主标题格式
        if title_line.startswith('# '):
            return bool(re.match(self.title_patterns['main_title'], title_line))
        
        # 检查子标题格式
        elif title_line.startswith('##'):
            return bool(re.match(self.title_patterns['sub_title'], title_line))
        
        return False
    
    def suggest_title_correction(self, title_line):
        """建议标题修正"""
        # 移除多余的空格
        corrected = re.sub(r'#+\s+', '# ', title_line)
        
        # 确保标题格式正确
        if not corrected.startswith('# '):
            corrected = '# ' + corrected.lstrip('#').lstrip()
        
        return corrected
```

### 3. 内容完整性验证功能

#### 3.1 文档结构完整性检查

```python
# 文档结构检测器
class DocumentStructureDetector:
    def __init__(self):
        self.required_sections = [
            '概述', '总览', 'Introduction', 'Overview'
        ]
        self.min_content_length = 100
    
    def check_document_structure(self, content, file_path):
        """检查文档结构完整性"""
        issues = []
        
        # 检查内容长度
        if len(content.strip()) < self.min_content_length:
            issues.append({
                'type': 'insufficient_content',
                'file': file_path,
                'current_length': len(content.strip()),
                'min_required': self.min_content_length
            })
        
        # 检查标题层级
        title_hierarchy = self.analyze_title_hierarchy(content)
        if not self.is_valid_hierarchy(title_hierarchy):
            issues.append({
                'type': 'invalid_title_hierarchy',
                'file': file_path,
                'hierarchy': title_hierarchy
            })
        
        # 检查必要章节
        missing_sections = self.check_required_sections(content)
        if missing_sections:
            issues.append({
                'type': 'missing_required_sections',
                'file': file_path,
                'missing_sections': missing_sections
            })
        
        return issues
    
    def analyze_title_hierarchy(self, content):
        """分析标题层级"""
        hierarchy = []
        lines = content.split('\n')
        
        for line in lines:
            if line.strip().startswith('#'):
                level = len(line) - len(line.lstrip('#'))
                title = line.strip('#').strip()
                hierarchy.append({'level': level, 'title': title})
        
        return hierarchy
    
    def is_valid_hierarchy(self, hierarchy):
        """验证标题层级是否合理"""
        if not hierarchy:
            return False
        
        # 检查层级跳跃
        for i in range(1, len(hierarchy)):
            if hierarchy[i]['level'] - hierarchy[i-1]['level'] > 1:
                return False
        
        return True
    
    def check_required_sections(self, content):
        """检查必要章节"""
        missing = []
        content_lower = content.lower()
        
        for section in self.required_sections:
            if section.lower() not in content_lower:
                missing.append(section)
        
        return missing
```

#### 3.2 数学公式格式检查

```python
# 数学公式检测器
class MathFormulaDetector:
    def __init__(self):
        self.latex_patterns = {
            'inline': r'\$([^$]+)\$',
            'block': r'\$\$([^$]+)\$\$',
            'equation': r'\\begin\{equation\}(.*?)\\end\{equation\}',
            'align': r'\\begin\{align\}(.*?)\\end\{align\}'
        }
    
    def check_math_formulas(self, content):
        """检查数学公式格式"""
        issues = []
        
        # 检查行内公式
        inline_issues = self.check_inline_formulas(content)
        issues.extend(inline_issues)
        
        # 检查块级公式
        block_issues = self.check_block_formulas(content)
        issues.extend(block_issues)
        
        # 检查LaTeX语法
        latex_issues = self.check_latex_syntax(content)
        issues.extend(latex_issues)
        
        return issues
    
    def check_inline_formulas(self, content):
        """检查行内公式"""
        issues = []
        matches = re.finditer(self.latex_patterns['inline'], content)
        
        for match in matches:
            formula = match.group(1)
            if not self.is_valid_latex_formula(formula):
                issues.append({
                    'type': 'invalid_inline_formula',
                    'formula': formula,
                    'position': match.start()
                })
        
        return issues
    
    def check_block_formulas(self, content):
        """检查块级公式"""
        issues = []
        matches = re.finditer(self.latex_patterns['block'], content, re.DOTALL)
        
        for match in matches:
            formula = match.group(1)
            if not self.is_valid_latex_formula(formula):
                issues.append({
                    'type': 'invalid_block_formula',
                    'formula': formula,
                    'position': match.start()
                })
        
        return issues
    
    def is_valid_latex_formula(self, formula):
        """验证LaTeX公式语法"""
        # 检查基本语法
        if not formula.strip():
            return False
        
        # 检查括号匹配
        if not self.check_bracket_balance(formula):
            return False
        
        # 检查常见错误
        common_errors = [
            r'\\[a-zA-Z]+',  # 检查反斜杠命令
            r'\{[^}]*\}',    # 检查花括号
            r'\[[^\]]*\]',   # 检查方括号
        ]
        
        for pattern in common_errors:
            if re.search(pattern, formula):
                # 进一步验证语法
                pass
        
        return True
    
    def check_bracket_balance(self, formula):
        """检查括号平衡"""
        stack = []
        brackets = {'(': ')', '{': '}', '[': ']'}
        
        for char in formula:
            if char in brackets:
                stack.append(char)
            elif char in brackets.values():
                if not stack:
                    return False
                if brackets[stack.pop()] != char:
                    return False
        
        return len(stack) == 0
```

### 4. 格式规范检查功能

#### 4.1 Markdown格式检查

```python
# Markdown格式检测器
class MarkdownFormatDetector:
    def __init__(self):
        self.format_rules = {
            'line_length': 120,
            'list_indentation': 2,
            'code_block_language': True
        }
    
    def check_markdown_format(self, content):
        """检查Markdown格式规范"""
        issues = []
        
        # 检查行长度
        line_length_issues = self.check_line_length(content)
        issues.extend(line_length_issues)
        
        # 检查列表格式
        list_format_issues = self.check_list_format(content)
        issues.extend(list_format_issues)
        
        # 检查代码块格式
        code_block_issues = self.check_code_block_format(content)
        issues.extend(code_block_issues)
        
        # 检查链接格式
        link_format_issues = self.check_link_format(content)
        issues.extend(link_format_issues)
        
        return issues
    
    def check_line_length(self, content):
        """检查行长度"""
        issues = []
        lines = content.split('\n')
        
        for line_num, line in enumerate(lines, 1):
            if len(line) > self.format_rules['line_length']:
                issues.append({
                    'type': 'line_too_long',
                    'line': line_num,
                    'length': len(line),
                    'max_length': self.format_rules['line_length']
                })
        
        return issues
    
    def check_list_format(self, content):
        """检查列表格式"""
        issues = []
        lines = content.split('\n')
        
        for line_num, line in enumerate(lines, 1):
            if line.strip().startswith(('-', '*', '+')):
                # 检查缩进
                indent = len(line) - len(line.lstrip())
                if indent % self.format_rules['list_indentation'] != 0:
                    issues.append({
                        'type': 'invalid_list_indentation',
                        'line': line_num,
                        'indent': indent,
                        'expected': self.format_rules['list_indentation']
                    })
        
        return issues
    
    def check_code_block_format(self, content):
        """检查代码块格式"""
        issues = []
        
        # 检查代码块语言标识
        code_block_pattern = r'```(\w+)?\n(.*?)```'
        matches = re.finditer(code_block_pattern, content, re.DOTALL)
        
        for match in matches:
            language = match.group(1)
            if not language and self.format_rules['code_block_language']:
                issues.append({
                    'type': 'missing_code_language',
                    'position': match.start(),
                    'suggestion': 'Add language identifier'
                })
        
        return issues
```

---

## 🏗️ 技术架构

### 1. 检测引擎架构

```text
自动化检测引擎/
├── detectors/              # 检测器模块
│   ├── link_detector.py    # 链接检测器
│   ├── naming_detector.py  # 命名检测器
│   ├── structure_detector.py # 结构检测器
│   ├── formula_detector.py # 公式检测器
│   └── format_detector.py  # 格式检测器
├── validators/             # 验证器模块
│   ├── link_validator.py   # 链接验证器
│   ├── content_validator.py # 内容验证器
│   └── format_validator.py # 格式验证器
├── analyzers/              # 分析器模块
│   ├── quality_analyzer.py # 质量分析器
│   ├── trend_analyzer.py   # 趋势分析器
│   └── report_analyzer.py  # 报告分析器
├── utils/                  # 工具函数
│   ├── file_utils.py       # 文件工具
│   ├── text_utils.py       # 文本工具
│   └── math_utils.py       # 数学工具
└── config/                 # 配置文件
    ├── detection_rules.py  # 检测规则
    ├── quality_standards.py # 质量标准
    └── thresholds.py       # 阈值配置
```

### 2. 检测流程

```text
文件扫描 → 内容解析 → 多检测器并行检测 → 结果聚合 → 问题分类 → 生成报告
    ↓
规则匹配 → 语法验证 → 格式检查 → 完整性验证 → 质量评分
```

### 3. 性能优化

#### 3.1 并行检测

```python
# 并行检测管理器
class ParallelDetectionManager:
    def __init__(self, max_workers=4):
        self.max_workers = max_workers
        self.detectors = self.load_detectors()
    
    def run_parallel_detection(self, files):
        """并行运行检测"""
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = []
            for file_path in files:
                future = executor.submit(self.detect_single_file, file_path)
                futures.append(future)
            
            results = []
            for future in as_completed(futures):
                results.extend(future.result())
        
        return results
    
    def detect_single_file(self, file_path):
        """检测单个文件"""
        issues = []
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        for detector in self.detectors:
            detector_issues = detector.detect(content, file_path)
            issues.extend(detector_issues)
        
        return issues
```

#### 3.2 缓存机制

```python
# 检测结果缓存
class DetectionCache:
    def __init__(self, cache_dir='.detection_cache'):
        self.cache_dir = cache_dir
        os.makedirs(cache_dir, exist_ok=True)
    
    def get_cache_key(self, file_path, detector_type):
        """生成缓存键"""
        file_hash = hashlib.md5(open(file_path, 'rb').read()).hexdigest()
        return f"{detector_type}_{file_hash}"
    
    def get_cached_result(self, cache_key):
        """获取缓存结果"""
        cache_file = os.path.join(self.cache_dir, f"{cache_key}.json")
        if os.path.exists(cache_file):
            with open(cache_file, 'r') as f:
                return json.load(f)
        return None
    
    def cache_result(self, cache_key, result):
        """缓存检测结果"""
        cache_file = os.path.join(self.cache_dir, f"{cache_key}.json")
        with open(cache_file, 'w') as f:
            json.dump(result, f)
```

---

## 📊 质量指标

### 1. 检测性能

- **检测速度**: < 1秒/文件
- **检测准确率**: > 95%
- **误报率**: < 5%
- **覆盖率**: 100%

### 2. 问题分类

- **严重问题**: 影响文档可读性的问题
- **一般问题**: 格式不规范但不影响理解的问题
- **建议问题**: 可选的改进建议

### 3. 质量评分

```python
# 质量评分计算器
class QualityScoreCalculator:
    def __init__(self):
        self.weights = {
            'critical': 0.5,
            'normal': 0.3,
            'suggestion': 0.2
        }
    
    def calculate_score(self, issues):
        """计算质量评分"""
        if not issues:
            return 100.0
        
        total_penalty = 0
        for issue in issues:
            penalty = self.get_issue_penalty(issue['type'])
            total_penalty += penalty
        
        score = max(0, 100 - total_penalty)
        return round(score, 2)
    
    def get_issue_penalty(self, issue_type):
        """获取问题扣分"""
        penalties = {
            'invalid_internal_reference': 10,
            'invalid_file_naming': 5,
            'insufficient_content': 15,
            'invalid_title_format': 3,
            'invalid_inline_formula': 8,
            'line_too_long': 1
        }
        return penalties.get(issue_type, 2)
```

---

## 🚀 部署方案

### 1. 命令行工具

```python
# 命令行接口
import argparse

def main():
    parser = argparse.ArgumentParser(description='Refactor质量检测工具')
    parser.add_argument('path', help='检测路径')
    parser.add_argument('--output', '-o', help='输出文件')
    parser.add_argument('--format', '-f', choices=['json', 'html', 'text'], 
                       default='json', help='输出格式')
    parser.add_argument('--parallel', '-p', type=int, default=4, 
                       help='并行检测数量')
    
    args = parser.parse_args()
    
    # 运行检测
    detector = QualityDetector()
    results = detector.detect_directory(args.path, max_workers=args.parallel)
    
    # 输出结果
    if args.output:
        detector.export_results(results, args.output, args.format)
    else:
        detector.print_results(results)

if __name__ == '__main__':
    main()
```

### 2. 集成到CI/CD

```yaml
# GitHub Actions配置
name: Quality Check
on: [push, pull_request]

jobs:
  quality-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.9
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
      
      - name: Run quality detection
        run: |
          python -m quality_detector Math/Refactor --output quality_report.json
      
      - name: Upload quality report
        uses: actions/upload-artifact@v2
        with:
          name: quality-report
          path: quality_report.json
```

---

## 📈 监控与优化

### 1. 性能监控

- **检测时间监控**: 跟踪检测耗时
- **内存使用监控**: 监控内存消耗
- **CPU使用监控**: 监控CPU使用率
- **错误率监控**: 跟踪检测错误率

### 2. 持续优化

- **规则优化**: 根据检测结果优化检测规则
- **算法优化**: 优化检测算法性能
- **缓存优化**: 优化缓存策略
- **并行优化**: 优化并行检测策略

---

## 🎯 后续发展

### 1. 功能扩展

- **机器学习检测**: 引入机器学习模型进行智能检测
- **语义分析**: 基于语义分析检测内容质量
- **多语言支持**: 支持多种语言的检测
- **实时检测**: 支持实时文件变化检测

### 2. 智能化提升

- **自适应规则**: 根据项目特点自适应调整检测规则
- **智能修复**: 提供自动修复建议
- **预测分析**: 预测潜在的质量问题
- **学习优化**: 从用户反馈中学习优化检测策略

---

*本文档为自动化检测引擎的详细设计，为Refactor项目的质量监控系统提供核心技术支撑。*
