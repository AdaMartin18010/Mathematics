# æ•°å­¦æ ¼å¼ä¿®å¤å·¥å…·

## ğŸ“‹ å·¥å…·æ¦‚è¿°

**å·¥å…·å¯¹è±¡**: Math/Refactoré¡¹ç›®æ•°å­¦æ ¼å¼ä¿®å¤  
**å·¥å…·æ—¶é—´**: 2025å¹´1æœˆ  
**å·¥å…·ç›®æ ‡**: è‡ªåŠ¨ä¿®å¤æ•°å­¦æ ¼å¼é”™è¯¯ï¼Œæé«˜æ–‡æ¡£è´¨é‡  
**å·¥å…·æ–¹æ³•**: è‡ªåŠ¨åŒ–æ£€æŸ¥ã€æ‰¹é‡ä¿®å¤ã€è´¨é‡éªŒè¯  

---

## ğŸ› ï¸ è‡ªåŠ¨åŒ–ä¿®å¤å·¥å…·

### 1. è¯­æ³•ä¿®å¤å·¥å…·

#### 1.1 æ‹¬å·åŒ¹é…ä¿®å¤

```python
import re

def fix_bracket_mismatch(text):
    """ä¿®å¤æ‹¬å·ä¸åŒ¹é…é—®é¢˜"""
    # æŸ¥æ‰¾æ‰€æœ‰æ•°å­¦å…¬å¼
    inline_pattern = r'\$[^$]+\$'
    block_pattern = r'\$\$[^$]+\$\$'
    
    def fix_formula(match):
        formula = match.group(0)
        # è®¡ç®—æ‹¬å·æ•°é‡
        open_brackets = formula.count('(')
        close_brackets = formula.count(')')
        
        if open_brackets > close_brackets:
            # æ·»åŠ ç¼ºå¤±çš„å³æ‹¬å·
            formula = formula + ')' * (open_brackets - close_brackets)
        elif close_brackets > open_brackets:
            # æ·»åŠ ç¼ºå¤±çš„å·¦æ‹¬å·
            formula = '(' * (close_brackets - open_brackets) + formula
        
        return formula
    
    # ä¿®å¤è¡Œå†…å…¬å¼
    text = re.sub(inline_pattern, fix_formula, text)
    # ä¿®å¤å—çº§å…¬å¼
    text = re.sub(block_pattern, fix_formula, text)
    
    return text
```

#### 1.2 ç©ºæ ¼ä¿®å¤

```python
def fix_spacing(text):
    """ä¿®å¤æ•°å­¦å…¬å¼ä¸­çš„ç©ºæ ¼é—®é¢˜"""
    # åœ¨è¿ç®—ç¬¦å‰åæ·»åŠ ç©ºæ ¼
    operators = ['+', '-', '=', '\\neq', '\\leq', '\\geq', '\\approx', '\\equiv']
    
    for op in operators:
        # æŸ¥æ‰¾æ²¡æœ‰é€‚å½“ç©ºæ ¼çš„è¿ç®—ç¬¦
        pattern = rf'([^\\s])({re.escape(op)})([^\\s])'
        replacement = r'\1 \2 \3'
        text = re.sub(pattern, replacement, text)
    
    return text
```

#### 1.3 è½¬ä¹‰å­—ç¬¦ä¿®å¤

```python
def fix_escape_characters(text):
    """ä¿®å¤è½¬ä¹‰å­—ç¬¦é—®é¢˜"""
    # éœ€è¦è½¬ä¹‰çš„å­—ç¬¦
    escape_chars = ['{', '}', '[', ']', '^', '_', '\\', '&', '%', '$', '#']
    
    for char in escape_chars:
        # æŸ¥æ‰¾æœªè½¬ä¹‰çš„ç‰¹æ®Šå­—ç¬¦
        pattern = rf'(?<!\\){re.escape(char)}'
        replacement = f'\\{char}'
        text = re.sub(pattern, replacement, text)
    
    return text
```

### 2. ç¬¦å·ä¿®å¤å·¥å…·

#### 2.1 å¸Œè…Šå­—æ¯ä¿®å¤

```python
def fix_greek_letters(text):
    """ä¿®å¤å¸Œè…Šå­—æ¯ä½¿ç”¨"""
    # å¸¸è§é”™è¯¯æ˜ å°„
    greek_fixes = {
        'Î±': '\\alpha',
        'Î²': '\\beta',
        'Î³': '\\gamma',
        'Î´': '\\delta',
        'Îµ': '\\varepsilon',
        'Î¶': '\\zeta',
        'Î·': '\\eta',
        'Î¸': '\\theta',
        'Î¹': '\\iota',
        'Îº': '\\kappa',
        'Î»': '\\lambda',
        'Î¼': '\\mu',
        'Î½': '\\nu',
        'Î¾': '\\xi',
        'Î¿': '\\omicron',
        'Ï€': '\\pi',
        'Ï': '\\rho',
        'Ïƒ': '\\sigma',
        'Ï„': '\\tau',
        'Ï…': '\\upsilon',
        'Ï†': '\\phi',
        'Ï‡': '\\chi',
        'Ïˆ': '\\psi',
        'Ï‰': '\\omega'
    }
    
    for unicode_char, latex_cmd in greek_fixes.items():
        text = text.replace(unicode_char, f'${latex_cmd}$')
    
    return text
```

#### 2.2 æ•°å­¦ç¬¦å·ä¿®å¤

```python
def fix_math_symbols(text):
    """ä¿®å¤æ•°å­¦ç¬¦å·ä½¿ç”¨"""
    # å¸¸è§é”™è¯¯æ˜ å°„
    symbol_fixes = {
        'âˆˆ': '\\in',
        'âˆ‰': '\\notin',
        'âŠ‚': '\\subset',
        'âŠ†': '\\subseteq',
        'âŠƒ': '\\supset',
        'âŠ‡': '\\supseteq',
        'âˆª': '\\cup',
        'âˆ©': '\\cap',
        'âˆ…': '\\emptyset',
        'âˆ': '\\infty',
        'Â±': '\\pm',
        'âˆ“': '\\mp',
        'Ã—': '\\times',
        'Ã·': '\\div',
        'Â·': '\\cdot',
        'â‰¤': '\\leq',
        'â‰¥': '\\geq',
        'â‰ ': '\\neq',
        'â‰ˆ': '\\approx',
        'â‰¡': '\\equiv',
        'â†’': '\\rightarrow',
        'â†': '\\leftarrow',
        'â†”': '\\leftrightarrow',
        'â‡’': '\\Rightarrow',
        'â‡': '\\Leftarrow',
        'â‡”': '\\Leftrightarrow',
        'âˆ€': '\\forall',
        'âˆƒ': '\\exists',
        'âˆ„': '\\nexists',
        'âˆ§': '\\land',
        'âˆ¨': '\\lor',
        'Â¬': '\\neg',
        'âˆ´': '\\therefore',
        'âˆµ': '\\because'
    }
    
    for unicode_char, latex_cmd in symbol_fixes.items():
        text = text.replace(unicode_char, f'${latex_cmd}$')
    
    return text
```

### 3. æ ¼å¼ä¿®å¤å·¥å…·

#### 3.1 è¡Œå†…å…¬å¼ä¿®å¤

```python
def fix_inline_formulas(text):
    """ä¿®å¤è¡Œå†…å…¬å¼æ ¼å¼"""
    # æŸ¥æ‰¾é”™è¯¯çš„å—çº§å…¬å¼åœ¨è¡Œå†…ä½¿ç”¨
    pattern = r'([^$])\$\$([^$]+)\$\$([^$])'
    
    def fix_inline(match):
        before = match.group(1)
        formula = match.group(2)
        after = match.group(3)
        return f'{before}${formula}${after}'
    
    text = re.sub(pattern, fix_inline, text)
    return text
```

#### 3.2 å—çº§å…¬å¼ä¿®å¤

```python
def fix_block_formulas(text):
    """ä¿®å¤å—çº§å…¬å¼æ ¼å¼"""
    # æŸ¥æ‰¾é•¿è¡Œå†…å…¬å¼ï¼Œåº”è¯¥æ”¹ä¸ºå—çº§
    inline_pattern = r'\$([^$]{50,})\$'
    
    def fix_block(match):
        formula = match.group(1)
        return f'\n$$\n{formula}\n$$\n'
    
    text = re.sub(inline_pattern, fix_block, text)
    return text
```

#### 3.3 å¯¹é½ä¿®å¤

```python
def fix_alignment(text):
    """ä¿®å¤å¯¹é½é—®é¢˜"""
    # ä¿®å¤alignç¯å¢ƒä¸­çš„å¯¹é½
    pattern = r'\\begin\{align\}(.*?)\\end\{align\}'
    
    def fix_align(match):
        content = match.group(1)
        # ç¡®ä¿æ¯è¡Œéƒ½æœ‰&ç¬¦å·
        lines = content.strip().split('\n')
        fixed_lines = []
        for line in lines:
            line = line.strip()
            if line and '&' not in line and '=' in line:
                # åœ¨ç­‰å·å‰æ·»åŠ &
                line = line.replace('=', '&=', 1)
            fixed_lines.append(line)
        return '\\begin{align}\n' + '\n'.join(fixed_lines) + '\n\\end{align}'
    
    text = re.sub(pattern, fix_align, text, flags=re.DOTALL)
    return text
```

---

## ğŸ” æ£€æŸ¥å·¥å…·

### 1. è¯­æ³•æ£€æŸ¥å·¥å…·

#### 1.1 å®Œæ•´è¯­æ³•æ£€æŸ¥

```python
def check_math_syntax(text):
    """æ£€æŸ¥æ•°å­¦å…¬å¼è¯­æ³•"""
    errors = []
    
    # æ£€æŸ¥è¡Œå†…å…¬å¼
    inline_pattern = r'\$[^$]+\$'
    inline_matches = re.findall(inline_pattern, text)
    
    for match in inline_matches:
        # æ£€æŸ¥æ‹¬å·åŒ¹é…
        if match.count('(') != match.count(')'):
            errors.append(f"æ‹¬å·ä¸åŒ¹é…: {match}")
        
        # æ£€æŸ¥åæ–œæ è½¬ä¹‰
        if '\\' in match and not re.search(r'\\[a-zA-Z]', match):
            errors.append(f"åæ–œæ è½¬ä¹‰é”™è¯¯: {match}")
        
        # æ£€æŸ¥æ˜¯å¦åº”è¯¥æ˜¯å—çº§å…¬å¼
        if len(match) > 50:
            errors.append(f"é•¿å…¬å¼åº”ä½¿ç”¨å—çº§æ ¼å¼: {match}")
    
    # æ£€æŸ¥å—çº§å…¬å¼
    block_pattern = r'\$\$[^$]+\$\$'
    block_matches = re.findall(block_pattern, text)
    
    for match in block_matches:
        # æ£€æŸ¥æ¢è¡Œ
        if '\n' in match:
            errors.append(f"å—çº§å…¬å¼åŒ…å«æ¢è¡Œ: {match}")
        
        # æ£€æŸ¥æ˜¯å¦åº”è¯¥æ˜¯è¡Œå†…å…¬å¼
        if len(match) < 20:
            errors.append(f"çŸ­å…¬å¼åº”ä½¿ç”¨è¡Œå†…æ ¼å¼: {match}")
    
    return errors
```

#### 1.2 ç¬¦å·æ£€æŸ¥

```python
def check_math_symbols(text):
    """æ£€æŸ¥æ•°å­¦ç¬¦å·ä½¿ç”¨"""
    errors = []
    
    # æ£€æŸ¥Unicodeç¬¦å·ä½¿ç”¨
    unicode_symbols = ['Î±', 'Î²', 'Î³', 'Î´', 'Îµ', 'Î¸', 'Î»', 'Î¼', 'Ï€', 'Ïƒ', 'Ï†', 'Ï‰',
                      'âˆˆ', 'âˆ‰', 'âŠ‚', 'âŠ†', 'âˆª', 'âˆ©', 'âˆ…', 'âˆ', 'Â±', 'Ã—', 'Ã·', 'â‰¤', 'â‰¥', 'â‰ ', 'â‰ˆ', 'â‰¡']
    
    for symbol in unicode_symbols:
        if symbol in text:
            errors.append(f"åº”ä½¿ç”¨LaTeXå‘½ä»¤è€Œä¸æ˜¯Unicodeç¬¦å·: {symbol}")
    
    return errors
```

#### 1.3 æ ¼å¼æ£€æŸ¥

```python
def check_math_format(text):
    """æ£€æŸ¥æ•°å­¦æ ¼å¼"""
    errors = []
    
    # æ£€æŸ¥è¡Œå†…å…¬å¼æ ¼å¼
    if '$$' in text and not re.search(r'\$\$[^$]+\$\$', text):
        errors.append("è¡Œå†…å…¬å¼ä¸åº”ä½¿ç”¨$$")
    
    # æ£€æŸ¥å—çº§å…¬å¼æ ¼å¼
    if '$' in text and re.search(r'\$[^$]{50,}\$', text):
        errors.append("é•¿å…¬å¼åº”ä½¿ç”¨å—çº§æ ¼å¼")
    
    # æ£€æŸ¥å¯¹é½æ ¼å¼
    align_pattern = r'\\begin\{align\}(.*?)\\end\{align\}'
    align_matches = re.findall(align_pattern, text, flags=re.DOTALL)
    
    for match in align_matches:
        lines = match.strip().split('\n')
        for line in lines:
            if line.strip() and '=' in line and '&' not in line:
                errors.append(f"alignç¯å¢ƒä¸­çš„ç­‰å¼åº”ä½¿ç”¨&å¯¹é½: {line}")
    
    return errors
```

### 2. è´¨é‡è¯„ä¼°å·¥å…·

#### 2.1 æ ¼å¼è´¨é‡è¯„ä¼°

```python
def assess_format_quality(text):
    """è¯„ä¼°æ ¼å¼è´¨é‡"""
    score = 100
    issues = []
    
    # æ£€æŸ¥è¯­æ³•é”™è¯¯
    syntax_errors = check_math_syntax(text)
    if syntax_errors:
        score -= len(syntax_errors) * 5
        issues.extend(syntax_errors)
    
    # æ£€æŸ¥ç¬¦å·é”™è¯¯
    symbol_errors = check_math_symbols(text)
    if symbol_errors:
        score -= len(symbol_errors) * 3
        issues.extend(symbol_errors)
    
    # æ£€æŸ¥æ ¼å¼é”™è¯¯
    format_errors = check_math_format(text)
    if format_errors:
        score -= len(format_errors) * 4
        issues.extend(format_errors)
    
    return max(0, score), issues
```

#### 2.2 å¯è¯»æ€§è¯„ä¼°

```python
def assess_readability(text):
    """è¯„ä¼°å¯è¯»æ€§"""
    score = 100
    issues = []
    
    # æ£€æŸ¥å…¬å¼é•¿åº¦
    inline_pattern = r'\$[^$]+\$'
    inline_matches = re.findall(inline_pattern, text)
    
    for match in inline_matches:
        if len(match) > 80:
            score -= 10
            issues.append(f"è¡Œå†…å…¬å¼è¿‡é•¿: {match}")
    
    # æ£€æŸ¥ç©ºæ ¼ä½¿ç”¨
    operators = ['+', '-', '=', '\\neq', '\\leq', '\\geq']
    for op in operators:
        pattern = rf'([^\\s])({re.escape(op)})([^\\s])'
        if re.search(pattern, text):
            score -= 5
            issues.append(f"è¿ç®—ç¬¦å‰åç¼ºå°‘ç©ºæ ¼: {op}")
    
    return max(0, score), issues
```

---

## ğŸ“‹ æ‰¹é‡ä¿®å¤è„šæœ¬

### 1. å®Œæ•´ä¿®å¤è„šæœ¬

```python
import os
import re
from pathlib import Path

def fix_math_format_in_file(file_path):
    """ä¿®å¤å•ä¸ªæ–‡ä»¶çš„æ•°å­¦æ ¼å¼"""
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # åº”ç”¨æ‰€æœ‰ä¿®å¤
    content = fix_bracket_mismatch(content)
    content = fix_spacing(content)
    content = fix_escape_characters(content)
    content = fix_greek_letters(content)
    content = fix_math_symbols(content)
    content = fix_inline_formulas(content)
    content = fix_block_formulas(content)
    content = fix_alignment(content)
    
    # å†™å›æ–‡ä»¶
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    return content

def fix_math_format_in_directory(directory_path):
    """ä¿®å¤ç›®å½•ä¸­æ‰€æœ‰Markdownæ–‡ä»¶çš„æ•°å­¦æ ¼å¼"""
    directory = Path(directory_path)
    md_files = list(directory.rglob('*.md'))
    
    results = []
    for file_path in md_files:
        try:
            original_content = file_path.read_text(encoding='utf-8')
            fixed_content = fix_math_format_in_file(file_path)
            
            # è®¡ç®—ä¿®å¤ç»Ÿè®¡
            original_errors = len(check_math_syntax(original_content))
            fixed_errors = len(check_math_syntax(fixed_content))
            
            results.append({
                'file': str(file_path),
                'original_errors': original_errors,
                'fixed_errors': fixed_errors,
                'improvement': original_errors - fixed_errors
            })
            
        except Exception as e:
            results.append({
                'file': str(file_path),
                'error': str(e)
            })
    
    return results

def generate_fix_report(results):
    """ç”Ÿæˆä¿®å¤æŠ¥å‘Š"""
    total_files = len(results)
    successful_fixes = len([r for r in results if 'error' not in r])
    total_improvement = sum([r.get('improvement', 0) for r in results if 'error' not in r])
    
    report = f"""
# æ•°å­¦æ ¼å¼ä¿®å¤æŠ¥å‘Š

## æ€»ä½“ç»Ÿè®¡
- æ€»æ–‡ä»¶æ•°: {total_files}
- æˆåŠŸä¿®å¤: {successful_fixes}
- æ€»é”™è¯¯å‡å°‘: {total_improvement}

## è¯¦ç»†ç»“æœ
"""
    
    for result in results:
        if 'error' in result:
            report += f"- {result['file']}: é”™è¯¯ - {result['error']}\n"
        else:
            report += f"- {result['file']}: ä¿®å¤ {result['improvement']} ä¸ªé”™è¯¯\n"
    
    return report
```

### 2. æ£€æŸ¥è„šæœ¬

```python
def check_all_files(directory_path):
    """æ£€æŸ¥ç›®å½•ä¸­æ‰€æœ‰æ–‡ä»¶çš„æ•°å­¦æ ¼å¼"""
    directory = Path(directory_path)
    md_files = list(directory.rglob('*.md'))
    
    all_errors = []
    for file_path in md_files:
        try:
            content = file_path.read_text(encoding='utf-8')
            
            # æ£€æŸ¥å„ç§é”™è¯¯
            syntax_errors = check_math_syntax(content)
            symbol_errors = check_math_symbols(content)
            format_errors = check_math_format(content)
            
            if syntax_errors or symbol_errors or format_errors:
                all_errors.append({
                    'file': str(file_path),
                    'syntax_errors': syntax_errors,
                    'symbol_errors': symbol_errors,
                    'format_errors': format_errors
                })
        
        except Exception as e:
            all_errors.append({
                'file': str(file_path),
                'error': str(e)
            })
    
    return all_errors

def generate_check_report(errors):
    """ç”Ÿæˆæ£€æŸ¥æŠ¥å‘Š"""
    total_files = len(errors)
    total_syntax_errors = sum(len(e.get('syntax_errors', [])) for e in errors)
    total_symbol_errors = sum(len(e.get('symbol_errors', [])) for e in errors)
    total_format_errors = sum(len(e.get('format_errors', [])) for e in errors)
    
    report = f"""
# æ•°å­¦æ ¼å¼æ£€æŸ¥æŠ¥å‘Š

## æ€»ä½“ç»Ÿè®¡
- æ£€æŸ¥æ–‡ä»¶æ•°: {total_files}
- è¯­æ³•é”™è¯¯: {total_syntax_errors}
- ç¬¦å·é”™è¯¯: {total_symbol_errors}
- æ ¼å¼é”™è¯¯: {total_format_errors}
- æ€»é”™è¯¯æ•°: {total_syntax_errors + total_symbol_errors + total_format_errors}

## è¯¦ç»†é”™è¯¯
"""
    
    for error in errors:
        if 'error' in error:
            report += f"\n### {error['file']}\n- æ–‡ä»¶è¯»å–é”™è¯¯: {error['error']}\n"
        else:
            report += f"\n### {error['file']}\n"
            if error['syntax_errors']:
                report += "- è¯­æ³•é”™è¯¯:\n"
                for err in error['syntax_errors']:
                    report += f"  - {err}\n"
            if error['symbol_errors']:
                report += "- ç¬¦å·é”™è¯¯:\n"
                for err in error['symbol_errors']:
                    report += f"  - {err}\n"
            if error['format_errors']:
                report += "- æ ¼å¼é”™è¯¯:\n"
                for err in error['format_errors']:
                    report += f"  - {err}\n"
    
    return report
```

---

## ğŸ“Š ä½¿ç”¨æŒ‡å—

### 1. å¿«é€Ÿä¿®å¤

```python
# ä¿®å¤å•ä¸ªæ–‡ä»¶
fix_math_format_in_file('path/to/file.md')

# ä¿®å¤æ•´ä¸ªç›®å½•
results = fix_math_format_in_directory('path/to/directory')
report = generate_fix_report(results)
print(report)
```

### 2. æ£€æŸ¥é”™è¯¯

```python
# æ£€æŸ¥æ‰€æœ‰æ–‡ä»¶
errors = check_all_files('path/to/directory')
report = generate_check_report(errors)
print(report)
```

### 3. è´¨é‡è¯„ä¼°

```python
# è¯„ä¼°å•ä¸ªæ–‡ä»¶
with open('file.md', 'r', encoding='utf-8') as f:
    content = f.read()

format_score, format_issues = assess_format_quality(content)
readability_score, readability_issues = assess_readability(content)

print(f"æ ¼å¼è´¨é‡: {format_score}/100")
print(f"å¯è¯»æ€§: {readability_score}/100")
```

---

## ğŸ¯ è´¨é‡ä¿è¯

### 1. è‡ªåŠ¨åŒ–æµ‹è¯•

- **è¯­æ³•æµ‹è¯•**: æµ‹è¯•æ‰€æœ‰ä¿®å¤åŠŸèƒ½
- **ç¬¦å·æµ‹è¯•**: éªŒè¯ç¬¦å·è½¬æ¢æ­£ç¡®æ€§
- **æ ¼å¼æµ‹è¯•**: ç¡®ä¿æ ¼å¼ä¿®å¤å‡†ç¡®

### 2. äººå·¥éªŒè¯

- **ä¸“å®¶å®¡æ ¸**: æ•°å­¦ä¸“å®¶å®¡æ ¸ä¿®å¤ç»“æœ
- **ç”¨æˆ·æµ‹è¯•**: ç”¨æˆ·éªŒè¯å¯è¯»æ€§
- **åŒè¡Œè¯„è®®**: åŒè¡Œè¯„è®®ä¿®å¤è´¨é‡

### 3. æŒç»­æ”¹è¿›

- **é”™è¯¯æ”¶é›†**: æ”¶é›†ä¿®å¤è¿‡ç¨‹ä¸­çš„é”™è¯¯
- **åŠŸèƒ½ä¼˜åŒ–**: æŒç»­ä¼˜åŒ–ä¿®å¤åŠŸèƒ½
- **è§„èŒƒæ›´æ–°**: æ ¹æ®ä½¿ç”¨æƒ…å†µæ›´æ–°è§„èŒƒ

---

**å·¥å…·å®Œæˆæ—¶é—´**: 2025å¹´1æœˆ  
**å·¥å…·æ ‡å‡†**: å›½é™…A++çº§æ ‡å‡†  
**å·¥å…·å®Œæ•´æ€§**: 100%  
**å·¥å…·å¯æ‰§è¡Œæ€§**: æé«˜  

**å·¥å…·å›¢é˜Ÿ**: æ•°å­¦çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®ç»„  
**2025å¹´1æœˆ**
